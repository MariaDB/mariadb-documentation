<!DOCTYPE html>
<html>
<head data-cookie-domain=""
      data-cookie-path="/">
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="apple-touch-icon" sizes="180x180" href="/kb/static/images/favicons/apple-touch-icon.159e713979be.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/kb/static/images/favicons/favicon-32x32.bc0ac1d5d11e.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/kb/static/images/favicons/favicon-16x16.5801f8f0f34e.png">
    <link rel="shortcut icon" href="/kb/static/images/favicons/favicon.d122d305dee4.ico" type="image/x-icon" />

    <title>Tipi di tabelle CONNECT - File dei dati - Source - MariaDB Knowledge Base</title>

    <link href="/kb/static/css/main.f7633538c846.css" rel="stylesheet" type="text/css" />

    
        <meta name="robots" content="noindex, nofollow">
    

    

    <!-- FB Open Graph tags -->
    <meta property="og:title" content="Tipi di tabelle CONNECT - File dei dati - Source" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://mariadb.com/kb/it/connect-table-types-data-files/+source/" />
    <meta property="og:image" content="http://mariadb.comaskmonty-logo.png" />
    <meta property="og:site_name" content="MariaDB KnowledgeBase" />
    <meta property="fb:admins" content="514852603" />
    <meta property="og:description" content="" />

    <meta name="description" content="" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="//fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet"/>
    
</head>
<body class="mpkb nodes autoresize nodes_source jqui" id="nodes_source">





<div id="menu-mobile" class="visible-sm visible-xs">

    <div>
        <div id="mobile-close-menu" class="text-right">
            <a href="javascript:void(0)" title="Close Menu" id="back-main" class="toggle-menu">X<span></span></a>
        </div>
    </div>
    <div class="mainmenu-mobile">
        <ul class="ls-none ul-menu">
            <li data-sub="submenu5"><a class="open-form-search" href="/kb/search/" title="Search">Search </a></li>
            <li data-sub="submenu0"><a href="/products" title="Products">Products</a><span class="arrow-main"></span></li>
            <li data-sub="submenu1"><a href="/services" title="Services">Services</a><span class="arrow-main"></span></li>
            <li data-sub="submenu2"><a href="/resources" title="Resources">Resources</a><span class="arrow-main"></span></li>
            <li data-sub="submenu3"><a href="/about-us" title="About">About</a><span class="arrow-main"></span></li>
            <li data-sub="submenu4"><a href="/contact" title="Contact">Contact</a></li>
        </ul>
    </div>

    <div class="nav-top-mobile">
        <div class="select-box form">

            <ul class="inline-block-md mb-none top-nav">
                <li>

                </li>
                
                    <li>
                        <a href="/kb/user/login?next=/kb/it/connect-table-types-data-files/+source/"> Login</a>
                    </li>
                
            </ul>



        </div>
        <p class="text-center copyright">Copyright &copy; 2025 MariaDB. All rights reserved.</p>
    </div>
</div>
<div class="violator-wrap d-none" id="top_violator">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12">
                <div class="violator-outer">
                    <div class="violator-inner">
                        <div class="row">
                            <div class="col-xs-12 col-sm-9 col-lg-7 col-lg-offset-2" id="top_violator_content">
                                <a href="https://go.mariadb.com/high-availability-guide-MariaDB-whitepaper.html" class="content-link" target="_blank" rel="nofollow noreferrer">
                                    <span>The Ultimate Guide to High Availability with MariaDB</span>
                                </a>
                            </div>
                            <div class="col-xs-12 col-sm-3" id="top_violator_cta">
                                <a href="https://go.mariadb.com/high-availability-guide-MariaDB-whitepaper.html" class="btn btn-mariadb" target="_blank" rel="nofollow noreferrer">Download Now</a>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="btn btn-link close-btn">
                        <svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 24 24" width="15px" height="15px"><path d="M 4.9902344 3.9902344 A 1.0001 1.0001 0 0 0 4.2929688 5.7070312 L 10.585938 12 L 4.2929688 18.292969 A 1.0001 1.0001 0 1 0 5.7070312 19.707031 L 12 13.414062 L 18.292969 19.707031 A 1.0001 1.0001 0 1 0 19.707031 18.292969 L 13.414062 12 L 19.707031 5.7070312 A 1.0001 1.0001 0 0 0 18.980469 3.9902344 A 1.0001 1.0001 0 0 0 18.292969 4.2929688 L 12 10.585938 L 5.7070312 4.2929688 A 1.0001 1.0001 0 0 0 4.9902344 3.9902344 z"/></svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="wrapper">
<div id="top-nav">
    <div class="container">
        <ul class="hidden-sm hidden-xs" >
            <li><a href="https://mariadb.com/kb/">Knowledge Base</a></li>
            <li><a href="https://mariadb.com/contact/">Contact</a></li>
            
                
                    <li>
                        <a href="/kb/user/login?next=/kb/it/connect-table-types-data-files/+source/" rel="nofollow">Accesso</a>
                    </li>
                
            
            
            <li id="search-form">
                <form action="/kb/it/+search/" method="get" id="search-block-form" accept-charset="UTF-8">
                    <input id="search" title="Enter the terms you wish to search for."
                           placeholder="Search . . ." type="text"
                           name="q" value="" size="15" maxlength="128" class="form-text"
                           data-autocomplete-url="/kb/it/+search/autocomplete/">
                    <input type="hidden" name="quick" value="1" />
                    <input type="hidden" name="source" value="kb" />
                </form>
            </li>
            <li><a id="search-toggler" href="/kb/search/">Search</a></li>
            
        </ul>
    </div>
</div>
<div id="navbar-bottom" class="navbar">
    <div class="container">
        
        
        
        
        <div class="row">
            <div class="col-md-3 col-sm-9 col-xs-9">
                <a class="brand" href="/" title="MariaDB">
                    <img src="/kb/static/images/logo-2018-black.95f5978ae14d.png">
                </a>
            </div>
            <div class="col-md-9 hidden-sm hidden-xs">
                <div class="main-menu">
                    <ul id="main-menu" class="nav navbar-nav inline-block-sm">
    <li class="has-sub full-menu">
        <a href="/products" title="Products">Products</a>
    </li>
    <li class="has-sub full-menu active">
        <a href="/solutions" title="Solutions">Solutions</a>
    </li>
    <li class="has-sub full-menu">
        <a href="/resources" title="Resources">Resources</a>
    </li>
    <li class="has-sub full-menu">
        <a href="/about-us" title="Company">Company</a>
    </li>
    <li class="has-sub full-menu active">
        <a href="/pricing" title="Pricing">Pricing</a>
    </li>
    
    <li class="">
        <a class="button electric-eel small top-bar-right-download" href="/downloads/">Download</a>
    </li>
</ul>
                </div>
            </div>
            <div class="col-md-3 visible-sm visible-xs col-sm-3 col-xs-3 ps-rv">
                <div class="navbar-header text-right pull-right">
                    <button type="button" class="menu-control toggle-menu" id="open-menu">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="main">
    <div class="container">
        

        <div id="subheader1" class="clearfix">
            <div class="pull-left">
                
                <div id="breadcrumbs" class="breadcrumb">
                    <a href="/kb/it/">Knowledge Base</a>
                    


    
    » <a class="crumb" href="/kb/it/mariadb-italiano/">MariaDB - Italiano</a>
    

    
    » <a class="crumb" href="/kb/it/storage-engine/">Storage Engine</a>
    

    
    » <a class="crumb" href="/kb/it/connect/">Connect</a>
    

    
    » <a class="crumb" href="/kb/it/connect-table-types/">CONNECT Table Types</a>
    


    » <a class="node_link crumb" href="/kb/it/connect-table-types-data-files/">Tipi di tabelle CONNECT - File dei dati</a>


                </div>
                
            </div>
        </div>
    </div>
    <div class="container" id="container-main">
        <div class="row">
            
            
                
                <aside id="sidebar-first" class="sidebar col-md-2 hidden-xs hidden-sm hidden-print">
                    
                        
                        <ul id="category_menu" class="nav nav-pills nav-stacked">
                            <li><a href="/kb/it/">Pagina iniziale</a></li>
                            
                                
                                    <li><a href="/kb/it/+questions/">Domande Aperte</a></li>
                                
                                <li><a href="/kb/it/documentation/">MariaDB Server</a></li>
                                <li><a href="/kb/it/maxscale/">MariaDB MaxScale</a></li>
                                <li><a href="/kb/it/mariadb-columnstore/">MariaDB ColumnStore</a></li>
                                <li><a href="/kb/it/connectors/">Connectors</a></li>
                            

                        </ul>
                    

                    
                        <div>
    

<div class="well well-small box actions"><div>

        <a class="btn btn-block btn-small" href="/kb/it/connect-table-types-data-files/">Return to article</a>
    
</div>
</div>

</div>
                    

                    

































                </aside>
            
            
            
                
            
            
            <section id="content" class="limited_width col-md-10 clearfix">
                
                    <h1>Tipi di tabelle CONNECT - File dei dati - Source</h1>
                

                



                <div>
                    

    

    
    <div class="revision_info">
        <dl class="table">
            <dt>Revisione</dt>
            <dd><a href="/kb/it/connect-table-types-data-files/+r/17120/">17120</a></dd>
            <dt>Utente</dt>
            <dd>
<span class="user" id="user-982">
<a href="/kb/user/id/982" title="Federico Razzoli">Federico Razzoli</a>
</span></dd>
            <dt>Data</dt>
            <dd>

<span class="datetime" title="2013-06-30 18:26">2013-06-30 18:26</span></dd>
        </dl>
    </div>
    


    

    
        
        <textarea id="answer_source" class="creole_source autogrow">&lt;&lt;toc&gt;&gt;
La maggior parte delle tabelle elaborate da CONNECT sono semplici file DOS o UNIX, logicamente considerate tabelle grazie alla loro descrizione fornita durante la creazione della tabella. Questa descrizione viene dall&#39;istruzione ##[[https://kb.askmonty.org/it/create-table/|CREATE TABLE]]##. A seconda dell&#39;applicazione, queste tabelle possono essere già esistenti come file, e quindi utilizzate così come sono da CONNECT, oppure possono essere create fisicamente da CONNECT in seguito all&#39;istruzione ##CREATE TABLE ... SELECT ...## e/o INSERT.

Il file //percorso/nome// è specificato con l&#39;opzione ##FILE_NAME##. Se il percorso è relativo, sarà considerato relativo alla directory del database, cioè quella che contiene il file .FRM.

== Tabelle interne
Un tipo particolare di tabelle CONNECT basate sui file sono le tabelle &#34;interne&#34;. Queste sono create quando il nome del file viene specificato nell&#39;istruzione ##[[https://kb.askmonty.org/it/create-table/|CREATE TABLE]]##. Il nome di default è //nome_tabella.tip// dove //nome_tabella// è il nome della tabella e //tip// è il tipo di tabella in caratteri minuscoli. Un file vuoto viene creato nella directory del database corrente al momento della creazione e viene popolato con i successivi inserimenti.

Queste tabelle si comportano come quelle create dagli altri Storage Engine e, diversamente da quanto avviene con le altre tabelle CONNECT, i file vengono cancellati quando la tabella viene eliminata. Naturalmente per poter essere usate non devono essere di sola lettura. Anche se la loro usabilità è limitata, possono essere utilizzate per scopo di testing o se l&#39;utente non ha il privilegio ##FILE##.

== Tabelle con file multipli
Una tabella con file **multipli** è una tabelle che fisicamente è contenuta da diversi file dello stesso tipo, non uno solo. Questi file vengono elaborati in sequenza durante l&#39;esecuzione delle query e il risultato è lo stesso che si otterrebbe se ci fosse un unico file. Ciò è utile per elaborare i file che vengono da diverse fonti (come i file di log dei crash) o creati in diversi periodi di tempo (come i report mensili della banca) e che devono essere considerati come un&#39;unica tabella. Si noti che le operazioni su tali file sono limitate alle SELECT e alle UPDATE sequenziali; e che le tabelle multiple VEC non sono supportate da CONNECT. La lista dei file dipende dall&#39;impostazione dell&#39;opzione **multiple** nell&#39;istruzione CREATE TABLE.

Le tabelle multiple si creano con MULTIPLE=//n//, che può assumere tre valori:

| 0 | Una tabella non multipla (il default). Si può utilizzare in una ALTER TABLE.
| 1 | La tabella è composta da file che si trovano nella stessa directory. L&#39;opzione FILE_NAME è una schema come ##&#39;cash*.log&#39;## che deve corrispondere a tutte le tabelle desiderate.
| 2 | FILE_NAME è il nome di un file che contiene tutti i percorsi e i nomi dei file che compongono la tabella. Questo file può essere creato utilizzando una tabella DIR.

La colonna speciale ##FILEID##, spiegata
[[using-connect-virtual-and-special-columns|qui]], permette di filtrare l&#39;elenco dei file o eseguire qualche raggruppamento sui file che compongono una tabella multipla.

== Il mapping dei file
Per le tabelle basate sui file di dimensioni ragionevoli, il tempo di elaborazione può essere ridotto sensibilmente sotto WindowsTM o alcuni sistemi UNIX e Linux utilizzando la tecnica del “file mapping”, che consiste nell&#39;elaborare un file come se si trovasse interamente in memoria. Il mapping viene specificato al momento della creazione della tabella tramite l&#39;opzione ##MAPPED=YES##. Questa non si applica alle tabelle che non sono gestite dalle funzioni di I/O del sistema (##XML## e ##INI##).

== Tabelle basate su file grandi
Siccome tutti i file sono festiti dalle funzioni standard di input/output del sistema operativo, their le loro dimensioni sono limitate a 2GB, cioè le dimensioni massime consentite da tali funzioni. Per alcuni tipi di tabelle, CONNECT può gestire file che sono più grandi di 2GB o che potrebbero superare questo limite. Questi tipi sono FIX, BIN e  VEC. Per dire a CONNECT di utilizzare le funzioni di input/output in grado di gestire file grandi, si specifica l&#39;opzione ##huge=1## o ##huge=YES##. Si noti però che CONNECT non può effettuare l&#39;accesso casuale su tabelle che superano i 2G.

== Compressed Table Tables
CONNECT can make and processed some tables whose data file is compressed. The
only supported compression format is the gzlib format. Zip and zlib formats are
not supported. The table types that can be compressed are DOS, FIX, BIN, CSV
and FMT. This can save some disk space at the cost of a somewhat longer
processing time.

Some restrictions apply to compressed tables:

* Compressed tables are not indexable.

* Update and partial delete are not supported.

Use the Boolean COMPRESS option to specify a compressed table.

== DOS and FIX Table Types

Table of type DOS are based on text files in which each record represents a
table row. Within a record, column fields are positioned at a fixed offset from
the beginning of the record. Except sometimes for the last field, column fields
are also of fixed length. If the last field has varying length, the type of the
table is DOS. For instance, having the file //dept.dat// formatted like:

&lt;&lt;code&gt;&gt;
0318 KINGSTON       70012 SALES       Bank/Insurance
0021 ARMONK         87777 CHQ         Corporate headquarter
0319 HARRISON       40567 SALES       Federal Administration
2452 POUGHKEEPSIE   31416 DEVELOPMENT Research &amp; development
&lt;&lt;/code&gt;&gt;

You can define a table based on it with:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table department (
  number char(4) not null,
  location char(15) not null flag=5,
  director char(5) not null flag=20,
  function char(12) not null flag=26,
  name char(22) not null flag=38)
engine=CONNECT table_type=DOS file_name=&#39;dept.dat&#39;;
&lt;&lt;/code&gt;&gt;

Here the flag column option represents the offset of this column inside the
records. If the offset of a column is not specified, it defaults to the end of
the previous column and defaults to 0 for the first one.  The //lrecl//
parameter that represents the maximum size of a record is calculated by default
as the end of the rightmost column and can be unspecified except when some
trailing information exists after the rightmost column.

&lt;&lt;style class=&#34;bluebox&#34;&gt;&gt;
**Note:** A special case is files having an encoding such as UTF-8 (for
instance specifying ##charset=UTF8##) in which some characters may be
represented with several bytes. Unlike the type size that MariaDB interprets as
a number of characters, the lrecl value is the record size in bytes and the
flag value represents the offset of the field in the record in bytes. If the
flag and/or the lrecl value are not specified, they will be calculated by the
number of character in the fields multiplied by a value that is the maximum
size in bytes of a character for the corresponding charset. For UTF-8 this
value is 3 that is far too much as they are very few characters requiring 3
bytes to be represented. When creating a new file, you are on the safe side by
only doubling the maximum number of characters of a field to calculate the
offset of the next field. Of course, for already existing files, the offset
must be specified according to what it is in it.
&lt;&lt;/style&gt;&gt;

Although the field representation is always text in the table file, you can
freely choose the corresponding column type, characters, date, integer or
floating point according to its contents.

Sometimes, as in the //number// column of the above //department// table, you
have the choice of the type, numeric or characters. This will modify how the
column is internally handled &lt;&lt;entity&gt;&gt;mdash&lt;&lt;/entity&gt;&gt; in characters 0021 is
different from 21 but not in numeric &lt;&lt;entity&gt;&gt;mdash&lt;&lt;/entity&gt;&gt; as well as how
it is displayed.

If the last field has fixed length, the table should be referred as having the
type FIX. For instance, to create a table on the file //boys.txt//:

&lt;&lt;code&gt;&gt;
John      Boston      25/01/1986  02/06/2010
Henry     Boston      07/06/1987  01/04/2008
George    San Jose    10/08/1981  02/06/2010
Sam       Chicago     22/11/1979  10/10/2007
James     Dallas      13/05/1992  14/12/2009
Bill      Boston      11/09/1986  10/02/2008
&lt;&lt;/code&gt;&gt;

You can for instance use the command:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table boys (
  name char(12) not null,
  city char(12) not null,
  birth date not null date_format=&#39;DD/MM/YYYY&#39;,
  hired date not null date_format=&#39;DD/MM/YYYY&#39; flag=36)
engine=CONNECT table_type=FIX file_name=&#39;boys.txt&#39; lrecl=48;
&lt;&lt;/code&gt;&gt;

Here some //flag// options were not specified because the fields have no
intermediate space between them except for the last column. The offsets are
calculated by default adding the field length to the //offset// of the
preceding field. However, for formatted date columns, the offset in the file
depends on the format and cannot be calculated by default. For fixed files,
the //lrecl// option is the physical length of the record including the line
ending character(s). It is calculated by adding to the end of the last field 2
bytes under Windows (CRLF) or 1 byte under UNIX. If the file is imported from
another operating system, the ##ENDING## option will have to be specified with
the proper value.

For this table, the last offset and the record length must be specified anyway
because the date columns have field length coming from their format that is not
known by CONNECT. Do not forget to add the line ending length to the total
length of the fields.

This table is displayed as:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= name  |= city    |= birth     |= hired
| John   | Boston   | 1986-01-25 | 2010-06-02
| Henry  | Boston   | 1987-06-07 | 2008-04-01
| George | San Jose | 1981-08-10 | 2010-06-02
| Sam    | Chicago  | 1979-11-22 | 2007-10-10
| James  | Dallas   | 1992-05-13 | 2009-12-14
| Bill   | Boston   | 1986-09-11 | 2008-02-10
&lt;&lt;/style&gt;&gt;

Whenever possible, the fixed format should be preferred to the varying one
because it is much faster to deal with fixed tables than with variable tables.
Sure enough, instead of being read or written record by record, FIX tables are
processed by blocks of ##BLOCK_SIZE## records, resulting in far less
input/output operations to execute. The block size defaults to 100 if not
specified in the Create Table statement.

**Note 1:** It is not mandatory to declare in the table all the fields existing
in the source file. However, if some fields are ignored, the //flag// option of
the following field and/or the //lrecl// option will have to be specified.

**Note 2:** Some files have an EOF marker (CTRL+Z 1A) that can prevent the
table to be recognized as fixed because the file length is not a multiple of
the fixed record size. To indicate this, use in the option list the create
option EOF. For instance, if after creating the FIX table //xtab// on the
file //foo.dat// that you know have fixed record size, you get, when you try to
use it, a message such as:

&lt;&lt;code&gt;&gt;
File foo.dat is not fixed length, len=302587 lrecl=141
&lt;&lt;/code&gt;&gt;

After checking that the LRECL default or specified specification is correct, you can indicate to ignore that extra EOF character by:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
alter table xtab option_list=&#39;eof=1&#39;;
&lt;&lt;/code&gt;&gt;

Of course, you can specify this option directly in the Create statement. All
this applies to some other table types, in particular to BIN tables.

**Note 3:** The width of the fields is the length specified in the column
declaration. For instance for a column declared as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
number int(3) not null,
&lt;&lt;/code&gt;&gt;

The field width in the file is 3 characters. This is the value used to
calculate the offset of the next field if it is not specified. If this length
is not specified, it defaults to the MySQL default type length.

=== Specifying the Field Format
Some files have specific format for their numeric fields. For instance, the
decimal point is absent and/or the field should be filled with leading zeros.
To deal with such files, as well in reading as in writing, the format can be
specified in the ##CREATE TABLE## column definition. The syntax of the field
format specification is:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
Field_format=&#39;[Z][N][d]&#39;
&lt;&lt;/code&gt;&gt;

The optional parts of the format are:
| **Z**     | The field has leading zeros
| **N**     | No decimal point exist in the file
| **//d//** | The number of decimals, defaults to the column precision

Let us see how it works in the following example. We define a table based on
the file xfmt.txt having eight fields of 12 characters:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table xfmt (
  col1 double(12,3) not null,
  col2 double(12,3) not null field_format=&#39;4&#39;,
  col3 double(12,2) not null field_format=&#39;N3&#39;,
  col4 double(12,3) not null field_format=&#39;Z&#39;,
  col5 double(12,3) not null field_format=&#39;Z3&#39;,
  col6 double(12,5) not null field_format=&#39;ZN5&#39;,
  col7 int(12) not null field_format=&#39;N3&#39;,
  col8 smallint(12) not null field_format=&#39;N3&#39;)
engine=CONNECT table_type=FIX file_name=&#39;xfmt.txt&#39;;

insert into xfmt values(4567.056,4567.056,4567.056,4567.056,-23456.8,
    3.14159,4567,4567);
select * from xfmt;
&lt;&lt;/code&gt;&gt;

The first row is displayed as:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= COL1    |= COL2    |= COL3   |= COL4    |= COL5      |= COL6   |= COL7 |= COL8
| 4567.056 | 4567.056 | 4567.06 | 4567.056 | -23456.800 | 3.14159 | 4567  | 4567
&lt;&lt;/style&gt;&gt;

The number of decimals displayed for all float columns is the column precision, the second argument of the column type option. Of course, integer columns have no decimals, although their formats specify some.

More interesting is the file layout. To see it let us define another table
based on the same file but whose columns are all characters:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table cfmt (
  col1 char(12) not null,
  col2 char(12) not null,
  col3 char(12) not null,
  col4 char(12) not null,
  col5 char(12) not null,
  col6 char(12) not null,
  col7 char(12) not null,
  col8 char(12) not null)
engine=CONNECT table_type=FIX file_name=&#39;xfmt.txt&#39;;
select * from cfmt;
&lt;&lt;/code&gt;&gt;

The (transposed) display of the select command shows the file text layout for
each field. Below a third column was added in this document to comment this
result.

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Column  |= Row 1           |= Comment (all numeric fields are written right justified)
| **COL1** | ##4567.056##     | No format, the value was entered as is.
| **COL2** | ##4567.0560##    | The format ‘4’ forces to write 4 decimals.
| **COL3** | ##4567060##      | N3 → No decimal point. The last 3 digits are decimals. However, the second decimal was rounded because of the column precision.
| **COL4** | ##00004567.056## | Z → Leading zeros, 3 decimals (the column precision)
| **COL5** | ##-0023456.800## | Z3 → (Minus sign) leading zeros, 3 decimals.
| **COL6** | ##000000314159## | ZN5 → Leading zeros, no decimal point, 5 decimals.
| **COL7** | ##4567000##      | N3 → No decimal point. The last 3 digits are decimals.
| **COL8** | ##4567000##      | Same. Any decimals would be ignored.
&lt;&lt;/style&gt;&gt;

**Note:** For columns internally using double precision floating-point numbers,
MariaDB limits the decimal precision of any calculation to the column
precision. The declared column precision should be at least the number of
decimals of the format to avoid a loss of decimals as it happened for col3 of
the above example.

== DBF Type
A table of type ##DBF## is physically a dBASE III or IV formatted file (used by
many products like dBASE, Xbase, FoxPro etc.). This format is similar to the
FIX type format with in addition a prefix giving the characteristics of the
file, describing in particular all the fields (columns) of the table.

Because ##DBF## files have a header that contains Meta data about the file, in
particular the column description, it is possible to create a table based on an
existing ##DBF## file without giving the column description, for instance:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table cust engine=CONNECT table_type=DBF file_name=&#39;cust.dbf&#39;;
&lt;&lt;/code&gt;&gt;

To see what CONNECT has done, you can use the ##DESCRIBE##
or ##SHOW CREATE TABLE## commands, and eventually modify some options with
the ##ALTER TABLE## command.

The case of deleted lines is handled in a specific way for DBF tables. Deleted
lines are not removed from the file but are &#34;soft deleted&#34; meaning they are
marked as deleted. In particular, the number of lines contained in the file
header does not take care of soft deleted lines. This is why if you execute
these two commands applied to a DBF table named //tabdbf//:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select count(*) from tabdbf;
select count(*) from tabdbf where 1;
&lt;&lt;/code&gt;&gt;

They can give a different result, the (fast) first one giving the number of physical lines in the file and the second one giving the number of line that are not (soft) deleted.

The commands UPDATE, INSERT, and DELETE can be used with DBF tables. The DELETE command marks the deleted lines as suppressed but keeps them in the file. The INSERT command, if it is used to populate a newly created table, constructs the file header before inserting new lines.

**Note:** For DBF tables, column name length is limited to 11 characters and field length to 256 bytes.

=== Reading Soft Deleted Lines of a DBF table
It is possible to read these lines by changing the read mode of the table. This is specified by an option ##READMODE## that can take the values:

| **0** | Standard mode. This is the default option.
| **1** | Read all lines including soft deleted ones.
| **2** | Read only the soft deleted lines.

For example, to read all lines of the tabdbf table, you can do:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
alter table tabdbf option_list=&#39;Readmode=1&#39;;
&lt;&lt;/code&gt;&gt;

To come back to normal mode, specify READMODE=0.

== BIN Table Type
A table of type BIN is physically a binary file in which each row is a logical record of fixed length&lt;&lt;ref&gt;&gt;Sometimes it can be a physical record if LF or CRLF have been written in the file.&lt;&lt;/ref&gt;&gt;. Within a record, column field are of fixed offset and length like for FIX tables. What is specific to BIN tables is that numerical values are internally encoded using native platform representation, so no conversion is needed to handle numerical values in expressions.

It is not required that the lines of a BIN file be separated by characters such as CR and/or LF but this is possible. In such event, the //lrecl// option must be specified accordingly.

**Note:** Unlike for the DOS and FIX types, the width of the fields is the length of their internal representation in the file. For instance for a column declared as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
number int(5) not null,
&lt;&lt;/code&gt;&gt;

The field width in the file is 4 characters, the size of a binary integer. This is the value used to calculate the offset of the next field if it is not specified. Therefore, if the next field is placed 5 characters after this one, this declaration is not enough, the flag option will have to be used on the next field.

=== Type Conversion in BIN Tables
Here are the correspondences between the column type and field format provided by default:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Column type    |= File default format
| Char(//n//)     | Text of //n// characters.
| Date            | Integer (4 bytes)
| Int(//n//)      | Integer (4 bytes)
| Smallint(//n//) | Short integer (2 bytes)
| Bigint(//n//)   | Large integer (8 bytes)
| Double(//n,d//) | Double floating point (8 bytes)
&lt;&lt;/style&gt;&gt;

However, the column type must not necessarily match the field format within the table file. In particular, this occurs for field formats that correspond to numeric types that are not handled by CONNECT. Indeed, BIN table files may internally contain tiny integers, short integers, or float numbers. Also, as in DOS or FIX tables, you may want to handles as numeric some character fields or vice versa.

This is why it is possible to specify the field format when it does not correspond to the column type default using the field_format column option in the CREATE TABLE statement. Here are the available field formats for BIN tables:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Field_format |= Internal representation
| C             | Characters string (//n// bytes)
| L or I        | (Long) integer (4 bytes)
| D             | Double float (8 bytes)
| S             | Short integer (2 bytes)
| B             | Large (big) integer (8 bytes)
| T             | Tiny integer (1 byte)
| F or R        | Real or float (Floating point number on 4 bytes)
| X             | Use the default format field for the column type
&lt;&lt;/style&gt;&gt;

All field formats are a one-character specification&lt;&lt;ref&gt;&gt;It can be specified with more than one character, but the first one only is significant.&lt;&lt;/ref&gt;&gt;. &#39;X&#39; is equivalent to not specifying the field format. For the &#39;C&#39; character specification, //n// is the column width as specified with the column type. The number of bytes of the numeric fields corresponds to what it is on most platforms. However, it could vary for some ones.

Here is an example of a BIN table, the file record layout is supposed to be:

&lt;&lt;code&gt;&gt;
NNNNCCCCCCCCCCIIIISSFFFFSS
&lt;&lt;/code&gt;&gt;

Where N represents numeric characters, C any characters, I integer bytes,
S short integer bytes, and F float number bytes. The ##IIII## field contains a
date in numeric format.

The table could be created by:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table testbal (
  fig int(4) not null field_format=&#39;C&#39;,
  name char(10) not null,
  birth date not null,
  id char(5) not null field_format=&#39;S&#39;,
  salary double(9,2) not null default 0.00 field_format=&#39;F&#39;,
  dept int(4) not null field_format=&#39;S&#39;)
engine=CONNECT table_type=BIN block_size=5 file_name=&#39;Testbal.dat&#39;;
&lt;&lt;/code&gt;&gt;

The field offsets and the file record length being calculated according the
column internal format, eventually modified by the field format, it is not
necessary to specify them for a packed binary file without line ending. If line
ending are desired, specify the lrecl option adding the ending width. The table
can be filled by:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
insert into testbal values
  (5500,&#39;ARCHIBALD&#39;,&#39;1980-01-25&#39;,&#39;3789&#39;,4380.50,318),
  (123,&#39;OLIVER&#39;,&#39;1953-08-10&#39;,&#39;23456&#39;,3400.68,2158),
  (3123,&#39;FOO&#39;,&#39;2002-07-23&#39;,&#39;888&#39;,default,318);
&lt;&lt;/code&gt;&gt;

Note that the types of the inserted values must match the column type, not the field format type.

The query:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from testbal;
&lt;&lt;/code&gt;&gt;

Returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= fig |= name     |= birth     |= id   |= salary |= dept
| 5500 | ARCHIBALD | 1980-01-25 | 3789  | 4380.50 | 318
| 123  | OLIVER    | 1953-08-10 | 23456 | 3400.68 | 2158
| 3123 | FOO       | 2002-07-23 | 888   | 0.00    | 318
&lt;&lt;/style&gt;&gt;

=== Numeric fields alignment
In binary files, numeric fields and record length are by default aligned on 8-bytes boundaries to optimize performances with some processors. This can be modified in the OPTION_LIST with an &#34;align&#34; option (or &#34;packed&#34; meaning align=1).

== VEC Table Type (Vector)
Tables of type ##VEC## are binary files that in some cases can provide good
performance on read-intensive query workloads. CONNECT organizes their data on
disk as columns of values from the same attribute, as opposed to storing it as
rows of tabular records. This organization means that when a query needs to
access only a few columns of a particular table, only those columns need to be
read from disk. Conversely, in a row-oriented table, all values in a table are
typically read from disk, and wasting I/O bandwidth.

CONNECT provides two integral VEC formats, in which each column data is
adjacent. The block semi-vector format, in which records are grouped by blocks
while column data is only adjacent into each block, is not supported by this
version.

=== Integral Vector Format
In this true vertical format, the VEC files are made of all the data of the
first column, followed by all the data of the second column etc. All this can
be in one physical file or each column data can be in a separate file. In the
first case, the option MAX_ROWS=//m//, where //m// is the estimate of the
maximum size (number of rows) of the table, must be specified to be able to
insert some new records. This leaves an empty space after each column area in
which new data can be inserted. In the second case, the &#34;Split&#34; option must be
specified at table creation and each columns will be stored in a file named
sequentially from the table file name followed by the rank of the column.
Inserting new lines can freely augment such a table.

=== Semi-Vector Format (not supported in this version)
In this format the VCT files are organized in blocks each containing the data of n rows, n being the Elements value. Within each block, data is organized column wise, a vector of n values for the first column followed by a vector of n values for the second column etc. When inserting new line, new blocks can be created.

=== Differences between vector formats
These formats correspond to different needs. The integral vector format provides the best performance gain. It will be chosen when the speed of decisional queries must be optimized.

In the case of a unique file, inserting new data will be limited but there will be only one open and close to do. However, the size of the table cannot be calculated from the file size because of the eventual unused space in the file. It must be kept in a header containing the maximum number of rows and the current number of valid rows in the table. To achieve this, specify the option Header=n when creating the table. If n=1 the header will be placed at the beginning of the file, if n=2 it will be a separate file with the type ‘.blk’, and if n=3 the header will be place at the end of the file. This last value is provided because batch inserting is sometimes slower when the header is at the beginning of the file. If not specified, the header option will default to 2 for this table type.

On the other hand, the &#34;Split&#34; format with separate files have none of these issues, and is a much safer solution when the table must frequently inserted or shared among several users.

The semi-vector format (VCT) can be used when the table must be in only one file but made progressively by successive inserts without size limitation, with somewhat reduced performance. This format is mainly kept to be compatible with tables files made with older versions of PlugDB.

In the integral vertical formats, the option BLOCK_SIZE=//n// is used for block reading and writing; however, to have a file made of blocks of equal size, the internal value of the MAX_ROWS=//m// option is eventually increased to become a multiple of //n//.

Like for BIN tables, numeric values are stored using platform internal layout, the correspondence between column types and internal format being the same than the default ones given above for BIN. However, field formats are not available for VEC tables.

=== Header Option
This applies to not split VEC tables. Because the file size depends on the MAX_ROWS value, CONNECT cannot know how many valid records exist in the file. Depending on the value of the HEADER option, this information is stored in a header that can be placed at the beginning of the file, at the end of the file or in a separate file called fn.blk. The valid values for the HEADER option are:

| 0 | Defaults to 2 for standard tables and to 3 for inward tables.
| 1 | The header is at the beginning of the file.
| 2 | The header is in a separate file.
| 3 | The header is at the end of the file.

The value 2 can be used when dealing with files created by another application with no header. The value 3 makes sometimes inserting in the file faster than when the header is at the beginning of the file.

== CSV and FMT Table Types
Many source data files are formatted with variable length fields and records.
The simplest format, known as ##CSV## (Comma Separated Variables), has column
fields separated by a separator character. By default, the separator is a comma
but can be specified by the SEP_CHAR option as any character, for instance a
semi-colon.

If the CSV file first record is the list of column names, specifying the
##HEADER=1## option will skip the first record on reading. On writing, if the
file is empty, the column names record is automatically written.

For instance, given the following //people.csv// file:

&lt;&lt;code&gt;&gt;
Name;birth;children
&#34;Archibald&#34;;17/05/01;3
&#34;Nabucho&#34;;12/08/03;2
&lt;&lt;/code&gt;&gt;

You can create the corresponding table by:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table people (
  name char(12) not null,
  birth date not null date_format=&#39;DD/MM/YY&#39;,
  children smallint(2) not null)
engine=CONNECT table_type=CSV file_name=&#39;people.csv&#39;
header=1 sep_char=&#39;;&#39; quoted=1;
&lt;&lt;/code&gt;&gt;

For CSV tables, the //flag// column option is the rank of the column into the file starting from 1 for the leftmost column. This is to enable having column displayed in a different order than in the file and/or to define the table specifying only some columns of the CSV file. For instance:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table people (
  name char(12) not null,
  children smallint(2) not null flag=3,
  birth date not null flag=2 date_format=&#39;DD/MM/YY&#39;)
engine=CONNECT table_type=CSV file_name=&#39;people.csv&#39;
header=1 sep_char=&#39;;&#39; quoted=1;
&lt;&lt;/code&gt;&gt;

In this case the command:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from people;
&lt;&lt;/code&gt;&gt;

will display the table as:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= name     |= children |= birth
| Archibald | 3         | 2001-05-17
| Nabucho   | 2         | 2003-08-12
&lt;&lt;/style&gt;&gt;

Many applications produce CSV files having some fields quoted, in particular
because the field text contains the separator character. For such files,
specify the &#39;QUOTED=//n//&#39; option to indicate the level of quoting and/or
the &#39;##QCHAR=c##&#39; to specify what is this eventual quoting character, which is
&#34; by default. Quoting with single quotes must be specified as ##QCHAR=&#39;&#39;&#39;&#39;##.
On writing, fields will be quoted depending on the value of the quoting level,
which is –1 by default meaning no quoting:

| 0 | The fields between quotes are read and the quotes discarded. On writing, fields will be quoted only if they contain the separator character or begin with the quoting character. If they contain the quoting character, it will be doubled.
| 1 | Only text fields will be written between quotes, except null fields. This includes also the column names of an eventual header.
| 2 | All fields will be written between quotes, except null fields.
| 3 | All fields will be written between quotes, including null fields.

Files written this way are successfully read by most applications including spreadsheets.

**Note 1:** If only the QCHAR option is specified, the QUOTED option will
default to 1.

**Note 2:** For CSV tables whose separator is the tab character, specify
##sep_char=&#39;\t&#39;##.

**Note 3:** When creating a table on an existing CSV file, you can leave
CONNECT analyze the file and make the column description. However, this is a
not an elaborate analysis of the file and, for instance, ##DATE## fields will
not be recognized as such but will be regarded as string fields.

=== FMT type
FMT tables handle files of various formats that are an extension of the concept
of CSV files. CONNECT supports these files providing all lines have the same
format and that all fields present in all records are recognizable (optional
fields must have recognizable delimiters). These files are made by specific
application and CONNECT handle them in read only mode.

FMT tables must be created as CSV tables, specifying their type as FMT. In
addition, each column description must be added its format specification.

=== Column Format Specification of FMT tables
The input format for each column is specified as a FIELD_FORMAT option. A
simple example is:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
IP Char(15) not null field_format=&#39; %n%s%n&#39;,
&lt;&lt;/code&gt;&gt;

In the above example, the format for this (1st) field is ##&#39; %n%s%n&#39;##. Note
that the blank character at the beginning of this format is significant. No
trailing blank should be specified in the column formats.

The syntax and meaning of the column input format is the one of the C **scanf**
function.

However, CONNECT uses the input format in a specific way. Instead of using it
to directly store the input value in the column buffer; it uses it to delimit
the sub string of the input record that contains the corresponding column
value. Retrieving this value is done later by the column functions as for
standard CSV files.

This is why all column formats are made of five components:

# An eventual description of what is met and ignored before the column value.
# A marker of the beginning of the column value written as %n.
# The format specification of the column value itself.
# A marker of the end of the column value written as %n (or %m for optional fields).
# An eventual description of what is met after the column value (not valid is %m was used).

For example, taking the file //funny.txt//:

&lt;&lt;code&gt;&gt;
12345,&#39;BERTRAND&#39;,#200;5009.13
 56, &#39;POIROT-DELMOTTE&#39; ,#4256 ;18009
345 ,&#39;TRUCMUCHE&#39; , #67; 19000.25
&lt;&lt;/code&gt;&gt;

You can make a table //fmtsample// with 4 columns ID, NAME, DEPNO and SALARY, using the Create
Table statement and column formats:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table FMTSAMPLE (
  ID Integer(5) not null field_format=&#39; %n%d%n&#39;,
  NAME Char(16) not null field_format=&#39; , &#39;&#39;%n%[^&#39;&#39;]%n&#39;&#39;&#39;,
  DEPNO Integer(4) not null field_format=&#39; , #%n%d%n&#39;,
  SALARY Double(12,2) not null field_format=&#39; ; %n%f%n&#39;)
Engine=CONNECT table_type=FMT file_name=&#39;funny.txt&#39;;
&lt;&lt;/code&gt;&gt;

**Field 1** is an integer (%d) with eventual leading blanks.

**Field 2** is separated from field 1 by optional blanks, a comma, and other optional blanks and is between single quotes. The leading quote is included in component 1 of the column format, followed by the %n marker. The column value is specified as ##%[^&#39;]## meaning to keep any characters read until a quote is met. The ending marker (%n) is followed by the 5th component of the column format, the single quote that follows the column value.

**Field 3,** also separated by a comma, is a number preceded by a pound sign.

**Field 4,** separated by a semicolon eventually surrounded by blanks, is a number with an optional decimal point (%f).

This table will be displayed as:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ID   |= NAME           |= DEPNO |= SALARY
| 12345 | BERTRAND        | 200    | 5009.13
| 56    | POIROT-DELMOTTE | 4256   | 18009.00
| 345   | TRUCMUCHE       | 67     | 19000.25
&lt;&lt;/style&gt;&gt;

=== Optional Fields
To be recognized, a field normally must be at least one character long. For instance, a numeric field must have at least one digit, or a character field cannot be void. However many existing files do not follow this format.

Let us suppose for instance that the preceding example file could be:

&lt;&lt;code&gt;&gt;
12345,&#39;BERTRAND&#39;,#200;5009.13
 56, &#39;POIROT-DELMOTTE&#39; ,# ;18009
345 ,&#39;&#39; , #67; 19000.25
&lt;&lt;/code&gt;&gt;

This will display an error message such as “Bad format line x field y of FMTSAMPLE”. To avoid this and accept these records, the corresponding fields must be specified as &#34;optional&#34;. In the above example, fields 2 and 3 can have null values (in lines 3 and 2 respectively). To specify them as optional, their format must be terminated by ##%m## (instead of the second ##%n##). A statement such as this can do the table creation:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table FMTAMPLE (
  ID Integer(5) not null field_format=&#39; %n%d%n&#39;,
  NAME Char(16) not null field_format=&#39; , &#39;&#39;%n%[^&#39;&#39;]%m&#39;,
  DEPNO Integer(4) field_format=&#39;&#39;&#39; , #%n%d%m&#39;,
  SALARY Double(12,2) field_format=&#39; ; %n%f%n&#39;)
Engine=CONNECT table_type=FMT file_name=&#39;funny.txt&#39;;
&lt;&lt;/code&gt;&gt;

Note that, because the statement must be terminated by %m with no additional characters, skipping the ending quote of field 2 was moved from the end of the second column format to the beginning of the third column format.

The table result is:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ID   |= NAME           |= DEPNO |= SALARY
| 12345 | BERTRAND        | 200    | 5,009.13
| 56    | POIROT-DELMOTTE | NULL   | 18,009.00
| 345   | NULL            | 67     | 19,000.25
&lt;&lt;/style&gt;&gt;

Missing fields are replaced by null values if the column is nullable, blanks for character strings and 0 for numeric fields if it is not.

**Note 1:** Because the formats are specified between quotes, quotes belonging to the formats must be doubled to avoid a CREATE TABLE statement syntax error.

**Note 2:** Characters separating columns can be included as well in component 5 of the preceding column format or in component 1 of the succeeding column format but for blanks, which should be always included in component 1 of the succeeding column format because line trailing blanks can be sometimes lost. This is also mandatory for optional fields.

**Note 3:** Because the format is mainly used to find the sub-string corresponding to a column value, the field specification does not necessarily match the column type. For instance supposing a table contains two integer columns, NBONE and NBTWO, the two lines describing these columns could be:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
NBONE integer(5) not null field_format=&#39; %n%d%n&#39;,
NBTWO integer(5) field_format=&#39; %n%s%n&#39;,
&lt;&lt;/code&gt;&gt;

The first one specifies a required integer field (%d), the second line describes a field that can be an integer, but can be replaced by a &#34;-&#34; (or any other) character. Specifying the format specification for this column as a character field (%s) enables to recognize it with no error in all cases. Later on, this field will be converted to integer by the column read function, and a null 0 value will be generated for field specified in their format as non-numeric.

=== Bad record error processing
When no match if found for a column field the process aborts with a message such as:

&lt;&lt;code&gt;&gt;
Bad format line 3 field 4 of funny.txt
&lt;&lt;/code&gt;&gt;

This can mean as well that one line of the input line is ill formed or that the column format for this field has been wrongly specified. When you know that your file contains records that are ill formatted and should be eliminated from normal processing, set the “maxerr” option of the CREATE TABLE statement, for instance:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
Option_list=&#39;maxerr=100&#39;
&lt;&lt;/code&gt;&gt;

This will indicate that no error message be raised for the 100 first wrong lines. You can set Maxerr to a number greater than the number of wrong lines in your files to ignore them and get no errors.

Additionally, the “accept” option permit to keep those ill formatted lines with the bad field, and all succeeding fields of the record, nullified. If “accept” is specified without “maxerr”, all ill formatted lines will be accepted.

**Note:** This error processing also applies to CSV tables.

=== Fields containing a formatted Date
A special case is one of columns containing a formatted date. In this case, two formats must be
specified:

# The field recognition format used to delimit the date in the input record.
# The date format used to interpret the date.
# The field length option if the date representation is different than the standard type size.

For example, let us suppose we have a web log source file containing records such a:

&lt;&lt;code&gt;&gt;
165.91.215.31 - - [17/Jul/2001:00:01:13 -0400] - &#34;GET /usnews/home.htm HTTP/1.1&#34; 302
&lt;&lt;/code&gt;&gt;

The create table statement shall be like this:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table WEBSAMP (
  IP char(15) not null field_format=&#39;%n%s%n&#39;,
  DATE datetime not null field_format=&#39; - - [%n%s%n -0400]&#39;
  date_format=&#39;DD/MMM/YYYY:hh:mm:ss&#39; field_length=20,
  FILE char(128) not null field_format=&#39; - &#34;GET %n%s%n&#39;,
  HTTP double(4,2) not null field_format=&#39; HTTP/%n%f%n&#34;&#39;,
  NBONE int(5) not null field_format=&#39; %n%d%n&#39;)
Engine=CONNECT table_type=FMT lrecl=400
file_name=&#39;e:\\data\\token\\Websamp.dat&#39;;
&lt;&lt;/code&gt;&gt;

**Note 1:** Here, ##field_length=20## was necessary because the default size
for datetime columns is only 19. The ##lrecl=400## was also specified because
the actual file contains more information in each records making the record
size calculated by default too small.

**Note 2:** The file name could have been specified as
##&#39;e:/data/token/Websamp.dat&#39;##.

**Note 3:** FMT tables are currently read only.

== XML Table Type
CONNECT supports tables represented by XML files. For these tables, the
standard input/output functions of the operating system are not used but the
parsing and processing of the file is delegated to a specialized library.
Currently two such systems are supported: libxml2, a part of the GNOME
framework, but that does not require GNOME and, on Windows, MS-DOM (DOMDOC)
that is the Microsoft standard support of XML documents.

DOMDOC is the default for the Windows version of CONNECT and libxml2 is always
used on other systems. On Windows the choice can be specified using the XMLSUP
create table list option, for instance specifying
##option_list=&#39;xmlsup=libxml2&#39;##.

=== Creating XML tables
First of all, it must be understood that XML is a very general language used to
encode data having any structure. In particular, the tag hierarchy in an XML
file describes a tree structure of the data. For instance, consider the file:

&lt;&lt;code lang=xml inline=false&gt;&gt;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;ISO-8859-1&#34;?&gt;
&lt;BIBLIO SUBJECT=&#34;XML&#34;&gt;
   &lt;BOOK ISBN=&#34;9782212090819&#34; LANG=&#34;fr&#34; SUBJECT=&#34;applications&#34;&gt;
      &lt;AUTHOR&gt;
         &lt;FIRSTNAME&gt;Jean-Christophe&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Bernadac&lt;/LASTNAME&gt;
      &lt;/AUTHOR&gt;
      &lt;AUTHOR&gt;
         &lt;FIRSTNAME&gt;François&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Knab&lt;/LASTNAME&gt;
      &lt;/AUTHOR&gt;
      &lt;TITLE&gt;Construire une application XML&lt;/TITLE&gt;
      &lt;PUBLISHER&gt;
         &lt;NAME&gt;Eyrolles&lt;/NAME&gt;
         &lt;PLACE&gt;Paris&lt;/PLACE&gt;
      &lt;/PUBLISHER&gt;
      &lt;DATEPUB&gt;1999&lt;/DATEPUB&gt;
   &lt;/BOOK&gt;
   &lt;BOOK ISBN=&#34;9782840825685&#34; LANG=&#34;fr&#34; SUBJECT=&#34;applications&#34;&gt;
      &lt;AUTHOR&gt;
         &lt;FIRSTNAME&gt;William J.&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Pardi&lt;/LASTNAME&gt;
      &lt;/AUTHOR&gt;
      &lt;TRANSLATOR PREFIX=&#34;adapté de l&#39;anglais par&#34;&gt;
         &lt;FIRSTNAME&gt;James&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Guerin&lt;/LASTNAME&gt;
      &lt;/TRANSLATOR&gt;
      &lt;TITLE&gt;XML en Action&lt;/TITLE&gt;
      &lt;PUBLISHER&gt;
         &lt;NAME&gt;Microsoft Press&lt;/NAME&gt;
         &lt;PLACE&gt;Paris&lt;/PLACE&gt;
      &lt;/PUBLISHER&gt;
      &lt;DATEPUB&gt;1999&lt;/DATEPUB&gt;
   &lt;/BOOK&gt;
&lt;/BIBLIO&gt;
&lt;&lt;/code&gt;&gt;

It represents data having the structure:

&lt;&lt;code&gt;&gt;
                               &lt;BIBLIO&gt;
                        __________|_________
                       |                    |
            &lt;BOOK:ISBN,LANG,SUBJECT&gt;        |
         ______________|_______________     |
        |        |         |           |    |
     &lt;AUTHOR&gt; &lt;TITLE&gt; &lt;PUBLISHER&gt; &lt;DATEPUB&gt; |
    ____|____            ___|____           |
   |    |    |          |        |          |
&lt;FIRST&gt; | &lt;LAST&gt;     &lt;NAME&gt;   &lt;PLACE&gt;       |
        |                                   |
     &lt;AUTHOR&gt;                   &lt;BOOK:ISBN,LANG,SUBJECT&gt;
    ____|____         ______________________|__________________
   |         |       |            |         |        |         |
&lt;FIRST&gt;   &lt;LAST&gt;  &lt;AUTHOR&gt; &lt;TRANSLATOR&gt; &lt;TITLE&gt; &lt;PUBLISHER&gt; &lt;DATEPUB&gt;
                _____|_        ___|___            ___|____
               |       |      |       |          |        |
            &lt;FIRST&gt; &lt;LAST&gt; &lt;FIRST&gt; &lt;LAST&gt;     &lt;NAME&gt;   &lt;PLACE&gt;
&lt;&lt;/code&gt;&gt;

This structure seems at first view far from being tabular. However, modern
database management systems, including MySQL, implement something close to the
relational model and work on tables that are structurally not hierarchical but
tabular with rows and columns.

Nevertheless, CONNECT can do it. Of course, it cannot guess what you want to extract from the XML
structure, but gives you the possibility to specify it when you create the table&lt;&lt;ref&gt;&gt;CONNECT does not claim to be able to deal with any XML document. Besides, those that can usefully be processed for data analysis are likely to have a structure that can easily be transformed into a table.&lt;&lt;/ref&gt;&gt;.

Let us take a first example. Suppose you want to make a table from the above
document, displaying the node contains.

For this, you can define a table //xsamptag// as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table xsamptag (
  AUTHOR char(50),
  TITLE char(32),
  TRANSLATOR char(40),
  PUBLISHER char(40),
  DATEPUB int(4))
engine=CONNECT table_type=XML file_name=&#39;Xsample.xml&#39;;
&lt;&lt;/code&gt;&gt;

It will be displayed as:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= AUTHOR |= TITLE |= TRANSLATOR |= PUBLISHER |= DATEPUB
| Jean-Christophe Bernadac | Construire une application XML |              | Eyrolles Paris | 1999
| William J. Pardi         | XML en Action                  | James Guerin | Microsoft Press Paris | 1999
&lt;&lt;/style&gt;&gt;
Let us try to understand what happened. By default the columns names correspond to tag names.
Because this file is rather simple, CONNECT was able to default the top tag of the table as the root
node &lt;BIBLIO&gt; of the file, and the row tags as the &lt;BOOK&gt; children of the table tag. In a more complex
file, this should have been specified, as we will see later. Note that we had not to worry about the sub-
tags such as &lt;FIRSTNAME&gt; or &lt;LASTNAME&gt; because CONNECT automatically retrieves the entire text
contained in a tag and its sub-tags&lt;&lt;ref&gt;&gt;With libxml2, sub tags text can be separated by 0 or several blanks depending on the structure and indentation of the data file.&lt;&lt;/ref&gt;&gt;.

&lt;&lt;style class=&#34;bluebox&#34;&gt;&gt;
Only the first author of the first book appears. This is because only the first occurrence of a column tag has been retrieved so the result has a proper tabular structure. We will see later what we can do about that.
&lt;&lt;/style&gt;&gt;

How can we retrieve the values specified by attributes? By using a Coltype
table option to specify the default column type. The values ‘@’ means that
column names match attribute names. Therefore, we can retrieve them by creating
a table such as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table xsampattr (
  ISBN char(15),
  LANG char(2),
  SUBJECT char(32))
engine=CONNECT table_type=XML file_name=&#39;Xsample.xml&#39;
option_list=&#39;Coltype=@&#39;;
&lt;&lt;/code&gt;&gt;

This table gives the following display:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ISBN         |= LANG |= SUBJECT
| 9782212090819 | fr    | applications
| 9782840825685 | fr    | applications
&lt;&lt;/style&gt;&gt;

Now to define a table that will give us all the previous information, we must specify the column type for each column. Because in the next statement the column type defaults to Node, the field_format column parameter was used to indicate which columns are attributes:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table xsamp (
  ISBN char(15) field_format=&#39;@&#39;,
  LANG char(2) field_format=&#39;@&#39;,
  SUBJECT char(32) field_format=&#39;@&#39;,
  AUTHOR char(50),
  TITLE char(32),
  TRANSLATOR char(40),
  PUBLISHER char(40),
  DATEPUB int(4))
engine=CONNECT table_type=XML file_name=&#39;Xsample.xml&#39;
tabname=&#39;BIBLIO&#39; option_list=&#39;rownode=BOOK&#39;;
&lt;&lt;/code&gt;&gt;

Once done, we can enter the query:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select subject, lang, title, author from xsamp;
&lt;&lt;/code&gt;&gt;

This will return the result:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= SUBJECT     |= LANG |= TITLE                         |= AUTHOR
| applications | fr    | Construire une application XML | Jean-Christophe Bernadac
| applications | fr    | XML en Action                  | William J. Pardi
&lt;&lt;/style&gt;&gt;

Note that we have been lucky. Because unlike SQL, XML is case sensitive and the column names have matched the node names only because column names were given in upper case. Note also that the order of the columns in the table could have been different from the order in which the nodes appear in the XML file.

=== Using Xpath’s with XML tables

The field_format options we used above can be specified to locate more precisely where and what is the information to retrieve using an Xpath-like syntax. For instance:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table xsampall (
  isbn char(15) field_format=&#39;@ISBN&#39;,
  language char(2) field_format=&#39;@LANG&#39;,
  subject char(32) field_format=&#39;@SUBJECT&#39;,
  authorfn char(20) field_format=&#39;AUTHOR/FIRSTNAME&#39;,
  authorln char(20) field_format=&#39;AUTHOR/LASTNAME&#39;,
  title char(32) field_format=&#39;TITLE&#39;,
  translated char(32) field_format=&#39;TRANSLATOR/@PREFIX&#39;,
  tranfn char(20) field_format=&#39;TRANSLATOR/FIRSTNAME&#39;,
  tranln char(20) field_format=&#39;TRANSLATOR/LASTNAME&#39;,
  publisher char(20) field_format=&#39;PUBLISHER/NAME&#39;,
  location char(20) field_format=&#39;PUBLISHER/PLACE&#39;,
  year int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=XML file_name=&#39;Xsample.xml&#39;
tabname=&#39;BIBLIO&#39; option_list=&#39;rownode=BOOK,skipnull=1&#39;;
&lt;&lt;/code&gt;&gt;

This very flexible column parameter serves several purposes:

* To specify the tag name, or the attribute name if different from the column name.
* To specify the type (tag or attribute) by a prefix of &#39;@&#39; for attributes.
* To specify the path for sub-tags using the &#39;/&#39; character.

This path is always relative to the current context (the column top node) and
cannot be specified as an absolute path from the document root, therefore a
leading &#39;/&#39; cannot be used. The path cannot be variable in node names or depth,
therefore using &#39;{{{//}}}&#39; is not allowed.

The query:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select isbn, title, translated, tranfn, tranln, location from
    xsampall where translated &lt;&gt; &#39;&#39;;
&lt;&lt;/code&gt;&gt;

Replies:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ISBN         |= TITLE        |= TRANSLATED             |= TRANFN |= TRANLN |= LOCATION
| 9782840825685 | XML en Action | adapté de l&#39;anglais par | James   | Guerin  | Paris
&lt;&lt;/style&gt;&gt;

=== Direct access on XML tables
Direct access is available on XML tables. This means that XML tables can be sorted and used in joins, even in the one-side of the join.

However, building a permanent index is not implemented yet. It is not sure that this can be useful. Indeed, the Windows DOM implementation when used to access these tables firstly parses the whole file and constructs a node tree in memory. This may be often the longest part of the process, so the use of index or block optimization would not be of great value. Note also that this restrict the XML files to be of a reasonable size. Anyway, when speed is important, this table type is not the best to use. Therefore, in these cases, it is probably better to convert the file to another type by inserting the XML table in another table of a more appropriate type concerning performance.

=== Write operations on XML tables
You can freely use the Update, Delete and Insert commands with XML table. However, you must
understand that the format of the updated or inserted data follows the specifications of the table you created, not the ones of the original source file. For instance, let us suppose we insert a new book using the //xsamp// table (not the xsampall table) with the command:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
insert into xsamp
  (isbn, lang, subject, author, title, publisher,datepub)
  values (&#39;9782212090529&#39;,&#39;fr&#39;,&#39;général&#39;,&#39;Alain Michard&#39;,
         &#39;XML, Langage et Applications&#39;,&#39;Eyrolles Paris&#39;,1998);
&lt;&lt;/code&gt;&gt;

Then if we ask:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select subject, author, title, translator, publisher from xsamp;
&lt;&lt;/code&gt;&gt;

Everything seems correct when we get the result:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= SUBJECT |= AUTHOR |= TITLE |= TRANSLATOR |= PUBLISHER
| applications | Jean-Christophe Bernadac | Construire une application XML | | Eyrolles Paris
| applications | William J. Pardi         | XML en Action | James Guerin | Microsoft Press Paris
| général      | Alain Michard            | XML, Langage et Applications | | Eyrolles Paris
&lt;&lt;/style&gt;&gt;
However if we enter the apparently equivalent query on the xsampall table, based on the same file:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select subject,
concat(authorfn, &#39; &#39;, authorln) author , title,
concat(tranfn, &#39; &#39;, tranln) translator,
concat(publisher, &#39; &#39;, location) publisher from xsampall;
&lt;&lt;/code&gt;&gt;

This will return an apparently wrong answer:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= SUBJECT |= AUTHOR |= TITLE |= TRANSLATOR |= PUBLISHER
| applications | Jean-Christophe Bernadac | Construire une application XML | | Eyrolles Paris
| applications | William J. Pardi | XML en Action     | James Guerin | Microsoft Press Paris
| général      |                  | XML, Langage et Applications |   | |
&lt;&lt;/style&gt;&gt;

What happened here? Simply, because we used the //xsamp// table to do the Insert, what has been inserted within the XML file had the structure described for //xsamp//:

&lt;&lt;code lang=xml inline=false&gt;&gt;
   &lt;BOOK ISBN=&#34;9782212090529&#34; LANG=&#34;fr&#34; SUBJECT=&#34;général&#34;&gt;
      &lt;AUTHOR&gt;Alain Michard&lt;/AUTHOR&gt;
      &lt;TITLE&gt;XML, Langage et Applications&lt;/TITLE&gt;
      &lt;TRANSLATOR&gt;&lt;/TRANSLATOR&gt;
      &lt;PUBLISHER&gt;Eyrolles Paris&lt;/PUBLISHER&gt;
      &lt;DATEPUB&gt;1998&lt;/DATEPUB&gt;
   &lt;/BOOK&gt;
&lt;&lt;/code&gt;&gt;

CONNECT cannot &#34;invent&#34; sub-tags that are not part of the //xsamp// table. Because these sub-tags do not exist, the //xsampall// table cannot retrieve the information that should be attached to them. If we want to be able to query the XML file by all the defined tables, the correct way to insert a new book to the file is to use the //xsampall// table, the only one that addresses all the components of the original document:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
delete from xsamp where isbn = &#39;9782212090529&#39;;

insert into xsampall (isbn, language, subject, authorfn, authorln,
      title, publisher, location, year)
   values(&#39;9782212090529&#39;,&#39;fr&#39;,&#39;général&#39;,&#39;Alain&#39;,&#39;Michard&#39;,
      &#39;XML, Langage et Applications&#39;,&#39;Eyrolles&#39;,&#39;Paris&#39;,1998);
&lt;&lt;/code&gt;&gt;

Now the added book, in the XML file, will have the required structure:

&lt;&lt;code lang=xml inline=false&gt;&gt;
   &lt;BOOK ISBN=&#34;9782212090529&#34; LANG=&#34;fr&#34; SUBJECT=&#34;général&#34;
      &lt;AUTHOR&gt;
         &lt;FIRSTNAME&gt;Alain&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Michard&lt;/LASTNAME&gt;
      &lt;/AUTHOR&gt;
      &lt;TITLE&gt;XML, Langage et Applications&lt;/TITLE&gt;
      &lt;PUBLISHER&gt;
         &lt;NAME&gt;Eyrolles&lt;/NAME&gt;
         &lt;PLACE&gt;Paris&lt;/PLACE&gt;
      &lt;/PUBLISHER&gt;
      &lt;DATEPUB&gt;1998&lt;/DATEPUB&gt;
   &lt;/BOOK&gt;
&lt;&lt;/code&gt;&gt;

**Note:** We used a column list in the Insert statements, along with specifying
‘skipnull=1’ when creating the table, to avoid generating a &lt;TRANSLATOR&gt; node
with sub-nodes, all containing null values (this works on Windows only).

=== Multiple Nodes in the XML Document
Let us come back to the above example XML file. We have seen that the author
node can be &#34;multiple&#34; meaning that there can be more than one author of a
book. What can we do to get the complete information fitting the relational
model? CONNECT provides you with two possibilities, but restricted to only one
such multiple node per table.

The first and most challenging one is to return as many rows than there are
authors, the other columns being repeated as if we had make a join between the
author column and the rest of the table. To achieve this, simply specify the
“multiple” node name and the “expand” option when creating the table. For
instance, we can create the xsamp2 table like this:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table xsamp2 (
  ISBN char(15) field_format=&#39;@&#39;,
  LANG char(2) field_format=&#39;@&#39;,
  SUBJECT char(32) field_format=&#39;@&#39;,
  AUTHOR char(40),
  TITLE char(32),
  TRANSLATOR char(32),
  PUBLISHER char(32),
  DATEPUB int(4))
engine=CONNECT table_type=XML file_name=&#39;Xsample.xml&#39;
tabname=&#39;BIBLIO&#39;
option_list=&#39;rownode=BOOK,Expand=1,Mulnode=AUTHOR,Limit=2&#39;;
&lt;&lt;/code&gt;&gt;

In this statement, the Limit option is a ceiling estimate of the average number of author per book that enables CONNECT to calculate the maximum size of the table. If not specified you are likely to have your result truncated by the internally recalculated table size value. Then you can enter a query such as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select isbn, subject, author, title from xsamp2;
&lt;&lt;/code&gt;&gt;

This will retrieve and display the following result:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ISBN |= SUBJECT |= AUTHOR |= TITLE
| 9782212090819 | applications | Jean-Christophe Bernadac | Construire une application XML
| 9782212090819 | applications | François Knab            | Construire une application XML
| 9782840825685 | applications | William J. Pardi         | XML en Action
| 9782212090529 | général      | Alain Michard            | XML, Langage et Applications
&lt;&lt;/style&gt;&gt;

In this case, this is as if the table had four rows. However if we enter the query:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select isbn, subject, title, publisher from xsamp2;
&lt;&lt;/code&gt;&gt;

This time the result will be:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ISBN         |= SUBJECT     |= TITLE                        |= PUBLISHER
| 9782212090819 | applications | Construire une application XML | Eyrolles Paris
| 9782840825685 | applications | XML en Action                  | Microsoft Press Paris
| 9782212090529 | général      | XML, Langage et Applications   | Eyrolles Paris
&lt;&lt;/style&gt;&gt;

Because the author column does not appear in the query, the corresponding row was not expanded.
This is somewhat strange because this would have been different if we had been working on a table of a different type. However, it is closer to the relational model for which there should not be two identical rows (tuples) in a table. Nevertheless, you should be aware of this somewhat erratic behavior. For instance:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select count(*) from xsamp2;                /* Replies 4 */
select count(author) from xsamp2;           /* Replies 4 */
select count(isbn) from xsamp2;             /* Replies 3 */
select isbn, subject, title, publisher from xsamp2 where author &lt;&gt; &#39;&#39;;
&lt;&lt;/code&gt;&gt;

This last query replies:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ISBN         |= SUBJECT     |= TITLE                         |= PUBLISHER
| 9782212090819 | applications | Construire une application XML | Eyrolles Paris
| 9782212090819 | applications | Construire une application XML | Eyrolles Paris
| 9782840825685 | applications | XML en Action                  | Microsoft Press Paris
| 9782212090529 | général      | XML, Langage et Applications   | Eyrolles Paris
&lt;&lt;/style&gt;&gt;

Even the author column does not appear in the result, the corresponding row was expanded because the multiple column was used in the where clause.

=== Intermediate Multiple Node
The &#34;multiple&#34; node can be an intermediate node. If we want to do the same expanding with the //xsampall// table, there will be nothing more to do. The //xsampall2// table can be created with:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table xsampall2 (
  isbn char(15) field_format=&#39;@ISBN&#39;,
  language char(2) field_format=&#39;@LANG&#39;,
  subject char(32) field_format=&#39;@SUBJECT&#39;,
  authorfn char(20) field_format=&#39;AUTHOR/FIRSTNAME&#39;,
  authorln char(20) field_format=&#39;AUTHOR/LASTNAME&#39;,
  title char(32) field_format=&#39;TITLE&#39;,
  translated char(32) field_format=&#39;TRANSLATOR/@PREFIX&#39;,
  tranfn char(20) field_format=&#39;TRANSLATOR/FIRSTNAME&#39;,
  tranln char(20) field_format=&#39;TRANSLATOR/LASTNAME&#39;,
  publisher char(20) field_format=&#39;PUBLISHER/NAME&#39;,
  location char(20) field_format=&#39;PUBLISHER/PLACE&#39;,
  year int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=XML file_name=&#39;Xsample.xml&#39;
tabname=&#39;BIBLIO&#39;
option_list=&#39;rownode=BOOK,Expand=1,Mulnode=AUTHOR,Limit=2&#39;;
&lt;&lt;/code&gt;&gt;

The only difference is that the &#34;multiple&#34; node is an intermediate node in the path. The resulting table can be seen with a query such as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select subject, language lang, title, authorfn first, authorln
    last, year from xsampall2;
&lt;&lt;/code&gt;&gt;

This displays:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= SUBJECT     |= LANG |= TITLE                         |= FIRST          |= LAST    |= YEAR
| applications | fr    | Construire une application XML | Jean-Christophe | Bernadac | 1999
| applications | fr    | Construire une application XML | François        | Knab     | 1999
| applications | fr    | XML en Action                  | William J.      | Pardi    | 1999
| général      | fr    | XML, Langage et Applications   | Alain           | Michard  | 1998
&lt;&lt;/style&gt;&gt;

These composite tables, half array half tree, reserve us some surprises when updating, deleting from or inserting into them. Insert just cannot generate this structure; if two rows are inserted with just a different author, two book nodes will be generated in the XML file. Delete always deletes one book node and all its children nodes even if specified against only one author. Update is more complicated:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
update xsampall2 set authorfn = &#39;Simon&#39; where authorln = &#39;Knab&#39;;
update xsampall2 set year = 2002 where authorln = &#39;Bernadac&#39;;
update xsampall2 set authorln = &#39;Mercier&#39; where year = 2002;
&lt;&lt;/code&gt;&gt;

After these three updates, the first one responding &#34;Affected rows: 0&#34; and the two others responding &#34;Affected rows: 1&#34;, the last query answers:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= SUBJECT     |= LANG |= TITLE                         |= FIRST          |= LAST    |= YEAR
| applications | fr    | Construire une application XML | Jean-Christophe | Mercier  | 2002
| applications | fr    | Construire une application XML | François        | Knab     | 2002
| applications | fr    | XML en Action                  | William J.      | Pardi    | 1999
| général      | fr    | XML, Langage et Applications   | Alain           | Michard  | 1998
&lt;&lt;/style&gt;&gt;

What must be understood here is that the Update modifies node values in the XML file, not cell values in the relational table. The first update did not worked as expected, unable to retrieve the first name node of the second author and changing it to a new value. The second update changed the year value of the book and this shows for the two expanded rows because there is only one DATEPUB node for that book. Because the third update applies to a row having a certain date value, this row was retrieved but not expanded because no author data appeared in the Where clause; consequently only the first author name was updated.

=== Making a List of Multiple Values
Another way to see multiple values is to ask CONNECT to make a comma separated list of the multiple node values. This time, it can only be done if the &#34;multiple&#34; node is not intermediate. For example, we can modify the //xsamp2// table definition by:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
alter table xsamp2 option_list=&#39;rownode=BOOK,Mulnode=AUTHOR,Limit=3&#39;;
&lt;&lt;/code&gt;&gt;

This time &#39;Expand&#39; is not specified, and Limit gives the maximum number of items in the list. Now if we enter the query:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select isbn, subject, author &#34;AUTHOR(S)&#34;, title from xsamp2;
&lt;&lt;/code&gt;&gt;

We will get the resulting display:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ISBN |= SUBJECT |= AUTHOR(S) |= TITLE
| 9782212090819 | applications | Jean-Christophe Bernadac, François Knab | Construire une application XML
| 9782840825685 | applications | William J. Pardi | XML en Action
| 9782212090529 | général | Alain Michard | XML, Langage et Applications
&lt;&lt;/style&gt;&gt;

Note that updating the &#34;multiple&#34; column is not possible because CONNECT does not know which of
the nodes to update.

This could not have been done with the //xsampall2// table because the author node is intermediate in the path, and making two lists, one of first names and another one of last names would not make sense anyway.

=== What if a table contains several multiple nodes
This can be handled by creating several tables on the same file, each containing only one multiple node and constructing the desired result using joins.

=== Support of HTML Tables
Most tables included in HTML documents cannot be processed by CONNECT because the HTML
language is often not compatible with the syntax of XML. In particular, XML requires all open tags to be matched by a closing tag while it is sometimes optional in HTML. This is often the case concerning column tags.

However, you can meet tables that respect the XML syntax but have some of the features of HTML tables. For instance:

&lt;&lt;code lang=xml inline=false&gt;&gt;
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;Beers&gt;
  &lt;table&gt;
    &lt;th&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Origin&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/th&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;brandName&gt;Huntsman&lt;/brandName&gt;&lt;/td&gt;
      &lt;td&gt;&lt;origin&gt;Bath, UK&lt;/origin&gt;&lt;/td&gt;
      &lt;td&gt;&lt;details&gt;Wonderful hop, light alcohol&lt;/details&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;brandName&gt;Tuborg&lt;/brandName&gt;&lt;/td&gt;
      &lt;td&gt;&lt;origin&gt;Danmark&lt;/origin&gt;&lt;/td&gt;
      &lt;td&gt;&lt;details&gt;In small bottles&lt;/details&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/Beers&gt;
&lt;&lt;/code&gt;&gt;

Here the different column tags are included in ##&lt;td&gt;&lt;/td&gt;## tags as for HTML tables. You cannot just
add this tag in the Xpath of the columns, because the search is done on the first occurrence of each tag, and this would cause this search to fail for all columns except the first one. This case is handled by specifying the //Colnode// table option that gives the name of these column tags, for example:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table beers (
  `Name` char(16) field_format=&#39;brandName&#39;,
  `Origin` char(16) field_format=&#39;origin&#39;,
  `Description` char(32) field_format=&#39;details&#39;)
engine=CONNECT table_type=XML file_name=&#39;beers.xml&#39;
tabname=&#39;table&#39; option_list=&#39;rownode=tr,colnode=td&#39;;
&lt;&lt;/code&gt;&gt;

The table will be displayed as:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Name    |= Origin  |= Description
| Huntsman | Bath, UK | Wonderful hop, light alcohol
| Tuborg   | Danmark  | In small bottles
&lt;&lt;/style&gt;&gt;

However, you can deal with tables even closer of the HTML model. For example the //coffee.htm// file:

&lt;&lt;code lang=html inline=false&gt;&gt;
&lt;TABLE summary=&#34;This table charts the number of cups of coffe
                consumed by each senator, the type of coffee (decaf
                or regular), and whether taken with sugar.&#34;&gt;
  &lt;CAPTION&gt;Cups of coffee consumed by each senator&lt;/CAPTION&gt;
  &lt;TR&gt;
    &lt;TH&gt;Name&lt;/TH&gt;
    &lt;TH&gt;Cups&lt;/TH&gt;
    &lt;TH&gt;Type of Coffee&lt;/TH&gt;
    &lt;TH&gt;Sugar?&lt;/TH&gt;
  &lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD&gt;T. Sexton&lt;/TD&gt;
    &lt;TD&gt;10&lt;/TD&gt;
    &lt;TD&gt;Espresso&lt;/TD&gt;
    &lt;TD&gt;No&lt;/TD&gt;
  &lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD&gt;J. Dinnen&lt;/TD&gt;
    &lt;TD&gt;5&lt;/TD&gt;
    &lt;TD&gt;Decaf&lt;/TD&gt;
    &lt;TD&gt;Yes&lt;/TD&gt;
  &lt;/TR&gt;
&lt;/TABLE&gt;
&lt;&lt;/code&gt;&gt;

Here column values are directly represented by the TD tag text. You cannot declare them as tags nor as attributes. In addition, they are not located using their name but by their position within the row. Here is how to declare such a table to CONNECT:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table coffee (
  `Name` char(16),
  `Cups` int(8),
  `Type` char(16),
  `Sugar` char(4))
engine=connect table_type=XML file_name=&#39;coffee.htm&#39;
tabname=&#39;TABLE&#39; header=1 option_list=&#39;Coltype=HTML&#39;;
&lt;&lt;/code&gt;&gt;

You specify the fact that column are located by position by setting the //Coltype// option to &#39;HTML&#39;. Each column position (0 based) will be the value of the //flag// column parameter that is set by default in sequence. Now we are able to display the table:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Name     |= Cups |= Type    |= Sugar
| T. Sexton | 10    | Espresso | No
| J. Dinnen | 5     | Decaf    | Yes
&lt;&lt;/style&gt;&gt;

**Note 1:** We specified &#39;##header=n##&#39; in the create statement to indicate that the first n rows of the table are not data rows and should be skipped.

**Note 2:** In this last example, we did not specify the node names using the Rownode and Colnode
options because when //Coltype// is set to &#39;HTML&#39; they default to &#39;##Rownode=TR##&#39; and &#39;##Colnode=TD##&#39;.

**Note 3:** The //Coltype// option is a word only the first character of which is significant. Recognized values are:

| T(ag) or N(ode)          | Column names match a tag name (the default).
| A(ttribute) or @         | Column names match an attribute name.
| H(tml) or C(ol) or P(os) | Column are retrieved by their position.

=== New file setting
Some create options are used only when creating a table on a new file, i. e. when inserting into a file that does not exist yet. When specified, the &#39;Header&#39; option will create a header row with the name of the table columns. This is chiefly useful for HTML tables to be displayed on a web browser.

Some new list-options are used in this context:

| **Encoding**  | The encoding of the new document, defaulting to UTF-8.
| **Attribute** | A list of &#39;attname=attvalue&#39; separated by &#39;;&#39; to add to the table node.
| **HeadAttr**  | An attribute list to be added to the header row node.

Let us see for instance, the following create statement:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table handlers (
  handler char(64),
  version char(20),
  author char(64),
  description char(255),
  maturity char(12))
engine=CONNECT table_type=XML file_name=&#39;handlers.htm&#39;
tabname=&#39;TABLE&#39; header=yes
option_list=&#39;coltype=HTML,encoding=ISO-8859-1,
attribute=border=1;cellpadding=5,headattr=bgcolor=yellow&#39;;
&lt;&lt;/code&gt;&gt;

Supposing the table file does not exist yet, the first insert into that table, for instance by the following statement:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
insert into handlers select plugin_name, plugin_version,
  plugin_author, plugin_description, plugin_maturity from
  information_schema.plugins where plugin_type = &#39;DAEMON&#39;;
&lt;&lt;/code&gt;&gt;

Will generate the following file:

&lt;&lt;code lang=xml inline=false&gt;&gt;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;ISO-8859-1&#34;?&gt;
&lt;!-- Created by CONNECT Version 3.05.0005 August 17, 2012 --&gt;
&lt;TABLE border=&#34;1&#34; cellpadding=&#34;5&#34;&gt;
  &lt;TR bgcolor=&#34;yellow&#34;&gt;
    &lt;TH&gt;handler&lt;/TH&gt;
    &lt;TH&gt;version&lt;/TH&gt;
    &lt;TH&gt;author&lt;/TH&gt;
    &lt;TH&gt;description&lt;/TH&gt;
    &lt;TH&gt;maturity&lt;/TH&gt;
  &lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD&gt;Maria&lt;/TD&gt;
    &lt;TD&gt;1.5&lt;/TD&gt;
    &lt;TD&gt;Monty Program Ab&lt;/TD&gt;
    &lt;TD&gt;Compatibility aliases for the Aria engine&lt;/TD&gt;
    &lt;TD&gt;Gamma&lt;/TD&gt;
  &lt;/TR&gt;
&lt;/TABLE&gt;
&lt;&lt;/code&gt;&gt;

This file can be used to display the table on a web browser (encoding should be ISO-8859-x)

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= handler |= version |= author          |= description                              |= maturity
| Maria    | 1.5      | Monty Program Ab | Compatibility aliases for the Aria engine | Gamma
&lt;&lt;/style&gt;&gt;

**Note:** The XML document encoding, is generally specified in the XML header node, and can be different from the DATA_CHARSET, which is always UTF-8 for XML tables. Therefore the table DATA_CHARSET character set should be unspecified, or specified as UTF8. The Encoding specification is useful only for new XML files and ignored for existing files having their encoding already specified in the header node.

== INI Table Type
The INI type is the one of &#34;configure&#34; or &#34;initializing&#34; files often met on
Windows machines. For instance, let us suppose you have a contact
file //contact.ini// such as:

&lt;&lt;code&gt;&gt;
[BER]
name=Bertrand
forename=Olivier
address=21 rue Ferdinand Buisson
city=Issy-les-Mlx
zipcode=92130
tel=09.54.36.29.60
cell=06.70.06.04.16

[WEL]
name=Schmitt
forename=Bernard
hired=19/02/1985
address=64 tiergarten strasse
city=Berlin
zipcode=95013
tel=03.43.377.360

[UK1]
name=Smith
forename=Henry
hired=08/11/2003
address=143 Blum Rd.
city=London
zipcode=NW1 2BP
&lt;&lt;/code&gt;&gt;

CONNECT let you view it as a table in two different ways.

=== Column layout
The first way is to regard it as a table having one line per section, the columns being the keys you want to display. In this case, the create statement could be:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table contact (
  contact char(16) flag=1,
  name char(20),
  forename char(32),
  hired date date_format=&#39;DD/MM/YYYY&#39;,
  address char(64),
  city char(20),
  zipcode char(8),
  tel char(16))
engine=CONNECT table_type=INI file_name=&#39;contact.ini&#39;;
&lt;&lt;/code&gt;&gt;

The column that will contain the section name can have any name but must specify ##flag=1##. All other column must have the names of the keys we want to display (case insensitive). The type can be character or numeric depending on the key value type, and the length is the maximum expected length for the key value. Once done, the statement:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select contact, name, hired, city, tel from contact;
&lt;&lt;/code&gt;&gt;

will display the file in tabular format.

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= contact |= name    |= hired     |= city        |= tel
| BER      | Bertrand | 1970-01-01 | Issy-les-Mlx | 09.54.36.29.60
| WEL      | Schmitt  | 1985-02-19 | Berlin       | 03.43.377.360
| UK1      | Smith    | 2003-11-08 | London       | NULL
&lt;&lt;/style&gt;&gt;

Only the keys defined in the create statements are visible; keys that do not
exist in a section are displayed as null or pseudo null (blank for character,
1/1/70 for dates, and 0 for numeric):

All relational operations can be applied to this table. The table (and the
file) can be updated, inserted and conditionally deleted. The only constraint
is that when inserting values, the section name must be the first in the list
of values.

**Note:** When inserting, if a section already exists, no new section will be
created but the new values will be added or replace those of the existing
section. Thus the following two commands are equivalent:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
update contact set forename = &#39;Harry&#39; where contact = &#39;UK1&#39;;
insert into contact (contact,forename) values(&#39;UK1&#39;,&#39;Harry&#39;);
&lt;&lt;/code&gt;&gt;

=== Row layout
To be a good candidate for tabular representation, an INI file should have often the same keys in all sections. In practice, many files commonly found on computers, such as the win.ini file of the Windows directory or the my.ini file cannot be viewed that way because each section have different keys. In this case, a second way is to regard the file as a table having one row per section key and whose columns can be the section name, the key name and the key value.

For instance, let us define the table:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table xcont (
  section char(16) flag=1,
  keyname char(16) flag=2,
  value char(32))
engine=CONNECT table_type=INI file_name=&#39;contact.ini&#39;
option_list=&#39;Layout=Row&#39;;
&lt;&lt;/code&gt;&gt;

In this statement, the &#34;Layout&#34; option sets the display format, Column by default or anything else not beginning by &#39;C&#39; for row layout display. The names of the three columns can be freely chosen. The Flag option gives the meaning of the column. Specify ##flag=1## for the section name and ##flag=2## for the key name. Otherwise, the column will contain the key value.

Once done, the command:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from xcont;
&lt;&lt;/code&gt;&gt;

Will display the following result:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= section |= keyname |= value
| BER      | name     | Bertrand
| BER      | forename | Olivier
| BER      | address  | 21 rue Ferdinand Buisson
| BER      | city     | Issy-les-Mlx
| BER      | zipcode  | 92130
| BER      | tel      | 09.54.36.29.60
| BER      | cell     | 06.70.06.04.16
| WEL      | name     | Schmitt
| WEL      | forename | Bernard
| WEL      | hired    | 19/02/1985
| WEL      | address  | 64 tiergarten strasse
| WEL      | city     | Berlin
| WEL      | zipcode  | 95013
| WEL      | tel      | 03.43.377.360
| UK1      | name     | Smith
| UK1      | forename | Henry
| UK1      | hired    | 08/11/2003
| UK1      | address  | 143 Blum Rd.
| UK1      | city     | London
| UK1      | zipcode  | NW1 2BP
&lt;&lt;/style&gt;&gt;

**Note:** When processing an INI table, all section names are retrieved in a buffer of 2048 bytes. For a big file having many sections, this size can be increased using for example:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
option_list=&#39;seclen=4000&#39;;
&lt;&lt;/code&gt;&gt;


&lt;&lt;references&gt;&gt;</textarea>
    


                    <div id="content_disclaimer" class="graybox">
                        Content reproduced on this site is the property of its respective owners,
                        and this content is not reviewed in advance by MariaDB. The views, information and opinions
                        expressed by this content do not necessarily represent those of MariaDB or any other party.
                    </div>
                </div>
            </section>

            
        </div>
    </div>
</div>

<!-- Footer -->
<footer id="footer">
    <div class="footer">
        <div class="container">
            <div class="row">
                <div class="col-xs-12">
                    <ul class="list-inline text-center footer-nav">
                        <li>
                            <h5>
                                <a href="https://mariadb.com/products" title="Products">Products</a>
                            </h5>
                        </li>
                        <li>
                            <h5>
                                <a href="https://mariadb.com/solutions" title="Solutions">Solutions</a>
                            </h5>
                        </li>
                        <li>
                            <h5>
                                <a href="https://mariadb.com/resources" title="Resources">Resources</a>
                            </h5>
                        </li>
                        <li>
                            <h5><a href="https://mariadb.com/about-us" title="About MariaDB">Company</a></h5>
                        </li>
                        <li>
                            <h5>
                                <a href="https://mariadb.com/pricing" title="Pricing">Pricing</a>
                            </h5>
                        </li>
                        
                        
                        <li>
                            <h5><a href="https://mariadb.com/downloads" title="Download">Download MariaDB</a></h5>
                        </li>
                    </ul>
                </div>
            </div>
            <div class="row row-10">
                
                <div class="col-md-4 col-xs-12 item col-md-offset-4">
                    <div id="block-footerformcontact" class="block block-block-content block-block-contentd754ee1b-3cc9-40e7-9ef4-f504f1197fb1">
                        
                            <h5 style="font-weight: 400;">Subscribe to our newsletter!</h5>
                            <script src="//app-sj15.marketo.com/js/forms2/js/forms2.min.js"></script><form id="mktoForm_1498"></form>
                            <script>
                                <!--//--><![CDATA[// ><!--
                                MktoForms2.loadForm("//app-sj15.marketo.com", "573-PXI-984", 1498);
                                //--><!]]]]><![CDATA[>
                                //--><!]]>
                            </script>
                        
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-md-4 col-xs-12 item col-md-offset-4">
                    <div class="footer-copyright">
                        <div class="text-center">
                            <ul class="list-inline no-margin">
                                <li>
                                    <a href="/legal" title="Legal">Legal</a>
                                </li>
                                <li>
                                    <a href="/privacy-policy" title="Privacy Policy">Privacy Policy</a>
                                </li>
                                <li>
                                    <a href="/cookie-policy/" title="Cookies">Cookie Policy</a>
                                </li>
                            </ul>
                            <p>Copyright &copy; 2025 MariaDB. All rights reserved.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
</footer>
</div>

<div id="ajax_loading">
    <img src="/kb/static/images/ajax-loader.a51c5608d01a.gif" />
</div>

    <!-- Google Tag Manager -->
    <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MK2847"
                      height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-MK2847');</script>
    <!-- End Google Tag Manager -->

</body>

<script type="text/javascript" src="/kb/static/js/main.1587e3a666fc.js" charset="utf-8"></script>

</html>