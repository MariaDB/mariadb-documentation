<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>MariaDB Knowledge Base Comments for: Understanding replication and read lock contention problems</title><link>https://mariadb.com/kb/en/understanding-replication-and-read-lock-contention-problems/+comments/feed/</link><description></description><atom:link href="https://mariadb.com/kb/en/understanding-replication-and-read-lock-contention-problems/+comments/feed/" rel="self"></atom:link><language>en-us</language><lastBuildDate>Mon, 29 Jul 2024 14:48:31 +0000</lastBuildDate><item><title>Re: Understanding replication and read lock contention problems</title><link>https://mariadb.com/kb/en/understanding-replication-and-read-lock-contention-problems/+comments/4941</link><description>&lt;p&gt;With galera, there is no primary. Updates to the local node are replicated to other members of the cluster.  It won't necessary avoid deadlock. The deadlocks shows are count updates and I can't see the order that spam assassin is doing database updates. With an understanding of that you might be able to do a small code change to avoid it, or at least handle the deadlock (retry maybe).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daniel Black</dc:creator><guid>https://mariadb.com/kb/en/understanding-replication-and-read-lock-contention-problems/+comments/4941</guid></item><item><title>Re: Understanding replication and read lock contention problems</title><link>https://mariadb.com/kb/en/understanding-replication-and-read-lock-contention-problems/+comments/4930</link><description>&lt;p&gt;Thanks so much for your help and explanation.&lt;/p&gt;
&lt;p&gt;Perhaps the solution for me right now is to configure all clients to read from their local copy and to write any changes directly to the primary? Would this avoid the deadlock issue?&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alex Regan</dc:creator><guid>https://mariadb.com/kb/en/understanding-replication-and-read-lock-contention-problems/+comments/4930</guid></item><item><title>Re: Understanding replication and read lock contention problems</title><link>https://mariadb.com/kb/en/understanding-replication-and-read-lock-contention-problems/+comments/4929</link><description>&lt;p&gt;First there is a need to clarify one thing, there is never any read lock contentions, all read locks are shared.&lt;/p&gt;
&lt;p&gt;Replication is one way, master -&amp;gt; replica (slave). To identify the difference you'll need to look at the data in the columns.&lt;/p&gt;
&lt;p&gt;The error you have posted is a dead-lock error. This occurs when a transaction takes locks (update/insert) in a different order to another transaction. So transaction X takes lock A and tries to obtain lock B. And transaction Y holds lock B and tries to aquire lock A. This is detected by the server and a deadlock thrown as there is no obvious server action to take. The locks would be output that you have posted, its just truncated slightly.&lt;/p&gt;
&lt;p&gt;From your scenario it seems you'd like bi-direction replication between your end nodes and other nodes. For this scenario it seems Galera would be a better replication technology to use.&lt;/p&gt;
&lt;p&gt;Bayes_token has a primary key of `(id,token)` so even with galera deadlocks may not be resolved (but at least it will be in sync). On this table small difference in the values may not make a difference to the application (&lt;a href="https://github.com/apache/spamassassin/blob/trunk/sql/bayes_mysql.sql#L23"&gt;https://github.com/apache/spamassassin/blob/trunk/sql/bayes_mysql.sql#L23&lt;/a&gt;) as I understand it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daniel Black</dc:creator><guid>https://mariadb.com/kb/en/understanding-replication-and-read-lock-contention-problems/+comments/4929</guid></item></channel></rss>