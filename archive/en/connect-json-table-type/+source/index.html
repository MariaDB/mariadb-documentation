<!DOCTYPE html>
<html>
<head data-cookie-domain=""
      data-cookie-path="/">
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="apple-touch-icon" sizes="180x180" href="/kb/static/images/favicons/apple-touch-icon.159e713979be.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/kb/static/images/favicons/favicon-32x32.bc0ac1d5d11e.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/kb/static/images/favicons/favicon-16x16.5801f8f0f34e.png">
    <link rel="shortcut icon" href="/kb/static/images/favicons/favicon.d122d305dee4.ico" type="image/x-icon" />

    <title>CONNECT JSON Table Type - Source - MariaDB Knowledge Base</title>

    <link href="/kb/static/css/main.f7633538c846.css" rel="stylesheet" type="text/css" />

    
        <meta name="robots" content="noindex, nofollow">
    

    

    <!-- FB Open Graph tags -->
    <meta property="og:title" content="CONNECT JSON Table Type - Source" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://mariadb.com/kb/en/connect-json-table-type/+source/" />
    <meta property="og:image" content="http://mariadb.comaskmonty-logo.png" />
    <meta property="og:site_name" content="MariaDB KnowledgeBase" />
    <meta property="fb:admins" content="514852603" />
    <meta property="og:description" content="" />

    <meta name="description" content="" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="//fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet"/>
    
</head>
<body class="mpkb nodes autoresize nodes_source jqui" id="nodes_source">





<div id="menu-mobile" class="visible-sm visible-xs">

    <div>
        <div id="mobile-close-menu" class="text-right">
            <a href="javascript:void(0)" title="Close Menu" id="back-main" class="toggle-menu">X<span></span></a>
        </div>
    </div>
    <div class="mainmenu-mobile">
        <ul class="ls-none ul-menu">
            <li data-sub="submenu5"><a class="open-form-search" href="/kb/search/" title="Search">Search </a></li>
            <li data-sub="submenu0"><a href="/products" title="Products">Products</a><span class="arrow-main"></span></li>
            <li data-sub="submenu1"><a href="/services" title="Services">Services</a><span class="arrow-main"></span></li>
            <li data-sub="submenu2"><a href="/resources" title="Resources">Resources</a><span class="arrow-main"></span></li>
            <li data-sub="submenu3"><a href="/about-us" title="About">About</a><span class="arrow-main"></span></li>
            <li data-sub="submenu4"><a href="/contact" title="Contact">Contact</a></li>
        </ul>
    </div>

    <div class="nav-top-mobile">
        <div class="select-box form">

            <ul class="inline-block-md mb-none top-nav">
                <li>

                </li>
                
                    <li>
                        <a href="/kb/user/login?next=/kb/en/connect-json-table-type/+source/"> Login</a>
                    </li>
                
            </ul>



        </div>
        <p class="text-center copyright">Copyright &copy; 2024 MariaDB. All rights reserved.</p>
    </div>
</div>
<div class="violator-wrap d-none" id="top_violator">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12">
                <div class="violator-outer">
                    <div class="violator-inner">
                        <div class="row">
                            <div class="col-xs-12 col-sm-9 col-lg-7 col-lg-offset-2" id="top_violator_content">
                                <a href="https://go.mariadb.com/high-availability-guide-MariaDB-whitepaper.html" class="content-link" target="_blank" rel="nofollow noreferrer">
                                    <span>The Ultimate Guide to High Availability with MariaDB</span>
                                </a>
                            </div>
                            <div class="col-xs-12 col-sm-3" id="top_violator_cta">
                                <a href="https://go.mariadb.com/high-availability-guide-MariaDB-whitepaper.html" class="btn btn-mariadb" target="_blank" rel="nofollow noreferrer">Download Now</a>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="btn btn-link close-btn">
                        <svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 24 24" width="15px" height="15px"><path d="M 4.9902344 3.9902344 A 1.0001 1.0001 0 0 0 4.2929688 5.7070312 L 10.585938 12 L 4.2929688 18.292969 A 1.0001 1.0001 0 1 0 5.7070312 19.707031 L 12 13.414062 L 18.292969 19.707031 A 1.0001 1.0001 0 1 0 19.707031 18.292969 L 13.414062 12 L 19.707031 5.7070312 A 1.0001 1.0001 0 0 0 18.980469 3.9902344 A 1.0001 1.0001 0 0 0 18.292969 4.2929688 L 12 10.585938 L 5.7070312 4.2929688 A 1.0001 1.0001 0 0 0 4.9902344 3.9902344 z"/></svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="wrapper">
<div id="top-nav">
    <div class="container">
        <ul class="hidden-sm hidden-xs" >
            <li><a href="https://mariadb.com/kb/">Knowledge Base</a></li>
            <li><a href="https://mariadb.com/contact/">Contact</a></li>
            
                
                    <li>
                        <a href="/kb/user/login?next=/kb/en/connect-json-table-type/+source/" rel="nofollow">Login</a>
                    </li>
                
            
            
            <li id="search-form">
                <form action="/kb/en/+search/" method="get" id="search-block-form" accept-charset="UTF-8">
                    <input id="search" title="Enter the terms you wish to search for."
                           placeholder="Search . . ." type="text"
                           name="q" value="" size="15" maxlength="128" class="form-text"
                           data-autocomplete-url="/kb/en/+search/autocomplete/">
                    <input type="hidden" name="quick" value="1" />
                    <input type="hidden" name="source" value="kb" />
                </form>
            </li>
            <li><a id="search-toggler" href="/kb/search/">Search</a></li>
            
        </ul>
    </div>
</div>
<div id="navbar-bottom" class="navbar">
    <div class="container">
        
        
        
        
        <div class="row">
            <div class="col-md-3 col-sm-9 col-xs-9">
                <a class="brand" href="/" title="MariaDB">
                    <img src="/kb/static/images/logo-2018-black.95f5978ae14d.png">
                </a>
            </div>
            <div class="col-md-9 hidden-sm hidden-xs">
                <div class="main-menu">
                    <ul id="main-menu" class="nav navbar-nav inline-block-sm">
    <li class="has-sub full-menu">
        <a href="/products" title="Products">Products</a>
    </li>
    <li class="has-sub full-menu active">
        <a href="/services" title="Services">Services</a>
    </li>
    <li class="has-sub full-menu active">
        <a href="/pricing" title="Pricing">Pricing</a>
    </li>
    <li class="has-sub full-menu">
        <a href="/resources" title="Resources">Resources</a>
    </li>
    <li class="has-sub full-menu">
        <a href="/about-us" title="About Us">About Us</a>
    </li>
    <li class="">
        <a class="button electric-eel small top-bar-right-download" href="/downloads/">Download</a>
    </li>
</ul>
                </div>
            </div>
            <div class="col-md-3 visible-sm visible-xs col-sm-3 col-xs-3 ps-rv">
                <div class="navbar-header text-right pull-right">
                    <button type="button" class="menu-control toggle-menu" id="open-menu">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="main">
    <div class="container">
        

        <div id="subheader1" class="clearfix">
            <div class="pull-left">
                
                <div id="breadcrumbs" class="breadcrumb">
                    <a href="/kb/en/">Knowledge Base</a>
                    


    
    » <a class="crumb" href="/kb/en/documentation/">MariaDB Server Documentation</a>
    

    
    » <a class="crumb" href="/kb/en/columns-storage-engines-and-plugins/">Columns, Storage Engines, and Plugins</a>
    

    
    » <a class="crumb" href="/kb/en/storage-engines/">Storage Engines</a>
    

    
    » <a class="crumb" href="/kb/en/connect/">CONNECT</a>
    

    
    » <a class="crumb" href="/kb/en/connect-table-types/">CONNECT Table Types</a>
    


    » <a class="node_link crumb" href="/kb/en/connect-json-table-type/">CONNECT JSON Table Type</a>


                </div>
                
            </div>
        </div>
    </div>
    <div class="container" id="container-main">
        <div class="row">
            
            
                
                <aside id="sidebar-first" class="sidebar col-md-2 hidden-xs hidden-sm hidden-print">
                    
                        
                        <ul id="category_menu" class="nav nav-pills nav-stacked">
                            <li><a href="/kb/en/">Home</a></li>
                            
                                
                                    <li><a href="/kb/en/+questions/">Open Questions</a></li>
                                
                                <li><a href="/kb/en/documentation/">MariaDB Server</a></li>
                                <li><a href="/kb/en/maxscale/">MariaDB MaxScale</a></li>
                                <li><a href="/kb/en/mariadb-columnstore/">MariaDB ColumnStore</a></li>
                                <li><a href="/kb/en/connectors/">Connectors</a></li>
                            

                        </ul>
                    

                    
                        <div>
    

<div class="well well-small box actions"><div>

        <a class="btn btn-block btn-small" href="/kb/en/connect-json-table-type/">Return to article</a>
    
</div>
</div>

</div>
                    

                    

































                </aside>
            
            
            
                
            
            
            <section id="content" class="limited_width col-md-10 clearfix">
                
                    <h1>CONNECT JSON Table Type - Source</h1>
                

                



                <div>
                    

    

    
    <div class="revision_info">
        <dl class="table">
            <dt>Revision</dt>
            <dd><a href="/kb/en/connect-json-table-type/+r/115753/">115753</a></dd>
            <dt>User</dt>
            <dd>
<span class="user" id="user-1368">
<a href="/kb/user/id/1368" title="Ian Gilfillan">Ian Gilfillan</a>
</span></dd>
            <dt>Date</dt>
            <dd>

<span class="datetime" title="2022-05-02 12:33">2022-05-02 12:33</span></dd>
        </dl>
    </div>
    


    

    
        
        <textarea id="answer_source" class="creole_source autogrow">&lt;&lt;toc&gt;&gt;
== Overview

JSON (JavaScript Object Notation) is a lightweight data-interchange format widely used on the Internet. Many applications, generally written in JavaScript or PHP use and produce JSON data, which are exchanged as files of different physical formats. JSON data is often returned from REST queries.

It is also possible to query, create or update such information in a database-like manner. MongoDB does it using a JavaScript-like language. PostgreSQL includes these facilities by using a specific data type and related functions like dynamic columns.

The CONNECT engine adds this facility to MariaDB by supporting tables based on JSON data files. This is done like for XML tables by creating tables describing what should be retrieved from the file and how it should be processed.

Starting with 1.07.0002, the internal way JSON was parsed and handled was changed. The main advantage of the new way is to reduce the memory required to parse JSON. It was from 6 to 10 times the size of the JSON source and is now only 2 to 4 times. However, this is in Beta mode and JSON tables are still handled using the old mode. To use the new mode, tables should be created with TABLE_TYPE=BSON. Another way is the set the [[connect-system-variables/#connect_force_bson|connect_force_bson]] session variable to 1 or ON. Then all JSON tables will be handled as BSON. Of course, this is temporary and when successfully tested, the new way will replace the old way and all tables be created as JSON.

Let us start from the file “biblio3.json” that is the JSON equivalent of the XML Xsample file described in the XML table chapter:
&lt;&lt;code&gt;&gt;
[
  {
    &#34;ISBN&#34;: &#34;9782212090819&#34;,
    &#34;LANG&#34;: &#34;fr&#34;,
    &#34;SUBJECT&#34;: &#34;applications&#34;,
    &#34;AUTHOR&#34;: [
      {
        &#34;FIRSTNAME&#34;: &#34;Jean-Christophe&#34;,
        &#34;LASTNAME&#34;: &#34;Bernadac&#34;
      },
      {
        &#34;FIRSTNAME&#34;: &#34;François&#34;,
        &#34;LASTNAME&#34;: &#34;Knab&#34;
      }
    ],
    &#34;TITLE&#34;: &#34;Construire une application XML&#34;,
    &#34;PUBLISHER&#34;: {
      &#34;NAME&#34;: &#34;Eyrolles&#34;,
      &#34;PLACE&#34;: &#34;Paris&#34;
    },
    &#34;DATEPUB&#34;: 1999
  },
  {
    &#34;ISBN&#34;: &#34;9782840825685&#34;,
    &#34;LANG&#34;: &#34;fr&#34;,
    &#34;SUBJECT&#34;: &#34;applications&#34;,
    &#34;AUTHOR&#34;: [
      {
        &#34;FIRSTNAME&#34;: &#34;William J.&#34;,
        &#34;LASTNAME&#34;: &#34;Pardi&#34;
      }
    ],
    &#34;TITLE&#34;: &#34;XML en Action&#34;,
    &#34;TRANSLATED&#34;: {
       &#34;PREFIX&#34;: &#34;adapté de l&#39;anglais par&#34;,
       &#34;TRANSLATOR&#34;: {
          &#34;FIRSTNAME&#34;: &#34;James&#34;,
        &#34;LASTNAME&#34;: &#34;Guerin&#34;
        }
    },
    &#34;PUBLISHER&#34;: {
      &#34;NAME&#34;: &#34;Microsoft Press&#34;,
      &#34;PLACE&#34;: &#34;Paris&#34;
    },
    &#34;DATEPUB&#34;: 1999
  }
]
&lt;&lt;/code&gt;&gt;
This file contains the different items existing in JSON.

*##Arrays##: They are enclosed in square brackets and contain a list of comma separated values.
*##Objects##: They are enclosed in curly brackets. They contain a comma separated list of pairs, each pair composed of a key name between double quotes, followed by a ‘:’ character and followed by a value.
*##Values##: Values can be an array or an object. They also can be a string between double quotes, an integer or float number, a Boolean value or a null value.
The simplest way for CONNECT to locate a table in such a file is by an array containing a list of objects (this is what MongoDB calls a collection of documents). Each array value will be a table row and each pair of the row objects will represent a column, the key being the column name and the value the column value.

A first try to create a table on this file will be to take the outer array as the table:

&lt;&lt;sql&gt;&gt;
create table jsample (
ISBN char(15),
LANG char(2),
SUBJECT char(32),
AUTHOR char(128),
TITLE char(32),
TRANSLATED char(80),
PUBLISHER char(20),
DATEPUB int(4))
engine=CONNECT table_type=JSON
File_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

If we execute the query:

&lt;&lt;sql&gt;&gt;
select isbn, author, title, publisher from jsample;
&lt;&lt;/sql&gt;&gt;

We get the result:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= isbn |= author |= title |= publisher
| 9782212090819 | Jean-Christophe Bernadac | Construire une application XML | Eyrolles Paris
| 9782840825685 | William J. Pardi | XML en Action | Microsoft Press Pari
&lt;&lt;/style&gt;&gt;

Note that by default, column values that are objects have been set to the concatenation of all the string values of the object separated by a blank. When a column value is an array, only the first item of the array is retrieved (This will change in later versions of Connect).

However, things are generally more complicated. If JSON files do not contain attributes (although object pairs are similar to attributes) they contain a new item, arrays. We have seen that they can be used like XML multiple nodes, here to specify several authors, but they are more general because they can contain objects of different types, even it may not be advisable to do so.

This is why CONNECT enables the specification of a column field_format option “JPATH” (FIELD_FORMAT until Connect 1.6) that is used to describe exactly where the items to display are and how to handles arrays.

Here is an example of a new table that can be created on the same file, allowing choosing the column names, to get some sub-objects and to specify how to handle the author array.

Until Connect 1.5:
&lt;&lt;sql&gt;&gt;
create table jsampall (
ISBN char(15),
Language char(2) field_format=&#39;LANG&#39;,
Subject char(32) field_format=&#39;SUBJECT&#39;,
Author char(128) field_format=&#39;AUTHOR:[&#34; and &#34;]&#39;,
Title char(32) field_format=&#39;TITLE&#39;,
Translation char(32) field_format=&#39;TRANSLATOR:PREFIX&#39;,
Translator char(80) field_format=&#39;TRANSLATOR&#39;,
Publisher char(20) field_format=&#39;PUBLISHER:NAME&#39;,
Location char(16) field_format=&#39;PUBLISHER:PLACE&#39;,
Year int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON File_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

From Connect 1.6:
&lt;&lt;sql&gt;&gt;
create table jsampall (
ISBN char(15),
Language char(2) field_format=&#39;LANG&#39;,
Subject char(32) field_format=&#39;SUBJECT&#39;,
Author char(128) field_format=&#39;AUTHOR.[&#34; and &#34;]&#39;,
Title char(32) field_format=&#39;TITLE&#39;,
Translation char(32) field_format=&#39;TRANSLATOR.PREFIX&#39;,
Translator char(80) field_format=&#39;TRANSLATOR&#39;,
Publisher char(20) field_format=&#39;PUBLISHER.NAME&#39;,
Location char(16) field_format=&#39;PUBLISHER.PLACE&#39;,
Year int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON File_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

From Connect 1.07.0002
&lt;&lt;sql&gt;&gt;
create table jsampall (
ISBN char(15),
Language char(2) jpath=&#39;$.LANG&#39;,
Subject char(32) jpath=&#39;$.SUBJECT&#39;,
Author char(128) jpath=&#39;$.AUTHOR[&#34; and &#34;]&#39;,
Title char(32) jpath=&#39;$.TITLE&#39;,
Translation char(32) jpath=&#39;$.TRANSLATOR.PREFIX&#39;,
Translator char(80) jpath=&#39;$.TRANSLATOR&#39;,
Publisher char(20) jpath=&#39;$.PUBLISHER.NAME&#39;,
Location char(16) jpath=&#39;$.PUBLISHER.PLACE&#39;,
Year int(4) jpath=&#39;$.DATEPUB&#39;)
engine=CONNECT table_type=JSON File_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

Given the query:

&lt;&lt;sql&gt;&gt;
select title, author, publisher, location from jsampall;
&lt;&lt;/sql&gt;&gt;

The result is:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= title |= author |= publisher |= location
| Construire une application XML | Jean-Christophe Bernadac and François Knab | Eyrolles | Paris
| XML en Action | William J. Pardi | Microsoft Press | Paris
&lt;&lt;/style&gt;&gt;

Note: The JPATH was not specified for column ISBN because it defaults to the column name.

Here is another example showing that one can choose what to extract from the file and how to “expand” an array, meaning to generate one row for each array value:

Until Connect 1.5:
&lt;&lt;sql&gt;&gt;
create table jsampex (
ISBN char(15),
Title char(32) field_format=&#39;TITLE&#39;,
AuthorFN char(128) field_format=&#39;AUTHOR:[X]:FIRSTNAME&#39;,
AuthorLN char(128) field_format=&#39;AUTHOR:[X]:LASTNAME&#39;,
Year int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON File_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

From Connect 1.6:
&lt;&lt;sql&gt;&gt;
create table jsampex (
ISBN char(15),
Title char(32) field_format=&#39;TITLE&#39;,
AuthorFN char(128) field_format=&#39;AUTHOR.[X].FIRSTNAME&#39;,
AuthorLN char(128) field_format=&#39;AUTHOR.[X].LASTNAME&#39;,
Year int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON File_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

From Connect 1.06.006:
&lt;&lt;sql&gt;&gt;
create table jsampex (
ISBN char(15),
Title char(32) field_format=&#39;TITLE&#39;,
AuthorFN char(128) field_format=&#39;AUTHOR[*].FIRSTNAME&#39;,
AuthorLN char(128) field_format=&#39;AUTHOR[*].LASTNAME&#39;,
Year int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON File_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

From Connect 1.07.0002
&lt;&lt;sql&gt;&gt;
create table jsampex (
ISBN char(15),
Title char(32) jpath=&#39;TITLE&#39;,
AuthorFN char(128) jpath=&#39;AUTHOR[*].FIRSTNAME&#39;,
AuthorLN char(128) jpath=&#39;AUTHOR[*].LASTNAME&#39;,
Year int(4) jpath=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON File_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

It is displayed as:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ISBN |= Title |= AuthorFN |= AuthorLN |= Year
| 9782212090819 | Construire une application XML | Jean-Christophe | Bernadac | 1999
| 9782212090819 | Construire une application XML | François | Knab | 1999
| 9782840825685 | XML en Action | William J. | Pardi |1999
&lt;&lt;/style&gt;&gt;

Note: The example above shows that the ‘$.’, that means the beginning of the path, can be omitted.

== The Jpath Specification

&lt;&lt;style class=&#34;greenbox&#34;&gt;&gt;
From Connect 1.6, the Jpath specification has changed to be the one of the native JSON functions and more compatible with what is generally used. It is close to the standard definition and compatible to what MongoDB and other products do. The ‘:’ separator is replaced by ‘.’. Position in array is accepted MongoDB style with no square brackets. Array specification specific to CONNECT are still accepted but [*] is used for expanding and [x] for multiply. However, tables created with the previous syntax can still be used by adding SEP_CHAR=’:’ (can be done with alter table). Also, it can be now specified as JPATH (was FIELD_FORMAT) but FIELD_FORMAT is still accepted.
&lt;&lt;/style&gt;&gt;

Until Connect 1.5, it is the description of the path to follow to reach the required item. Each step is the key name (case sensitive) of the pair when crossing an object, and the number of the value between square brackets when crossing an array. Each specification is separated by a ‘:’ character.

From Connect 1.6, It is the description of the path to follow to reach the required item. Each step is the key name (case sensitive) of the pair when crossing an object, and the position number of the value when crossing an array. Key specifications are separated by a ‘.’ character.

For instance, in the above file, the last name of the second author of a book is reached by:

$.AUTHOR[1].LASTNAME	// standard style
$AUTHOR.1.LASTNAME	// MongoDB style
AUTHOR:[1]:LASTNAME   // old style when SEP_CHAR=’:’ or until Connect 1.5

The ‘$’ or “$.” prefix specifies the root of the path and can be omitted with CONNECT.

The array specification can also indicate how it must be processed:

For instance, in the above file, the last name of the second author of a book is reached by:

&lt;&lt;code&gt;&gt;
AUTHOR:[1]:LASTNAME
&lt;&lt;/code&gt;&gt;

The array specification can also indicate how it must be processed:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Specification |= Array Type |= Limit |= Description
| n (Connect &gt;= 1.6) or [n]&lt;&lt;ref&gt;&gt;The value n can be 0 based or 1 based depending on the base table option. The default is 0 to match what is the current usage in the Json world but it can be set to 1 for tables created in old versions.&lt;&lt;/ref&gt;&gt; | All | N.A |Take the nth value of the array.
| [*] (Connect &gt;= 1.6), [X] or [x] (Connect &lt;= 1.5) | All | | Expand. Generate one row for each array value.
| [&#34;string&#34;] | String | | Concatenate all values separated by the specified string.
| [+] | Numeric | | Make the sum of all the non-null array values.
| [x] (Connect &gt;= 1.6), [*] (Connect &lt;= 1.5)| Numeric | | Make the product of all non-null array values.
| [!] | Numeric | | Make the average of all the non-null array values.
| [&gt;] or [&lt;] | All ||  Return the greatest or least non-null value of the array.
| [#] | All | N.A | Return the number of values in the array.	
| [] | All | | Expand if under an expanded object. Otherwise sum if numeric, else concatenation separated by “, “.
| |  All | | Between two separators, if an array, expand it if under an expanded object or take the first value of it.
&lt;&lt;/style&gt;&gt;

Note 1: When the LIMIT restriction is applicable, only the first //m// array items are used, //m// being the value of the LIMIT option (to be specified in option_list). The LIMIT default value is 10.

Note 2: An alternative way to indicate what is to be expanded is to use the expand option in the option list, for instance:
&lt;&lt;code&gt;&gt;
OPTION_LIST=&#39;Expand=AUTHOR&#39;
&lt;&lt;/code&gt;&gt;

##AUTHOR## is here the key of the pair that has the array as a value (case sensitive). Expand is limited to only one branch (expanded arrays must be under the same object).

Let us take as an example the file ##expense.json## ([[json-sample-files|found here]]).
The table jexpall expands all under and including the week array:

From Connect 1.07.0002
&lt;&lt;code&gt;&gt;
create table jexpall (
WHO char(12),
WEEK int(2) jpath=&#39;$.WEEK[*].NUMBER&#39;,
WHAT char(32) jpath=&#39;$.WEEK[*].EXPENSE[*].WHAT&#39;,
AMOUNT double(8,2) jpath=&#39;$.WEEK[*].EXPENSE[*].AMOUNT&#39;)
engine=CONNECT table_type=JSON File_name=&#39;expense.json&#39;;
&lt;&lt;/code&gt;&gt;

From Connect.1.6
&lt;&lt;code&gt;&gt;
create table jexpall (
WHO char(12),
WEEK int(2) field_format=&#39;$.WEEK[*].NUMBER&#39;,
WHAT char(32) field_format=&#39;$.WEEK[*].EXPENSE[*].WHAT&#39;,
AMOUNT double(8,2) field_format=&#39;$.WEEK[*].EXPENSE[*].AMOUNT&#39;)
engine=CONNECT table_type=JSON File_name=&#39;expense.json&#39;;
&lt;&lt;/code&gt;&gt;

Until Connect 1.5:
&lt;&lt;code&gt;&gt;
create table jexpall (
WHO char(12),
WEEK int(2) field_format=&#39;WEEK:[x]:NUMBER&#39;,
WHAT char(32) field_format=&#39;WEEK:[x]:EXPENSE:[x]:WHAT&#39;,
AMOUNT double(8,2) field_format=&#39;WEEK:[x]:EXPENSE:[x]:AMOUNT&#39;)
engine=CONNECT table_type=JSON File_name=&#39;expense.json&#39;;
&lt;&lt;/code&gt;&gt;


&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= WHO |= WEEK |= WHAT |= AMOUNT
| Joe | 3 | Beer | 18.00
| Joe | 3 | Food | 12.00
| Joe | 3 | Food | 19.00
| Joe | 3 | Car | 20.00
| Joe | 4 | Beer | 19.00
| Joe | 4 | Beer | 16.00
| Joe | 4 | Food | 17.00
| Joe | 4 | Food | 17.00
| Joe | 4 | Beer | 14.00
| Joe | 5 | Beer | 14.00
| Joe | 5 | Food | 12.00
| Beth | 3 | Beer | 16.00
| Beth | 4 | Food | 17.00
| Beth | 4 | Beer | 15.00
| Beth | 5 | Food | 12.00
| Beth | 5 | Beer | 20.00
| Janet | 3 | Car | 19.00
| Janet | 3 | Food | 18.00
| Janet | 3 | Beer | 18.00
| Janet | 4 | Car | 17.00
| Janet | 5 | Beer | 14.00
| Janet | 5 | Car | 12.00
| Janet | 5 | Beer | 19.00
| Janet | 5 | Food | 12.00
&lt;&lt;/style&gt;&gt;

The table ##jexpw## shows what was bought and the sum and average of amounts for each person and week:

From Connect 1.07.0002
&lt;&lt;code&gt;&gt;
create table jexpw (
WHO char(12) not null,
WEEK int(2) not null jpath=&#39;$.WEEK[*].NUMBER&#39;,
WHAT char(32) not null jpath=&#39;$.WEEK[].EXPENSE[&#34;, &#34;].WHAT&#39;,
SUM double(8,2) not null jpath=&#39;$.WEEK[].EXPENSE[+].AMOUNT&#39;,
AVERAGE double(8,2) not null jpath=&#39;$.WEEK[].EXPENSE[!].AMOUNT&#39;)
engine=CONNECT table_type=JSON File_name=&#39;expense.json&#39;;
&lt;&lt;/code&gt;&gt;

From Connect 1.6:
&lt;&lt;code&gt;&gt;
create table jexpw (
WHO char(12) not null,
WEEK int(2) not null field_format=&#39;$.WEEK[*].NUMBER&#39;,
WHAT char(32) not null field_format=&#39;$.WEEK[].EXPENSE[&#34;, &#34;].WHAT&#39;,
SUM double(8,2) not null field_format=&#39;$.WEEK[].EXPENSE[+].AMOUNT&#39;,
AVERAGE double(8,2) not null field_format=&#39;$.WEEK[].EXPENSE[!].AMOUNT&#39;)
engine=CONNECT table_type=JSON File_name=&#39;expense.json&#39;;
&lt;&lt;/code&gt;&gt;

Until Connect 1.5:
&lt;&lt;code&gt;&gt;
create table jexpw (
WHO char(12) not null,
WEEK int(2) not null field_format=&#39;WEEK:[x]:NUMBER&#39;,
WHAT char(32) not null field_format=&#39;WEEK::EXPENSE:[&#34;, &#34;]:WHAT&#39;,
SUM double(8,2) not null field_format=&#39;WEEK::EXPENSE:[+]:AMOUNT&#39;,
AVERAGE double(8,2) not null field_format=&#39;WEEK::EXPENSE:[!]:AMOUNT&#39;)
engine=CONNECT table_type=JSON File_name=&#39;expense.json&#39;;
&lt;&lt;/code&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= WHO |= WEEK |= WHAT |= SUM |= AVERAGE
| Joe | 3 | Beer, Food, Food, Car | 69.00 | 17.25
| Joe| 4 | Beer, Beer, Food, Food, Beer | 83.00 | 16.60
| Joe | 5 | Beer, Food | 26.00 | 13.00 
| Beth | 3 | Beer | 16.00 | 16.00 
| Beth | 4 | Food, Beer | 32.00 | 16.00
| Beth | 5 | Food, Beer | 32.00 | 16.00
| Janet | 3 | Car, Food, Beer | 55.00 | 18.33
| Janet | 4 | Car | 17.00 | 17.00
| Janet | 5 | Beer, Car, Beer, Food | 57.00 | 14.25
&lt;&lt;/style&gt;&gt;

Let us see what the table ##jexpz## does:

From Connect 1.6:
&lt;&lt;code&gt;&gt;
create table jexpz (
WHO char(12) not null,
WEEKS char(12) not null field_format=&#39;WEEK[&#34;, &#34;].NUMBER&#39;,
SUMS char(64) not null field_format=&#39;WEEK[&#34;+&#34;].EXPENSE[+].AMOUNT&#39;,
SUM double(8,2) not null field_format=&#39;WEEK[+].EXPENSE[+].AMOUNT&#39;,
AVGS char(64) not null field_format=&#39;WEEK[&#34;+&#34;].EXPENSE[!].AMOUNT&#39;,
SUMAVG double(8,2) not null field_format=&#39;WEEK[+].EXPENSE[!].AMOUNT&#39;,
AVGSUM double(8,2) not null field_format=&#39;WEEK[!].EXPENSE[+].AMOUNT&#39;,
AVERAGE double(8,2) not null field_format=&#39;WEEK[!].EXPENSE[*].AMOUNT&#39;)
engine=CONNECT table_type=JSON File_name=&#39;expense.json&#39;;
&lt;&lt;/code&gt;&gt;

From Connect 1.07.0002
&lt;&lt;code&gt;&gt;
create table jexpz (
WHO char(12) not null,
WEEKS char(12) not null jpath=&#39;WEEK[&#34;, &#34;].NUMBER&#39;,
SUMS char(64) not null jpath=&#39;WEEK[&#34;+&#34;].EXPENSE[+].AMOUNT&#39;,
SUM double(8,2) not null jpath=&#39;WEEK[+].EXPENSE[+].AMOUNT&#39;,
AVGS char(64) not null jpath=&#39;WEEK[&#34;+&#34;].EXPENSE[!].AMOUNT&#39;,
SUMAVG double(8,2) not null jpath=&#39;WEEK[+].EXPENSE[!].AMOUNT&#39;,
AVGSUM double(8,2) not null jpath=&#39;WEEK[!].EXPENSE[+].AMOUNT&#39;,
AVERAGE double(8,2) not null jpath=&#39;WEEK[!].EXPENSE[*].AMOUNT&#39;)
engine=CONNECT table_type=JSON File_name=&#39;expense.json&#39;;
&lt;&lt;/code&gt;&gt;

Until Connect 1.5:
&lt;&lt;code&gt;&gt;
create table jexpz (
WHO char(12) not null,
WEEKS char(12) not null field_format=&#39;WEEK:[&#34;, &#34;]:NUMBER&#39;,
SUMS char(64) not null field_format=&#39;WEEK:[&#34;+&#34;]:EXPENSE:[+]:AMOUNT&#39;,
SUM double(8,2) not null field_format=&#39;WEEK:[+]:EXPENSE:[+]:AMOUNT&#39;,
AVGS char(64) not null field_format=&#39;WEEK:[&#34;+&#34;]:EXPENSE:[!]:AMOUNT&#39;,
SUMAVG double(8,2) not null field_format=&#39;WEEK:[+]:EXPENSE:[!]:AMOUNT&#39;,
AVGSUM double(8,2) not null field_format=&#39;WEEK:[!]:EXPENSE:[+]:AMOUNT&#39;,
AVERAGE double(8,2) not null field_format=&#39;WEEK:[!]:EXPENSE:[x]:AMOUNT&#39;)
engine=CONNECT table_type=JSON
File_name=&#39;E:/Data/Json/expense2.json&#39;;
&lt;&lt;/code&gt;&gt;


&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= WHO |= WEEKS |= SUMS |= SUM |= AVGS |= SUMAVG |= AVGSUM |= AVERAGE
| Joe | 3, 4, 5 | 69.00+83.00+26.00 | 178.00 | 17.25+16.60+13.00 | 46.85 | 59.33 | 16.18
| Beth | 3, 4, 5 | 16.00+32.00+32.00 | 80.00 | 16.00+16.00+16.00 | 48.00 | 26.67 | 16.00
| Janet | 3, 4, 5 | 55.00+17.00+57.00 | 129.00 | 18.33+17.00+14.25 | 49.58 | 43.00 | 16.12
&lt;&lt;/style&gt;&gt;

For all persons:

* Column 1 show the person name.
* Column 2 shows the weeks for which values are calculated.
* Column 3 lists the sums of expenses for each week.
* Column 4 calculates the sum of all expenses by person.
* Column 5 shows the week’s expense averages.
* Column 6 calculates the sum of these averages.
* Column 7 calculates the average of the week’s sum of expenses.
* Column 8 calculates the average expense by person. 

It would be very difficult, if even possible, to obtain this result from table ##jexpall## using an SQL query.

== Handling of NULL Values
Json has a null explicit value that can be met in arrays or object key values. When regarding json as a relational table, a column value can be null because the corresponding json item is explicitly null, or implicitly because the corresponding item is missing in an array or object. CONNECT does not make any distinction between explicit and implicit nulls.

However, it is possible to specify how nulls are handled and represented. This is done by setting the string session variable [[connect-system-variables/#connect_json_null|connect_json_null]]. The default value of connect_json_null is “&lt;null&gt;”; it can be changed, for instance, by:
&lt;&lt;code&gt;&gt;
SET connect_json_null=&#39;NULL&#39;;
&lt;&lt;/code&gt;&gt;

This changes its representation when a column displays the text of an object or the concatenation of the values of an array.

It is also possible to tell CONNECT to ignore nulls by:
&lt;&lt;code&gt;&gt;
SET connect_json_null=NULL;
&lt;&lt;/code&gt;&gt;

When doing so, nulls do not appear in object text or array lists. However, this does not change the behavior of array calculation nor the result of array count.

== Having Columns defined by Discovery
It is possible to let the MariaDB discovery process do the job of column specification. When columns are not defined in the create table statement, CONNECT endeavors to analyze the JSON file and to provide the column specifications. This is possible only for tables represented by an array of objects because CONNECT retrieves the column names from the object pair keys and their definition from the object pair values. For instance, the jsample table could be created saying:

&lt;&lt;sql&gt;&gt;
create table jsample engine=connect table_type=JSON file_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

Let’s check how it was actually specified using the show create table statement:

&lt;&lt;sql&gt;&gt;
CREATE TABLE `jsample` (
  `ISBN` char(13) NOT NULL,
  `LANG` char(2) NOT NULL,
  `SUBJECT` char(12) NOT NULL,
  `AUTHOR` varchar(256) DEFAULT NULL,
  `TITLE` char(30) NOT NULL,
  `TRANSLATED` varchar(256) DEFAULT NULL,
  `PUBLISHER` varchar(256) DEFAULT NULL,
  `DATEPUB` int(4) NOT NULL
) ENGINE=CONNECT DEFAULT CHARSET=latin1 `TABLE_TYPE`=&#39;JSON&#39; `FILE_NAME`=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

It is equivalent except for the column sizes that have been calculated from the file as the maximum length of the corresponding column when it was a normal value. For columns that are json arrays or objects, the column is specified as a varchar string of length 256, supposedly big enough to contain the sub-object&#39;s concatenated values. Nullable is set to true if the column is null or missing in some rows or if its JPATH contains arrays.

If a more complex definition is desired, you can ask CONNECT to analyse the JPATH up to a given depth using the DEPTH or LEVEL option in the option list. Its default value is 0 but can be changed setting the [[connect-system-variables/#connect_default_depth|connect_default_depth]] session variable (in future versions the default will be 5). The depth value is the number of sub-objects that are taken in the JPATH2 (this is different from what is defined and returned by the native [[json_depth|Json_Depth]] function).

For instance:

&lt;&lt;sql&gt;&gt;
create table jsampall2 engine=connect table_type=JSON 
  file_name=&#39;biblio3.json&#39; option_list=&#39;level=1&#39;;
&lt;&lt;/sql&gt;&gt;

This will define the table as:

From Connect 1.07.0002
&lt;&lt;sql&gt;&gt;
CREATE TABLE `jsampall2` (
  `ISBN` char(13) NOT NULL,
  `LANG` char(2) NOT NULL,
  `SUBJECT` char(12) NOT NULL,
  `AUTHOR_FIRSTNAME` char(15) NOT NULL `JPATH`=&#39;$.AUTHOR.[0].FIRSTNAME&#39;,
  `AUTHOR_LASTNAME` char(8) NOT NULL `JPATH`=&#39;$.AUTHOR.[0].LASTNAME&#39;,
  `TITLE` char(30) NOT NULL,
  `TRANSLATED_PREFIX` char(23) DEFAULT NULL `JPATH`=&#39;$.TRANSLATED.PREFIX&#39;,
  `TRANSLATED_TRANSLATOR` varchar(256) DEFAULT NULL `JPATH`=&#39;$.TRANSLATED.TRANSLATOR&#39;,
  `PUBLISHER_NAME` char(15) NOT NULL `JPATH`=&#39;$.PUBLISHER.NAME&#39;,
  `PUBLISHER_PLACE` char(5) NOT NULL `JPATH`=&#39;$.PUBLISHER.PLACE&#39;,
  `DATEPUB` int(4) NOT NULL
) ENGINE=CONNECT DEFAULT CHARSET=latin1 `TABLE_TYPE`=&#39;JSON&#39; 
  `FILE_NAME`=&#39;biblio3.json&#39; `OPTION_LIST`=&#39;depth=1&#39;;
&lt;&lt;/sql&gt;&gt;

From Connect 1.6:
&lt;&lt;sql&gt;&gt;
CREATE TABLE `jsampall2` (
  `ISBN` char(13) NOT NULL,
  `LANG` char(2) NOT NULL,
  `SUBJECT` char(12) NOT NULL,
  `AUTHOR_FIRSTNAME` char(15) NOT NULL `FIELD_FORMAT`=&#39;AUTHOR..FIRSTNAME&#39;,
  `AUTHOR_LASTNAME` char(8) NOT NULL `FIELD_FORMAT`=&#39;AUTHOR..LASTNAME&#39;,
  `TITLE` char(30) NOT NULL,
  `TRANSLATED_PREFIX` char(23) DEFAULT NULL `FIELD_FORMAT`=&#39;TRANSLATED.PREFIX&#39;,
  `TRANSLATED_TRANSLATOR` varchar(256) DEFAULT NULL `FIELD_FORMAT`=&#39;TRANSLATED.TRANSLATOR&#39;,
  `PUBLISHER_NAME` char(15) NOT NULL `FIELD_FORMAT`=&#39;PUBLISHER.NAME&#39;,
  `PUBLISHER_PLACE` char(5) NOT NULL `FIELD_FORMAT`=&#39;PUBLISHER.PLACE&#39;,
  `DATEPUB` int(4) NOT NULL
) ENGINE=CONNECT DEFAULT CHARSET=latin1 `TABLE_TYPE`=&#39;JSON&#39; 
  `FILE_NAME`=&#39;biblio3.json&#39; `OPTION_LIST`=&#39;level=1&#39;;
&lt;&lt;/sql&gt;&gt;

Until Connect 1.5:
&lt;&lt;sql&gt;&gt;
CREATE TABLE `jsampall2` (
  `ISBN` char(13) NOT NULL,
  `LANG` char(2) NOT NULL,
  `SUBJECT` char(12) NOT NULL,
  `AUTHOR_FIRSTNAME` char(15) NOT NULL `FIELD_FORMAT`=&#39;AUTHOR::FIRSTNAME&#39;,
  `AUTHOR_LASTNAME` char(8) NOT NULL `FIELD_FORMAT`=&#39;AUTHOR::LASTNAME&#39;,
  `TITLE` char(30) NOT NULL,
  `TRANSLATED_PREFIX` char(23) DEFAULT NULL `FIELD_FORMAT`=&#39;TRANSLATED:PREFIX&#39;,
  `TRANSLATED_TRANSLATOR` varchar(256) DEFAULT NULL `FIELD_FORMAT`=&#39;TRANSLATED:TRANSLATOR&#39;,
  `PUBLISHER_NAME` char(15) NOT NULL `FIELD_FORMAT`=&#39;PUBLISHER:NAME&#39;,
  `PUBLISHER_PLACE` char(5) NOT NULL `FIELD_FORMAT`=&#39;PUBLISHER:PLACE&#39;,
  `DATEPUB` int(4) NOT NULL
) ENGINE=CONNECT DEFAULT CHARSET=latin1 `TABLE_TYPE`=&#39;JSON&#39; `
  FILE_NAME`=&#39;biblio3.json&#39; `OPTION_LIST`=&#39;level=1&#39;;
&lt;&lt;/sql&gt;&gt;

For columns that are a simple value, the Json path is the column name. This is the default when the Jpath option is not specified, so it was not specified for such columns. However, you can force discovery to specify it by setting the connect_all_path variable to 1 or ON. This can be useful if you plan to change the name of such columns and relieves you of manually specifying the path (otherwise it would default to the new name and cause the column to not or wrongly be found).

Another problem is that CONNECT cannot guess what you want to do with arrays. Here the AUTHOR array is set to 0, which means that only its first value will be retrieved unless you also had specified “Expand=AUTHOR” in the option list. But of course, you can replace it with anything else.

This method can be used as a quick way to make a “template” table definition that can later be edited to make the desired definition. In particular, column names are constructed from all the object keys of their path in order to have distinct column names. This can be manually edited to have the desired names, provided their JPATH key names are not modified.

DEPTH can also be given the value -1 to create only columns that are simple values (no array or object). It normally defaults to 0 but this can be modified setting the [[connect-system-variables/#connect_default_depth|connect_default_depth]] variable.

Note: Since version 1.6.4, CONNECT eliminates columns that are “void” or whose type cannot be determined. For instance given the file sresto.json:

&lt;&lt;code&gt;&gt;
{&#34;_id&#34;:1,&#34;name&#34;:&#34;Corner Social&#34;,&#34;cuisine&#34;:&#34;American&#34;,&#34;grades&#34;:[{&#34;grade&#34;:&#34;A&#34;,&#34;score&#34;:6}]}
{&#34;_id&#34;:2,&#34;name&#34;:&#34;La Nueva Clasica Antillana&#34;,&#34;cuisine&#34;:&#34;Spanish&#34;,&#34;grades&#34;:[]}
&lt;&lt;/code&gt;&gt;

Previously, when using discovery, creating the table by:

&lt;&lt;code&gt;&gt;
create table sjr0
engine=connect table_type=JSON file_name=&#39;sresto.json&#39;
option_list=&#39;Pretty=0,Depth=1&#39; lrecl=128;
&lt;&lt;/code&gt;&gt;

The table was previously created as:

&lt;&lt;sql&gt;&gt;
CREATE TABLE `sjr0` (
  `_id` bigint(1) NOT NULL,
  `name` char(26) NOT NULL,
  `cuisine` char(8) NOT NULL,
  `grades` char(1) DEFAULT NULL,
  `grades_grade` char(1) DEFAULT NULL `JPATH`=&#39;$.grades[0].grade&#39;,
  `grades_score` bigint(1) DEFAULT NULL `JPATH`=&#39;$.grades[0].score&#39;
) ENGINE=CONNECT DEFAULT CHARSET=latin1 `TABLE_TYPE`=&#39;JSON&#39;
  `FILE_NAME`=&#39;sresto.json&#39; 
  `OPTION_LIST`=&#39;Pretty=0,Depth=1,Accept=1&#39; `LRECL`=128;
&lt;&lt;/sql&gt;&gt;
The column “grades” was added because of the void array in line 2. Now this column is skipped and does not appear anymore (unless the option ##Accept=1## is added in the option list).


== JSON Catalogue Tables
Another way to see JSON table column specifications is to use a catalogue table. For instance:

&lt;&lt;sql&gt;&gt;
create table bibcol engine=connect table_type=JSON file_name=&#39;biblio3.json&#39; 
  option_list=&#39;level=2&#39; catfunc=columns;
select column_name, type_name type, column_size size, jpath from bibcol;
&lt;&lt;/sql&gt;&gt;

which returns:

From Connect 1.07.0002:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= column_name |= type |= size |= jpath |
| ISBN | CHAR | 13 | $.ISBN |
| LANG | CHAR | 2 | $.LANG |
| SUBJECT | CHAR | 12 | $.SUBJECT |
| AUTHOR_FIRSTNAME | CHAR | 15 | $.AUTHOR[0].FIRSTNAME | 
| AUTHOR_LASTNAME | CHAR | 8 | $.AUTHOR[0].LASTNAME | 
| TITLE | CHAR | 30 | $.TITLE |
| TRANSLATED_PREFIX | CHAR | 23 | $.TRANSLATED.PREFIX |
| TRANSLATED_TRANSLATOR_FIRSTNAME | CHAR | 5 | $TRANSLATED.TRANSLATOR.FIRSTNAME |
| TRANSLATED_TRANSLATOR_LASTNAME | CHAR | 6 | $.TRANSLATED.TRANSLATOR.LASTNAME |
| PUBLISHER_NAME | CHAR | 15 | $.PUBLISHER.NAME |
| PUBLISHER_PLACE | CHAR | 5 | $.PUBLISHER.PLACE | 
| DATEPUB | INTEGER | 4 | $.DATEPUB |
&lt;&lt;/style&gt;&gt;

From Connect 1.6:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= column_name |= type |= size |= jpath |
| ISBN | CHAR | 13 | |
| LANG | CHAR | 2 | |
| SUBJECT | CHAR | 12 | |
| AUTHOR_FIRSTNAME | CHAR | 15 | AUTHOR..FIRSTNAME | 
| AUTHOR_LASTNAME | CHAR | 8 | AUTHOR..LASTNAME | 
| TITLE | CHAR | 30 | |
| TRANSLATED_PREFIX | CHAR | 23 | TRANSLATED.PREFIX |
| TRANSLATED_TRANSLATOR_FIRSTNAME | CHAR | 5 | TRANSLATED.TRANSLATOR.FIRSTNAME |
| TRANSLATED_TRANSLATOR_LASTNAME | CHAR | 6 | TRANSLATED.TRANSLATOR.LASTNAME |
| PUBLISHER_NAME | CHAR | 15 | PUBLISHER.NAME |
| PUBLISHER_PLACE | CHAR | 5 | PUBLISHER.PLACE | 
| DATEPUB | INTEGER | 4 | |
&lt;&lt;/style&gt;&gt;

Until Connect 1.5:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= column_name |= type |= size |= jpath |
| ISBN | CHAR | 13 | |
| LANG | CHAR | 2 | |
| SUBJECT | CHAR | 12 | |
| AUTHOR_FIRSTNAME | CHAR | 15 | AUTHOR::FIRSTNAME | 
| AUTHOR_LASTNAME | CHAR | 8 | AUTHOR::LASTNAME | 
| TITLE | CHAR | 30 | |
| TRANSLATED_PREFIX | CHAR | 23 | TRANSLATED:PREFIX |
| TRANSLATED_TRANSLATOR_FIRSTNAME | CHAR | 5 | TRANSLATED:TRANSLATOR:FIRSTNAME |
| TRANSLATED_TRANSLATOR_LASTNAME | CHAR | 6 | TRANSLATED:TRANSLATOR:LASTNAME |
| PUBLISHER_NAME | CHAR | 15 | PUBLISHER:NAME |
| PUBLISHER_PLACE | CHAR | 5 | PUBLISHER:PLACE | 
| DATEPUB | INTEGER | 4 | |
&lt;&lt;/style&gt;&gt;

All this is mostly useful when creating a table on a remote file that you cannot easily see.

== Finding the table within a JSON file
Given the file “facebook.json”:
&lt;&lt;code&gt;&gt;
{
   &#34;data&#34;: [
      {
         &#34;id&#34;: &#34;X999_Y999&#34;,
         &#34;from&#34;: {
            &#34;name&#34;: &#34;Tom Brady&#34;, &#34;id&#34;: &#34;X12&#34;
         },
         &#34;message&#34;: &#34;Looking forward to 2010!&#34;,
         &#34;actions&#34;: [
            {
               &#34;name&#34;: &#34;Comment&#34;,
               &#34;link&#34;: &#34;http://www.facebook.com/X999/posts/Y999&#34;
            },
            {
               &#34;name&#34;: &#34;Like&#34;,
               &#34;link&#34;: &#34;http://www.facebook.com/X999/posts/Y999&#34;
            }
         ],
         &#34;type&#34;: &#34;status&#34;,
         &#34;created_time&#34;: &#34;2010-08-02T21:27:44+0000&#34;,
         &#34;updated_time&#34;: &#34;2010-08-02T21:27:44+0000&#34;
      },
      {
         &#34;id&#34;: &#34;X998_Y998&#34;,
         &#34;from&#34;: {
            &#34;name&#34;: &#34;Peyton Manning&#34;, &#34;id&#34;: &#34;X18&#34;
         },
         &#34;message&#34;: &#34;Where&#39;s my contract?&#34;,
         &#34;actions&#34;: [
            {
               &#34;name&#34;: &#34;Comment&#34;,
               &#34;link&#34;: &#34;http://www.facebook.com/X998/posts/Y998&#34;
            },
            {
               &#34;name&#34;: &#34;Like&#34;,
               &#34;link&#34;: &#34;http://www.facebook.com/X998/posts/Y998&#34;
            }
         ],
         &#34;type&#34;: &#34;status&#34;,
         &#34;created_time&#34;: &#34;2010-08-02T21:27:44+0000&#34;,
         &#34;updated_time&#34;: &#34;2010-08-02T21:27:44+0000&#34;
      }
   ]
}
&lt;&lt;/code&gt;&gt;

The table we want to analyze is represented by the array value of the “data” object. Here is how this is specified in the create table statement:


From Connect 1.07.0002:
&lt;&lt;sql&gt;&gt;
create table jfacebook (
`ID` char(10) jpath=&#39;id&#39;,
`Name` char(32) jpath=&#39;from.name&#39;,
`MyID` char(16) jpath=&#39;from.id&#39;,
`Message` varchar(256) jpath=&#39;message&#39;,
`Action` char(16) jpath=&#39;actions..name&#39;,
`Link` varchar(256) jpath=&#39;actions..link&#39;,
`Type` char(16) jpath=&#39;type&#39;,
`Created` datetime date_format=&#39;YYYY-MM-DD\&#39;T\&#39;hh:mm:ss&#39; jpath=&#39;created_time&#39;,
`Updated` datetime date_format=&#39;YYYY-MM-DD\&#39;T\&#39;hh:mm:ss&#39; jpath=&#39;updated_time&#39;)
engine=connect table_type=JSON file_name=&#39;facebook.json&#39; option_list=&#39;Object=data,Expand=actions&#39;;
&lt;&lt;/sql&gt;&gt;

From Connect 1.6:
&lt;&lt;sql&gt;&gt;
create table jfacebook (
`ID` char(10) field_format=&#39;id&#39;,
`Name` char(32) field_format=&#39;from.name&#39;,
`MyID` char(16) field_format=&#39;from.id&#39;,
`Message` varchar(256) field_format=&#39;message&#39;,
`Action` char(16) field_format=&#39;actions..name&#39;,
`Link` varchar(256) field_format=&#39;actions..link&#39;,
`Type` char(16) field_format=&#39;type&#39;,
`Created` datetime date_format=&#39;YYYY-MM-DD\&#39;T\&#39;hh:mm:ss&#39; field_format=&#39;created_time&#39;,
`Updated` datetime date_format=&#39;YYYY-MM-DD\&#39;T\&#39;hh:mm:ss&#39; field_format=&#39;updated_time&#39;)
engine=connect table_type=JSON file_name=&#39;facebook.json&#39; option_list=&#39;Object=data,Expand=actions&#39;;
&lt;&lt;/sql&gt;&gt;

Until Connect 1.5:
&lt;&lt;sql&gt;&gt;
create table jfacebook (
`ID` char(10) field_format=&#39;id&#39;,
`Name` char(32) field_format=&#39;from:name&#39;,
`MyID` char(16) field_format=&#39;from:id&#39;,
`Message` varchar(256) field_format=&#39;message&#39;,
`Action` char(16) field_format=&#39;actions::name&#39;,
`Link` varchar(256) field_format=&#39;actions::link&#39;,
`Type` char(16) field_format=&#39;type&#39;,
`Created` datetime date_format=&#39;YYYY-MM-DD\&#39;T\&#39;hh:mm:ss&#39; field_format=&#39;created_time&#39;,
`Updated` datetime date_format=&#39;YYYY-MM-DD\&#39;T\&#39;hh:mm:ss&#39; field_format=&#39;updated_time&#39;)
engine=connect table_type=JSON file_name=&#39;facebook.json&#39; option_list=&#39;Object=data,Expand=actions&#39;;
&lt;&lt;/sql&gt;&gt;



This is the object option that gives the Jpath of the table. Note also an alternate way to declare the array to be expanded by the expand option of the option_list.

Because some string values contain a date representation, the corresponding columns are declared as datetime and the date format is specified for them.

The Jpath of the object option has the same syntax as the column Jpath but of course all array steps must be specified using the [n] (until Connect 1.5) or n (from Connect 1.6) format.

Note: This applies to the whole document for tables having ##PRETTY = 2## (see below). Otherwise, it applies to the document objects of each file records.

== JSON File Formats
The examples we have seen so far are files that, even they can be formatted in different ways (blanks, tabs, carriage return and line feed are ignored when parsing them), respect the JSON syntax and are made of only one item (Object or Array). Like for XML files, they are entirely parsed and a memory representation is made used to process them. This implies that they are of reasonable size to avoid an out of memory condition. Tables based on such files are recognized by the option Pretty=2 that we did not specify above because this is the default.

An alternate format, which is the format of exported MongoDB files, is a file where each row is physically stored in one file record. For instance:

&lt;&lt;code wrap=true&gt;&gt;
{ &#34;_id&#34; : &#34;01001&#34;, &#34;city&#34; : &#34;AGAWAM&#34;, &#34;loc&#34; : [ -72.622739, 42.070206 ], &#34;pop&#34; : 15338, &#34;state&#34; : &#34;MA&#34; }
{ &#34;_id&#34; : &#34;01002&#34;, &#34;city&#34; : &#34;CUSHMAN&#34;, &#34;loc&#34; : [ -72.51564999999999, 42.377017 ], &#34;pop&#34; : 36963, &#34;state&#34; : &#34;MA&#34; }
{ &#34;_id&#34; : &#34;01005&#34;, &#34;city&#34; : &#34;BARRE&#34;, &#34;loc&#34; : [ -72.1083540000001, 42.409698 ], &#34;pop&#34; : 4546, &#34;state&#34; : &#34;MA&#34; }
{ &#34;_id&#34; : &#34;01007&#34;, &#34;city&#34; : &#34;BELCHERTOWN&#34;, &#34;loc&#34; : [ -72.4109530000001, 42.275103 ], &#34;pop&#34; : 10579, &#34;state&#34; : &#34;MA&#34; }
…
{ &#34;_id&#34; : &#34;99929&#34;, &#34;city&#34; : &#34;WRANGELL&#34;, &#34;loc&#34; : [ -132.352918, 56.433524 ], &#34;pop&#34; : 2573, &#34;state&#34; : &#34;AK&#34; }
{ &#34;_id&#34; : &#34;99950&#34;, &#34;city&#34; : &#34;KETCHIKAN&#34;, &#34;loc&#34; : [ -133.18479, 55.942471 ], &#34;pop&#34; : 422, &#34;state&#34; : &#34;AK&#34; }
&lt;&lt;/code&gt;&gt;

The original file, “cities.json”, has 29352 records. To base a table on this file we must specify the option Pretty=0 in the option list. For instance:

From Connect 1.07.0002:
&lt;&lt;sql&gt;&gt;
create table cities (
`_id` char(5) key,
`city` char(32),
`lat` double(12,6) jpath=&#39;loc.0&#39;,
`long` double(12,6) jpath=&#39;loc.1&#39;,
`pop` int(8),
`state` char(2) distrib=&#39;clustered&#39;)
engine=CONNECT table_type=JSON file_name=&#39;cities.json&#39; lrecl=128 option_list=&#39;pretty=0&#39;;
&lt;&lt;/sql&gt;&gt;

From Connect 1.6:
&lt;&lt;sql&gt;&gt;
create table cities (
`_id` char(5) key,
`city` char(32),
`lat` double(12,6) field_format=&#39;loc.0&#39;,
`long` double(12,6) field_format=&#39;loc.1&#39;,
`pop` int(8),
`state` char(2) distrib=&#39;clustered&#39;)
engine=CONNECT table_type=JSON file_name=&#39;cities.json&#39; lrecl=128 option_list=&#39;pretty=0&#39;;
&lt;&lt;/sql&gt;&gt;

Until Connect 1.5:
&lt;&lt;sql&gt;&gt;
create table cities (
`_id` char(5) key,
`city` char(32),
`long` double(12,6) field_format=&#39;loc:[0]&#39;,
`lat` double(12,6) field_format=&#39;loc:[1]&#39;,
`pop` int(8),
`state` char(2) distrib=&#39;clustered&#39;)
engine=CONNECT table_type=JSON file_name=&#39;cities.json&#39; lrecl=128 option_list=&#39;pretty=0&#39;;
&lt;&lt;/sql&gt;&gt;

Note the use of [n] (until Connect 1.5) or n (from Connect 1.6) array specifications for the longitude and latitude columns.

When using this format, the table is processed by CONNECT like a DOS, CSV or FMT table. Rows are retrieved and parsed by records and the table can be very large. Another advantage is that such a table can be indexed, which can be of great value for very large tables. The “distrib” option of the “state” column tells CONNECT to use block indexing when possible.

For such tables – as well as for //pretty=1// ones – the record size must be specified using the LRECL option. Be sure you don’t specify it too small as it is used to allocate the read/write buffers and the memory used for parsing the rows. If in doubt, be generous as it does not cost much in memory allocation.

Another format exists, noted by Pretty=1, which is similar to this one but has some additions to represent a JSON array. A header and a trailer records are added containing the opening and closing square bracket, and all records but the last are followed by a comma. It has the same advantages for reading and updating, but inserting and deleting are executed in the pretty=2 way.

== Alternate Table Arrangement
We have seen that the most natural way to represent a table in a JSON file is to make it on an array of objects. However, other possibilities exist. A table can be an array of arrays, a one column table can be an array of values, or a one row table can be just one object or one value. Single row tables are internally handled by adding a one value array around them.

Let us see how to handle, for instance, a table that is an array of arrays. The file:
&lt;&lt;code&gt;&gt;
[
  [56, &#34;Coucou&#34;, 500.00],
  [[2,0,1,4], &#34;Hello World&#34;, 2.0316],
  [&#34;1784&#34;, &#34;John Doo&#34;, 32.4500],
  [1914, [&#34;Nabucho&#34;,&#34;donosor&#34;], 5.12],
  [7, &#34;sept&#34;, [0.77,1.22,2.01]],
  [8, &#34;huit&#34;, 13.0]
]
&lt;&lt;/code&gt;&gt;

A table can be created on this file as:

From Connect 1.07.0002:
&lt;&lt;sql&gt;&gt;
create table xjson (
`a` int(6) jpath=&#39;1&#39;,
`b` char(32) jpath=&#39;2&#39;,
`c` double(10,4) jpath=&#39;3&#39;)
engine=connect table_type=JSON file_name=&#39;test.json&#39; option_list=&#39;Pretty=1,Jmode=1,Base=1&#39; lrecl=128;
&lt;&lt;/sql&gt;&gt;

From Connect 1.6:
&lt;&lt;sql&gt;&gt;
create table xjson (
`a` int(6) field_format=&#39;1&#39;,
`b` char(32) field_format=&#39;2&#39;,
`c` double(10,4) field_format=&#39;3&#39;)
engine=connect table_type=JSON file_name=&#39;test.json&#39; option_list=&#39;Pretty=1,Jmode=1,Base=1&#39; lrecl=128;
&lt;&lt;/sql&gt;&gt;

Until Connect 1.5:
&lt;&lt;sql&gt;&gt;
create table xjson (
`a` int(6) field_format=&#39;[1]&#39;,
`b` char(32) field_format=&#39;[2]&#39;,
`c` double(10,4) field_format=&#39;[3]&#39;)
engine=connect table_type=JSON file_name=&#39;test.json&#39;
option_list=&#39;Pretty=1,Jmode=1,Base=1&#39; lrecl=128;
&lt;&lt;/sql&gt;&gt;

Columns are specified by their position in the row arrays. By default, this is zero-based but for this table the base was set to 1 by the //Base// option of the option list. Another new option in the option list is Jmode=1.
It indicates what type of table this is. The Jmode values are:

# An array of objects. This is the default.
# An array of Array. Like this one.
# An array of values.

When reading, this is not required as the type of the array items is specified for the columns; however, it is required when inserting new rows so CONNECT knows what to insert. For instance:

&lt;&lt;code&gt;&gt;
insert into xjson values(25, &#39;Breakfast&#39;, 1.414);
&lt;&lt;/code&gt;&gt;

After this, it is displayed as:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= a |= b |= c
| 56 | Coucou | 500.0000
| 2 | Hello World | 2.0316
|1784 | John Doo | 32.4500
| 1914 | Nabucho | 5.1200
| 7 | sept | 0.7700
| 8 | huit | 13.0000
| 25 | Breakfast | 1.4140
&lt;&lt;/style&gt;&gt;

Unspecified array values are represented by their first element.

== Getting and Setting JSON Representation of a Column
We have seen that columns corresponding to a Json object or array are retrieved by default as the concatenation of all its values separated by a blank. It is also possible to retrieve and display such column contains as the full JSON string corresponding to it in the JSON file. This is specified in the JPATH by a “*” where the object or array would be specified. 

Note: When having columns generated by discovery, this can be specified by adding the STRINGIFY option to ON or 1 in the option list.
 
For instance:

From Connect 1.07.0002:
&lt;&lt;sql&gt;&gt;
create table jsample2 (
ISBN char(15),
Lng char(2) jpath=&#39;LANG&#39;,
json_Author char(255) jpath=&#39;AUTHOR.*&#39;,
Title char(32) jpath=&#39;TITLE&#39;,
Year int(4) jpath=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON file_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

From Connect 1.6:
&lt;&lt;code&gt;&gt;
create table jsample2 (
ISBN char(15),
Lng char(2) field_format=&#39;LANG&#39;,
json_Author char(255) field_format=&#39;AUTHOR.*&#39;,
Title char(32) field_format=&#39;TITLE&#39;,
Year int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON file_name=&#39;biblio3.json&#39;;
&lt;&lt;/code&gt;&gt;

Until Connect 1.5:
&lt;&lt;code&gt;&gt;
create table jsample2 (
ISBN char(15),
Lng char(2) field_format=&#39;LANG&#39;,
json_Author char(255) field_format=&#39;AUTHOR:*&#39;,
Title char(32) field_format=&#39;TITLE&#39;,
Year int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON file_name=&#39;biblio3.json&#39;;
&lt;&lt;/code&gt;&gt;

Now the query:

&lt;&lt;sql&gt;&gt;
select json_Author from jsample2;
&lt;&lt;/sql&gt;&gt;

will return and display :

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= json_Author
| [{&#34;FIRSTNAME&#34;:&#34;Jean-Christophe&#34;,&#34;LASTNAME&#34;:&#34;Bernadac&#34;},{&#34;FIRSTNAME&#34;:&#34;François&#34;,&#34;LASTNAME&#34;:&#34;Knab&#34;}] |
| [{&#34;FIRSTNAME&#34;:&#34;William J.&#34;,&#34;LASTNAME&#34;:&#34;Pardi&#34;}] |
&lt;&lt;/style&gt;&gt;

Note: Prefixing the column name by //json_// is optional but is useful when using the column as argument to Connect UDF functions, making it to be surely recognized as valid Json without aliasing.

This also works on input, a column specified so that it can be directly set to a valid JSON string.

This feature is of great value as we will see below.

== Create, Read, Update and Delete Operations on JSON Tables
The SQL commands INSERT, UPDATE and DELETE are fully supported for JSON tables except those returned by REST queries. For INSERT and UPDATE, if the target values are simple values, there are no problems.

However, there are some issues when the added or modified values are objects or arrays.

Concerning objects, the same problems exist that we have already seen with the XML type. The added or modified object will have the format described in the table definition, which can be different from the one of the JSON file. Modifications should be done using a file specifying the full path of modified objects.

New problems are raised when trying to modify the values of an array. Only updates can be done on the original table. First of all, for the values of the array to be distinct values, all update operations concerning array values must be done using a table expanding this array.

For instance, to modify the authors of the ##biblio.json## based table, the ##jsampex## table must be used. Doing so, updating and deleting authors is possible using standard SQL commands. For example, to change the first name of Knab from François to John:

&lt;&lt;sql&gt;&gt;
update jsampex set authorfn = &#39;John&#39; where authorln = &#39;Knab&#39;;
&lt;&lt;/sql&gt;&gt;

However It would be wrong to do:

&lt;&lt;sql&gt;&gt;
update jsampex set authorfn = &#39;John&#39; where isbn = &#39;9782212090819&#39;;
&lt;&lt;/sql&gt;&gt;

Because this would change the first name of both authors as they share the same ISBN.

Where things become more difficult is when trying to delete or insert an author of a book. Indeed, a delete command will delete the whole book and an insert command will add a new complete row instead of adding a new author in the same array. Here we are penalized by the SQL language that cannot give us a way to specify this. Something like:

&lt;&lt;sql&gt;&gt;
update jsampex add authorfn = &#39;Charles&#39;, authorln = &#39;Dickens&#39;
where title = &#39;XML en Action&#39;;
&lt;&lt;/sql&gt;&gt;

However this does not exist in SQL. Does this mean that it is impossible to do it? No, but it requires us to use a table specified on the same file but adapted to this task. One way to do it is to specify a table for which the authors are no more an expanded array. Supposing we want to add an author to the “XML en Action” book. We will do it on a table containing just the author(s) of that book, which is the second book of the table.

From Connect 1.6:
&lt;&lt;sql&gt;&gt;
create table jauthor (
FIRSTNAME char(64),
LASTNAME char(64))
engine=CONNECT table_type=JSON File_name=&#39;biblio3.json&#39; option_list=&#39;Object=1.AUTHOR&#39;;
&lt;&lt;/sql&gt;&gt;

Until Connect 1.5
&lt;&lt;sql&gt;&gt;
create table jauthor (
FIRSTNAME char(64),
LASTNAME char(64))
engine=CONNECT table_type=JSON File_name=&#39;biblio3.json&#39; option_list=&#39;Object=[1]:AUTHOR&#39;;
&lt;&lt;/sql&gt;&gt;

The command:

&lt;&lt;sql&gt;&gt;
select * from jauthor;
&lt;&lt;/sql&gt;&gt;

replies:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= FIRSTNAME |= LASTNAME |
| William J. | Pardi
&lt;&lt;/style&gt;&gt;

It is a standard JSON table that is an array of objects in which we can freely insert or delete  rows.

&lt;&lt;sql&gt;&gt;
insert into jauthor values(&#39;Charles&#39;,&#39;Dickens&#39;);
&lt;&lt;/sql&gt;&gt;

We can check that this was done correctly by:

&lt;&lt;sql&gt;&gt;
select * from jsampex;
&lt;&lt;/sql&gt;&gt;

This will display:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ISBN |= Title |= AuthorFN |= AuthorLN |= Year
| 9782212090819 | Construire une application XML | Jean-Christophe | Bernadac | 1999
| 9782212090819 | Construire une application XML | John | Knab | 1999
| 9782840825685 | XML en Action | William J. | Pardi | 1999
| 9782840825685 | XML en Action | Charles | Dickens | 1999
&lt;&lt;/style&gt;&gt;

Note: If this table were a big table with many books, it would be difficult to know what the order of a specific book is in the table. This can be found by adding a special ROWID column in the table.

However, an alternate way to do it is by using direct JSON column representation as in the ##JSAMPLE2## table. This can be done by:

&lt;&lt;sql&gt;&gt;
update jsample2 set json_Author =
&#39;[{&#34;FIRSTNAME&#34;:&#34;William J.&#34;,&#34;LASTNAME&#34;:&#34;Pardi&#34;},
  {&#34;FIRSTNAME&#34;:&#34;Charles&#34;,&#34;LASTNAME&#34;:&#34;Dickens&#34;}]&#39;
where isbn = &#39;9782840825685&#39;;
&lt;&lt;/sql&gt;&gt;

Here, we didn&#39;t have to find the index of the sub array to modify. However, this is not quite satisfying because we had to manually write the whole JSON value to set to the json_Author column.

Therefore we need specific functions to do so. They are introduced now.

== JSON User Defined Functions
Although such functions written by other parties do exist,&lt;&lt;ref&gt;&gt;See for instance: [[json-functions]], https://github.com/mysqludf/lib_mysqludf_json#readme and https://blogs.oracle.com/svetasmirnova/entry/json_udf_functions_version_04&lt;&lt;/ref&gt;&gt; CONNECT provides its own UDFs that are specifically adapted to the JSON table type and easily available because, being inside the CONNECT library or DLL, they require no additional module to be loaded (see [[connect-compiling-json-udfs-in-a-separate-library|CONNECT - Compiling JSON UDFs in a Separate Library]] to make these functions in a separate library module). 

In particular, MariaDB 10.2 and 10.3 feature native JSON functions. In some cases, it is possible that these native functions can be used. However, mixing native and UDF JSON functions in the same query often does not work because the way they recognize their arguments is different and might even cause a server crash. 

Here is the list of the CONNECT functions; more can be added if required.

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Name |= Type |= Return |= Description |= Added
| jbin_array | Function | STRING* | Make a JSON array containing its arguments. | MariaDB 10.1.9 |
| jbin_array_add | Function | STRING* | Adds to its first array argument its second arguments. | MariaDB 10.1.9 |
| jbin_array_add_values | Function | STRING* | Adds to its first array argument all following arguments. | |
| jbin_array_delete | Function | STRING* | Deletes the nth element of its first array argument. | MariaDB 10.1.9 |
| jbin_file | Function | STRING* | Returns of a (json) file contain. | MariaDB 10.1.9 |
| jbin_get_item | Function | STRING* | Access and returns a json item by a JPATH key. | MariaDB 10.1.9 |
| jbin_insert_item | Function | STRING | Insert item values located to paths. |  |
| jbin_item_merge | Function | STRING* | Merges two arrays or two objects. | MariaDB 10.1.9 |
| jbin_object | Function | STRING* | Make a JSON object containing its arguments. | MariaDB 10.1.9 |
| jbin_object_nonull | Function | STRING* | Make a JSON object containing its not null arguments. | MariaDB 10.1.9 |
| jbin_object_add | Function | STRING* | Adds to its first object argument its second argument. | MariaDB 10.1.9 |
| jbin_object_delete | Function | STRING* | Deletes the nth element of its first object argument. | MariaDB 10.1.9 |
| jbin_object_key | Function | STRING* | Make a JSON object for key/value pairs. |  |
| jbin_object_list | Function | STRING* | Returns the list of object keys as an array. | MariaDB 10.1.9 |
| jbin_set_item | Function | STRING | Set item values located to paths. | |
| jbin_update_item | Function | STRING | Update item values located to paths. |  |
| jfile_bjson | Function | STRING | Convert a pretty=0 file to another BJson file. | MariaDB 10.5.9, MariaDB 10.4.18, MariaDB 10.3.28, MariaDB 10.2.36 |
| jfile_convert | Function | STRING | Convert a Json file to another pretty=0 file. | MariaDB 10.5.9, MariaDB 10.4.18, MariaDB 10.3.28, MariaDB 10.2.36 |
| jfile_make | Function | STRING | Make a json file from its json item first argument. | MariaDB 10.1.9 |
| json_array | Function | STRING | Make a JSON array containing its arguments. | MariaDB 10.0.17 until Connect 1.5 |
| json_array_add | Function | STRING | Adds to its first array argument its second arguments (before MariaDB 10.1.9, all following arguments). | |
| json_array_add_values | Function | STRING | Adds to its first array argument all following arguments. | MariaDB 10.1.9
| json_array_delete | Function | STRING | Deletes the nth element of its first array argument. | |
| json_array_grp | Aggregate | STRING | Makes JSON arrays from coming argument. | |
| json_file | Function | STRING | Returns the contains of (json) file. | MariaDB 10.1.9 |
| json_get_item | Function | STRING | Access and returns a json item by a JPATH key. | MariaDB 10.1.9 |
| json_insert_item |Function | STRING | Insert item values located to paths. | |
| json_item_merge | Function | STRING | Merges two arrays or two objects. | MariaDB 10.1.9 |
| json_locate_all | Function | STRING | Returns the JPATH’s of all occurrences of an element. | MariaDB 10.1.9 |
| json_make_array | Function | STRING | Make a JSON array containing its arguments. | From Connect 1.6
| json_make_object | Function | STRING | Make a JSON object containing its arguments. | From Connect 1.6
| json_object | Function | STRING | Make a JSON object containing its arguments. | MariaDB 10.0.17 until Connect 1.5
| json_object_delete | Function | STRING | Deletes the nth element of its first object argument. | MariaDB 10.1.9 |
| json_object_grp | Aggregate | STRING | Makes JSON objects from coming arguments. | |
| json_object_list | Function | STRING | Returns the list of object keys as an array. | MariaDB 10.1.9 |
| json_object_nonull | Function | STRING | Make a JSON object containing its not null arguments. | |
| json_serialize | Function | STRING | Serializes the return of a “Jbin” function. | MariaDB 10.1.9 |
| json_set_item | Function | STRING |Set item values located to paths. | |
| json_update_item | Function | STRING | Update item values located to paths. | |
| jsonvalue | Function | STRING | Make a JSON value from its unique argument. Called json_value until MariaDB 10.0.22 and MariaDB 10.1.8. | MariaDB 10.0.17 |
| jsoncontains | Function | INTEGER | Returns 0 or 1 if an element is contained in the document. | |
| jsoncontains_path | Function | INTEGER | Returns 0 or 1 if a JPATH is contained in the document. |  |
| jsonget_string | Function | STRING | Access and returns a string element by a JPATH key. | MariaDB 10.1.9 |
| jsonget_int | Function | INTEGER | Access and returns an integer element by a JPATH key. | MariaDB 10.1.9 |
| jsonget_real | Function | REAL | Access and returns a real element by a JPATH key. | MariaDB 10.1.9 |
| jsonlocate | Function | STRING | Returns the JPATH to access one element. | MariaDB 10.1.9 |
&lt;&lt;/style&gt;&gt;

String values are mapped to JSON strings. These strings are automatically escaped to conform to the JSON syntax. The automatic escaping is bypassed when the value has an alias beginning with ‘json_’. This is automatically the case when a JSON UDF argument is another JSON UDF whose name begins with “json_” (not case sensitive). This is why all functions that do not return a Json item are not prefixed by “json_”.

Argument string values, for some functions, can alternatively be json file names. When this is ambiguous, alias them as //jfile_//. Full path should be used because UDF functions has no means to know what the current database is. Apparently, when the file name path is not full, it is based on the MariaDB data directory but I am not sure it is always true.

Numeric values are (big) integers, double floating point values or decimal values. Decimal values are character strings containing a numeric representation and are treated as strings. Floating point values contain a decimal point and/or an exponent. Integers are written without decimal points.

To install these functions execute the following commands :&lt;&lt;ref&gt;&gt;This will not work when CONNECT is compiled embedded&lt;&lt;/ref&gt;&gt;

&lt;&lt;style class=&#34;bluebox&#34;&gt;&gt;
Note: Json function names are often written on this page with leading upper case letters for clarity. It is possible to do so in SQL queries because function names are case insensitive. However, when creating or dropping them, their names must match the case they are in the library module (lower case from MariaDB 10.1.9).
&lt;&lt;/style&gt;&gt;

On Unix systems (from Connect 1.7.02):
&lt;&lt;sql&gt;&gt;
create function jsonvalue returns string soname &#39;ha_connect.so&#39;;
create function json_make_array returns string soname &#39;ha_connect.so&#39;;
create function json_array_add_values returns string soname &#39;ha_connect.so&#39;;
create function json_array_add returns string soname &#39;ha_connect.so&#39;;
create function json_array_delete returns string soname &#39;ha_connect.so&#39;;
create function json_make_object returns string soname &#39;ha_connect.so&#39;;
create function json_object_nonull returns string soname &#39;ha_connect.so&#39;;
create function json_object_key returns string soname &#39;ha_connect.so&#39;;
create function json_object_add returns string soname &#39;ha_connect.so&#39;;
create function json_object_delete returns string soname &#39;ha_connect.so&#39;;
create function json_object_list returns string soname &#39;ha_connect.so&#39;;
create function json_object_values returns string soname &#39;ha_connect.so&#39;;
create function jsonset_grp_size returns integer soname &#39;ha_connect.so&#39;;
create function jsonget_grp_size returns integer soname &#39;ha_connect.so&#39;;
create aggregate function json_array_grp returns string soname &#39;ha_connect.so&#39;;
create aggregate function json_object_grp returns string soname &#39;ha_connect.so&#39;;
create function jsonlocate returns string soname &#39;ha_connect.so&#39;;
create function json_locate_all returns string soname &#39;ha_connect.so&#39;;
create function jsoncontains returns integer soname &#39;ha_connect.so&#39;;
create function jsoncontains_path returns integer soname &#39;ha_connect.so&#39;;
create function json_item_merge returns string soname &#39;ha_connect.so&#39;;
create function json_get_item returns string soname &#39;ha_connect.so&#39;;
create function jsonget_string returns string soname &#39;ha_connect.so&#39;;
create function jsonget_int returns integer soname &#39;ha_connect.so&#39;;
create function jsonget_real returns real soname &#39;ha_connect.so&#39;;
create function json_set_item returns string soname &#39;ha_connect.so&#39;;
create function json_insert_item returns string soname &#39;ha_connect.so&#39;;
create function json_update_item returns string soname &#39;ha_connect.so&#39;;
create function json_file returns string soname &#39;ha_connect.so&#39;;
create function jfile_make returns string soname &#39;ha_connect.so&#39;;
create function jfile_convert returns string soname &#39;ha_connect.so&#39;;
create function jfile_bjson returns string soname &#39;ha_connect.so&#39;;
create function json_serialize returns string soname &#39;ha_connect.so&#39;;
create function jbin_array returns string soname &#39;ha_connect.so&#39;;
create function jbin_array_add_values returns string soname &#39;ha_connect.so&#39;;
create function jbin_array_add returns string soname &#39;ha_connect.so&#39;;
create function jbin_array_delete returns string soname &#39;ha_connect.so&#39;;
create function jbin_object returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_nonull returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_key returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_add returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_delete returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_list returns string soname &#39;ha_connect.so&#39;;
create function jbin_item_merge returns string soname &#39;ha_connect.so&#39;;
create function jbin_get_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_set_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_insert_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_update_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_file returns string soname &#39;ha_connect.so&#39;;
&lt;&lt;/sql&gt;&gt;

On Unix systems (from Connect 1.6):
&lt;&lt;sql&gt;&gt;
create function jsonvalue returns string soname &#39;ha_connect.so&#39;;
create function json_make_array returns string soname &#39;ha_connect.so&#39;;
create function json_array_add_values returns string soname &#39;ha_connect.so&#39;;
create function json_array_add returns string soname &#39;ha_connect.so&#39;;
create function json_array_delete returns string soname &#39;ha_connect.so&#39;;
create function json_make_object returns string soname &#39;ha_connect.so&#39;;
create function json_object_nonull returns string soname &#39;ha_connect.so&#39;;
create function json_object_key returns string soname &#39;ha_connect.so&#39;;
create function json_object_add returns string soname &#39;ha_connect.so&#39;;
create function json_object_delete returns string soname &#39;ha_connect.so&#39;;
create function json_object_list returns string soname &#39;ha_connect.so&#39;;
create function jsonset_grp_size returns integer soname &#39;ha_connect.so&#39;;
create function jsonget_grp_size returns integer soname &#39;ha_connect.so&#39;;
create aggregate function json_array_grp returns string soname &#39;ha_connect.so&#39;;
create aggregate function json_object_grp returns string soname &#39;ha_connect.so&#39;;
create function jsonlocate returns string soname &#39;ha_connect.so&#39;;
create function json_locate_all returns string soname &#39;ha_connect.so&#39;;
create function jsoncontains returns integer soname &#39;ha_connect.so&#39;;
create function jsoncontains_path returns integer soname &#39;ha_connect.so&#39;;
create function json_item_merge returns string soname &#39;ha_connect.so&#39;;
create function json_get_item returns string soname &#39;ha_connect.so&#39;;
create function jsonget_string returns string soname &#39;ha_connect.so&#39;;
create function jsonget_int returns integer soname &#39;ha_connect.so&#39;;
create function jsonget_real returns real soname &#39;ha_connect.so&#39;;
create function json_set_item returns string soname &#39;ha_connect.so&#39;;
create function json_insert_item returns string soname &#39;ha_connect.so&#39;;
create function json_update_item returns string soname &#39;ha_connect.so&#39;;
create function json_file returns string soname &#39;ha_connect.so&#39;;
create function jfile_make returns string soname &#39;ha_connect.so&#39;;
create function json_serialize returns string soname &#39;ha_connect.so&#39;;
create function jbin_array returns string soname &#39;ha_connect.so&#39;;
create function jbin_array_add_values returns string soname &#39;ha_connect.so&#39;;
create function jbin_array_add returns string soname &#39;ha_connect.so&#39;;
create function jbin_array_delete returns string soname &#39;ha_connect.so&#39;;
create function jbin_object returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_nonull returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_key returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_add returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_delete returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_list returns string soname &#39;ha_connect.so&#39;;
create function jbin_item_merge returns string soname &#39;ha_connect.so&#39;;
create function jbin_get_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_set_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_insert_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_update_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_file returns string soname &#39;ha_connect.so&#39;;
&lt;&lt;/sql&gt;&gt;

On Unix systems (from MariaDB 10.1.9 until Connect 1.5):
&lt;&lt;sql&gt;&gt;
create function jsonvalue returns string soname &#39;ha_connect.so&#39;;
create function json_array returns string soname &#39;ha_connect.so&#39;;
create function json_array_add_values returns string soname &#39;ha_connect.so&#39;;
create function json_array_add returns string soname &#39;ha_connect.so&#39;;
create function json_array_delete returns string soname &#39;ha_connect.so&#39;;
create function json_object returns string soname &#39;ha_connect.so&#39;;
create function json_object_nonull returns string soname &#39;ha_connect.so&#39;;
create function json_object_key returns string soname &#39;ha_connect.so&#39;;
create function json_object_add returns string soname &#39;ha_connect.so&#39;;
create function json_object_delete returns string soname &#39;ha_connect.so&#39;;
create function json_object_list returns string soname &#39;ha_connect.so&#39;;
create function jsonset_grp_size returns integer soname &#39;ha_connect.so&#39;;
create function jsonget_grp_size returns integer soname &#39;ha_connect.so&#39;;
create aggregate function json_array_grp returns string soname &#39;ha_connect.so&#39;;
create aggregate function json_object_grp returns string soname &#39;ha_connect.so&#39;;
create function jsonlocate returns string soname &#39;ha_connect.so&#39;;
create function json_locate_all returns string soname &#39;ha_connect.so&#39;;
create function jsoncontains returns integer soname &#39;ha_connect.so&#39;;
create function jsoncontains_path returns integer soname &#39;ha_connect.so&#39;;
create function json_item_merge returns string soname &#39;ha_connect.so&#39;;
create function json_get_item returns string soname &#39;ha_connect.so&#39;;
create function jsonget_string returns string soname &#39;ha_connect.so&#39;;
create function jsonget_int returns integer soname &#39;ha_connect.so&#39;;
create function jsonget_real returns real soname &#39;ha_connect.so&#39;;
create function json_set_item returns string soname &#39;ha_connect.so&#39;;
create function json_insert_item returns string soname &#39;ha_connect.so&#39;;
create function json_update_item returns string soname &#39;ha_connect.so&#39;;
create function json_file returns string soname &#39;ha_connect.so&#39;;
create function jfile_make returns string soname &#39;ha_connect.so&#39;;
create function json_serialize returns string soname &#39;ha_connect.so&#39;;
create function jbin_array returns string soname &#39;ha_connect.so&#39;;
create function jbin_array_add_values returns string soname &#39;ha_connect.so&#39;;
create function jbin_array_add returns string soname &#39;ha_connect.so&#39;;
create function jbin_array_delete returns string soname &#39;ha_connect.so&#39;;
create function jbin_object returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_nonull returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_key returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_add returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_delete returns string soname &#39;ha_connect.so&#39;;
create function jbin_object_list returns string soname &#39;ha_connect.so&#39;;
create function jbin_item_merge returns string soname &#39;ha_connect.so&#39;;
create function jbin_get_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_set_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_insert_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_update_item returns string soname &#39;ha_connect.so&#39;;
create function jbin_file returns string soname &#39;ha_connect.so&#39;;
&lt;&lt;/sql&gt;&gt;

On WIndows (from Connect 1.7.02):
&lt;&lt;sql&gt;&gt;
create function jsonvalue returns string soname &#39;ha_connect&#39;;
create function json_make_array returns string soname &#39;ha_connect&#39;;
create function json_array_add_values returns string soname &#39;ha_connect&#39;;
create function json_array_add returns string soname &#39;ha_connect&#39;;
create function json_array_delete returns string soname &#39;ha_connect&#39;;
create function json_make_object returns string soname &#39;ha_connect&#39;;
create function json_object_nonull returns string soname &#39;ha_connect&#39;;
create function json_object_key returns string soname &#39;ha_connect&#39;;
create function json_object_add returns string soname &#39;ha_connect&#39;;
create function json_object_delete returns string soname &#39;ha_connect&#39;;
create function json_object_list returns string soname &#39;ha_connect&#39;;
create function json_object_values returns string soname &#39;ha_connect&#39;;
create function jsonset_grp_size returns integer soname &#39;ha_connect&#39;;
create function jsonget_grp_size returns integer soname &#39;ha_connect&#39;;
create aggregate function json_array_grp returns string soname &#39;ha_connect&#39;;
create aggregate function json_object_grp returns string soname &#39;ha_connect&#39;;
create function jsonlocate returns string soname &#39;ha_connect&#39;;
create function json_locate_all returns string soname &#39;ha_connect&#39;;
create function jsoncontains returns integer soname &#39;ha_connect&#39;;
create function jsoncontains_path returns integer soname &#39;ha_connect&#39;;
create function json_item_merge returns string soname &#39;ha_connect&#39;;
create function json_get_item returns string soname &#39;ha_connect&#39;;
create function jsonget_string returns string soname &#39;ha_connect&#39;;
create function jsonget_int returns integer soname &#39;ha_connect&#39;;
create function jsonget_real returns real soname &#39;ha_connect&#39;;
create function json_set_item returns string soname &#39;ha_connect&#39;;
create function json_insert_item returns string soname &#39;ha_connect&#39;;
create function json_update_item returns string soname &#39;ha_connect&#39;;
create function json_file returns string soname &#39;ha_connect&#39;;
create function jfile_make returns string soname &#39;ha_connect&#39;;
create function jfile_convert returns string soname &#39;ha_connect&#39;;
create function jfile_bjson returns string soname &#39;ha_connect&#39;;
create function json_serialize returns string soname &#39;ha_connect&#39;;
create function jbin_array returns string soname &#39;ha_connect&#39;;
create function jbin_array_add_values returns string soname &#39;ha_connect&#39;;
create function jbin_array_add returns string soname &#39;ha_connect&#39;;
create function jbin_array_delete returns string soname &#39;ha_connect&#39;;
create function jbin_object returns string soname &#39;ha_connect&#39;;
create function jbin_object_nonull returns string soname &#39;ha_connect&#39;;
create function jbin_object_key returns string soname &#39;ha_connect&#39;;
create function jbin_object_add returns string soname &#39;ha_connect&#39;;
create function jbin_object_delete returns string soname &#39;ha_connect&#39;;
create function jbin_object_list returns string soname &#39;ha_connect&#39;;
create function jbin_item_merge returns string soname &#39;ha_connect&#39;;
create function jbin_get_item returns string soname &#39;ha_connect&#39;;
create function jbin_set_item returns string soname &#39;ha_connect&#39;;
create function jbin_insert_item returns string soname &#39;ha_connect&#39;;
create function jbin_update_item returns string soname &#39;ha_connect&#39;;
create function jbin_file returns string soname &#39;ha_connect&#39;;
&lt;&lt;/sql&gt;&gt;

On WIndows (from Connect 1.6):
&lt;&lt;sql&gt;&gt;
create function jsonvalue returns string soname &#39;ha_connect&#39;;
create function json_make_array returns string soname &#39;ha_connect&#39;;
create function json_array_add_values returns string soname &#39;ha_connect&#39;;
create function json_array_add returns string soname &#39;ha_connect&#39;;
create function json_array_delete returns string soname &#39;ha_connect&#39;;
create function json_make_object returns string soname &#39;ha_connect&#39;;
create function json_object_nonull returns string soname &#39;ha_connect&#39;;
create function json_object_key returns string soname &#39;ha_connect&#39;;
create function json_object_add returns string soname &#39;ha_connect&#39;;
create function json_object_delete returns string soname &#39;ha_connect&#39;;
create function json_object_list returns string soname &#39;ha_connect&#39;;
create function jsonset_grp_size returns integer soname &#39;ha_connect&#39;;
create function jsonget_grp_size returns integer soname &#39;ha_connect&#39;;
create aggregate function json_array_grp returns string soname &#39;ha_connect&#39;;
create aggregate function json_object_grp returns string soname &#39;ha_connect&#39;;
create function jsonlocate returns string soname &#39;ha_connect&#39;;
create function json_locate_all returns string soname &#39;ha_connect&#39;;
create function jsoncontains returns integer soname &#39;ha_connect&#39;;
create function jsoncontains_path returns integer soname &#39;ha_connect&#39;;
create function json_item_merge returns string soname &#39;ha_connect&#39;;
create function json_get_item returns string soname &#39;ha_connect&#39;;
create function jsonget_string returns string soname &#39;ha_connect&#39;;
create function jsonget_int returns integer soname &#39;ha_connect&#39;;
create function jsonget_real returns real soname &#39;ha_connect&#39;;
create function json_set_item returns string soname &#39;ha_connect&#39;;
create function json_insert_item returns string soname &#39;ha_connect&#39;;
create function json_update_item returns string soname &#39;ha_connect&#39;;
create function json_file returns string soname &#39;ha_connect&#39;;
create function jfile_make returns string soname &#39;ha_connect&#39;;
create function json_serialize returns string soname &#39;ha_connect&#39;;
create function jbin_array returns string soname &#39;ha_connect&#39;;
create function jbin_array_add_values returns string soname &#39;ha_connect&#39;;
create function jbin_array_add returns string soname &#39;ha_connect&#39;;
create function jbin_array_delete returns string soname &#39;ha_connect&#39;;
create function jbin_object returns string soname &#39;ha_connect&#39;;
create function jbin_object_nonull returns string soname &#39;ha_connect&#39;;
create function jbin_object_key returns string soname &#39;ha_connect&#39;;
create function jbin_object_add returns string soname &#39;ha_connect&#39;;
create function jbin_object_delete returns string soname &#39;ha_connect&#39;;
create function jbin_object_list returns string soname &#39;ha_connect&#39;;
create function jbin_item_merge returns string soname &#39;ha_connect&#39;;
create function jbin_get_item returns string soname &#39;ha_connect&#39;;
create function jbin_set_item returns string soname &#39;ha_connect&#39;;
create function jbin_insert_item returns string soname &#39;ha_connect&#39;;
create function jbin_update_item returns string soname &#39;ha_connect&#39;;
create function jbin_file returns string soname &#39;ha_connect&#39;;
&lt;&lt;/sql&gt;&gt;


On WIndows (until Connect 1.5):
&lt;&lt;sql&gt;&gt;
create function jsonvalue returns string soname &#39;ha_connect&#39;;
create function json_array returns string soname &#39;ha_connect&#39;;
create function json_array_add_values returns string soname &#39;ha_connect&#39;;
create function json_array_add returns string soname &#39;ha_connect&#39;;
create function json_array_delete returns string soname &#39;ha_connect&#39;;
create function json_object returns string soname &#39;ha_connect&#39;;
create function json_object_nonull returns string soname &#39;ha_connect&#39;;
create function json_object_key returns string soname &#39;ha_connect&#39;;
create function json_object_add returns string soname &#39;ha_connect&#39;;
create function json_object_delete returns string soname &#39;ha_connect&#39;;
create function json_object_list returns string soname &#39;ha_connect&#39;;
create function jsonset_grp_size returns integer soname &#39;ha_connect&#39;;
create function jsonget_grp_size returns integer soname &#39;ha_connect&#39;;
create aggregate function json_array_grp returns string soname &#39;ha_connect&#39;;
create aggregate function json_object_grp returns string soname &#39;ha_connect&#39;;
create function jsonlocate returns string soname &#39;ha_connect&#39;;
create function json_locate_all returns string soname &#39;ha_connect&#39;;
create function jsoncontains returns integer soname &#39;ha_connect&#39;;
create function jsoncontains_path returns integer soname &#39;ha_connect&#39;;
create function json_item_merge returns string soname &#39;ha_connect&#39;;
create function json_get_item returns string soname &#39;ha_connect&#39;;
create function jsonget_string returns string soname &#39;ha_connect&#39;;
create function jsonget_int returns integer soname &#39;ha_connect&#39;;
create function jsonget_real returns real soname &#39;ha_connect&#39;;
create function json_set_item returns string soname &#39;ha_connect&#39;;
create function json_insert_item returns string soname &#39;ha_connect&#39;;
create function json_update_item returns string soname &#39;ha_connect&#39;;
create function json_file returns string soname &#39;ha_connect&#39;;
create function jfile_make returns string soname &#39;ha_connect&#39;;
create function json_serialize returns string soname &#39;ha_connect&#39;;
create function jbin_array returns string soname &#39;ha_connect&#39;;
create function jbin_array_add_values returns string soname &#39;ha_connect&#39;;
create function jbin_array_add returns string soname &#39;ha_connect&#39;;
create function jbin_array_delete returns string soname &#39;ha_connect&#39;;
create function jbin_object returns string soname &#39;ha_connect&#39;;
create function jbin_object_nonull returns string soname &#39;ha_connect&#39;;
create function jbin_object_key returns string soname &#39;ha_connect&#39;;
create function jbin_object_add returns string soname &#39;ha_connect&#39;;
create function jbin_object_delete returns string soname &#39;ha_connect&#39;;
create function jbin_object_list returns string soname &#39;ha_connect&#39;;
create function jbin_item_merge returns string soname &#39;ha_connect&#39;;
create function jbin_get_item returns string soname &#39;ha_connect&#39;;
create function jbin_set_item returns string soname &#39;ha_connect&#39;;
create function jbin_insert_item returns string soname &#39;ha_connect&#39;;
create function jbin_update_item returns string soname &#39;ha_connect&#39;;
create function jbin_file returns string soname &#39;ha_connect&#39;;
&lt;&lt;/sql&gt;&gt;

=== Jfile_Bjson
&lt;&lt;product mariadb from=10.2.36&gt;&gt;
JFile_Bjson was introduced in MariaDB 10.5.9, MariaDB 10.4.18, MariaDB 10.3.28 and MariaDB 10.2.36.
&lt;&lt;/product&gt;&gt;
&lt;&lt;code&gt;&gt;
Jfile_Bjson(in_file_name, out_file_name, lrecl)
&lt;&lt;/code&gt;&gt;
Converts the first argument pretty=0 json file to Bjson file. B(inary)json is a pre-parsed json format. It is described below in the Performance chapter (available in next Connect versions).

=== Jfile_Convert
&lt;&lt;product mariadb from=10.2.36&gt;&gt;
JFile_Convert was introduced in MariaDB 10.5.9, MariaDB 10.4.18, MariaDB 10.3.28 and MariaDB 10.2.36.
&lt;&lt;/product&gt;&gt;

&lt;&lt;code&gt;&gt;
Jfile_Convert(in_file_name, out_file_name, lrecl)
&lt;&lt;/code&gt;&gt;
Converts the first argument json file to another //pretty=0// json file. The third integer argument is the record length to use. This is often required to process huge json files that would be very slow if they were in //pretty=2// format.

This is done without completely parsing the file, is very fast and requires no big memory.

=== Jfile_Make
&lt;&lt;product mariadb from=10.1.9&gt;&gt;
Jfile_Make was added in CONNECT 1.4 (from MariaDB 10.1.9).
&lt;&lt;/product&gt;&gt;

&lt;&lt;code&gt;&gt;
Jfile_Make(arg1, arg2, [arg3], …)
&lt;&lt;/code&gt;&gt;

The first argument must be a json item (if it is just a string, Jfile_Make will try its best to see if it is a json item or an input file name). The following arguments are a string file name and an integer pretty value (defaulting to 2) in any order. This function creates a json file containing the first argument item.

The returned string value is the created file name. If not specified as an argument, the file name can in some cases be retrieved from the first argument; in such cases the file itself is modified. 

This function can be used to create or format a json file. For instance, supposing we want to format the file tb.json, this can be done with the query:

&lt;&lt;sql&gt;&gt;
select Jfile_Make(&#39;tb.json&#39; jfile_, 2);
&lt;&lt;/sql&gt;&gt;

The tb.json file will be changed to:

&lt;&lt;code&gt;&gt;
[
  {
    &#34;_id&#34;: 5,
    &#34;type&#34;: &#34;food&#34;,
    &#34;ratings&#34;: [
      5,
      8,
      9
    ]
  },
  {
    &#34;_id&#34;: 6,
    &#34;type&#34;: &#34;car&#34;,
    &#34;ratings&#34;: [
      5,
      9
    ]
  }
]
&lt;&lt;/code&gt;&gt;

=== Json_Array_Add
&lt;&lt;code&gt;&gt;
Json_Array_Add(arg1, arg2, [arg3][, arg4][, ...])
&lt;&lt;/code&gt;&gt;

Note: In CONNECT version 1.3 (before MariaDB 10.1.9), this function behaved like the new ##Json_Array_Add_Values## function. The following describes this function for CONNECT version 1.4 (from MariaDB 10.1.9) only.
The first argument must be a JSON array. The second argument is added as member of this array. For example:

&lt;&lt;sql&gt;&gt;
select Json_Array_Add(Json_Array(56,3.1416,&#39;machin&#39;,NULL),
&#39;One more&#39;) Array;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Array
| [56,3.141600,&#34;machin&#34;,null,&#34;One more&#34;]
&lt;&lt;/style&gt;&gt;

Note: The first array is not escaped, its (alias) name beginning with ‘json_’.

Now we can see how adding an author to the JSAMPLE2 table can alternatively be done:

&lt;&lt;sql&gt;&gt;
update jsample2 set 
  json_author = json_array_add(json_author, json_object(&#39;Charles&#39; FIRSTNAME, &#39;Dickens&#39; LASTNAME)) 
  where isbn = &#39;9782840825685&#39;;
&lt;&lt;/sql&gt;&gt;

Note: Calling a column returning JSON a name prefixed by json_ (like json_author here) is good practice and removes the need to give it an alias to prevent escaping when used as an argument.

Additional arguments:
If a third integer argument is given, it specifies the position (zero based) of the added value:

&lt;&lt;sql&gt;&gt;
select Json_Array_Add(&#39;[5,3,8,7,9]&#39; json_, 4, 2) Array;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Array
| [5,3,4,8,7,9]
&lt;&lt;/style&gt;&gt;

If a string argument is added, it specifies the Json path to the array to be modified. For instance:

&lt;&lt;sql&gt;&gt;
select Json_Array_Add(&#39;{&#34;a&#34;:1,&#34;b&#34;:2,&#34;c&#34;:[3,4]}&#39; json_, 5, 1, &#39;c&#39;);
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Array_Add(&#39;{&#34;a&#34;:1,&#34;b&#34;:2,&#34;c&#34;:[3, 4]}&#39; json_, 5, 1, &#39;c&#39;)
| {&#34;a&#34;:1,&#34;b&#34;:2,&#34;c&#34;:[3,5,4]}
&lt;&lt;/style&gt;&gt;

=== Json_Array_Add_Values
Json_Array_Add_Values added in CONNECT 1.4 replaces the function Json_Array_Add of CONNECT version 1.3 (before MariaDB 10.1.9).

&lt;&lt;code&gt;&gt;
Json_Array_Add_Values(arg, arglist)
&lt;&lt;/code&gt;&gt;

The first argument must be a JSON array string. Then all other arguments are added as members of this array. For example:

&lt;&lt;sql&gt;&gt;
select Json_Array_Add_Values
  (Json_Array(56, 3.1416, &#39;machin&#39;, NULL), &#39;One more&#39;, &#39;Two more&#39;) Array;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Array
| [56,3.141600,&#34;machin&#34;,null,&#34;One more&#34;,&#34;Two more&#34;]
&lt;&lt;/style&gt;&gt;

=== Json_Array_Delete

&lt;&lt;code&gt;&gt;
Json_Array_Delete(arg1, arg2 [,arg3] [...])
&lt;&lt;/code&gt;&gt;

The first argument should be a JSON array. The second argument is an integer indicating the rank (0 based conforming to general json usage) of the element to delete. For example:

&lt;&lt;sql&gt;&gt;
select Json_Array_Delete(Json_Array(56,3.1416,&#39;foo&#39;,NULL),1) Array;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Array |
| [56,&#34;foo&#34;,null] |
&lt;&lt;/style&gt;&gt;

Now we can see how to delete the second author from the JSAMPLE2 table:

&lt;&lt;sql&gt;&gt;
update jsample2 set json_author = json_array_delete(json_author, 1) 
  where isbn = &#39;9782840825685&#39;;
&lt;&lt;/sql&gt;&gt;

A Json path can be specified as a third string argument 

=== Json_Array_Grp
&lt;&lt;code&gt;&gt;
Json_Array_Grp(arg)
&lt;&lt;/code&gt;&gt;

This is an aggregate function that makes an array filled from values coming from the rows retrieved by a query. Let us suppose we have the pet table:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= name |= race |= number
| John | dog | 2
| Bill | cat | 1
| Mary | dog | 1
| Mary | cat | 1
| Lisbeth | rabbit | 2
| Kevin | cat | 2
| Kevin | bird | 6
| Donald | dog | 1
| Donald | fish | 3
&lt;&lt;/style&gt;&gt;

The query:

&lt;&lt;sql&gt;&gt;
select name, json_array_grp(race) from pet group by name;
&lt;&lt;/sql&gt;&gt;

will return:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= name | json_array_grp(race)
| Bill | [&#34;cat&#34;]
| Donald | [&#34;dog&#34;,&#34;fish&#34;]
| John | [&#34;dog&#34;]
| Kevin | [&#34;cat&#34;,&#34;bird&#34;]
| Lisbeth | [&#34;rabbit&#34;]
| Mary | [&#34;dog&#34;,&#34;cat&#34;]
&lt;&lt;/style&gt;&gt;

One problem with the JSON aggregate functions is that they construct their result in memory and cannot know the needed amount of storage, not knowing the number of rows of the used table.

Therefore, the number of values for each group is limited. This limit is the value of JsonGrpSize whose default value is 10 but can be set using the JsonSet_Grp_Size function. Nevertheless, working on a larger table is possible, but only after setting JsonGrpSize to the ceiling of the number of rows per group for the table. Try not to set it to a very large value to avoid memory exhaustion.

=== JsonContains
&lt;&lt;code&gt;&gt;
JsonContains(json_doc, item [, int])&lt;
&lt;&lt;/code&gt;&gt;
This function can be used to check whether an item is contained in a document. Its arguments are the same than the ones of the JsonLocate function; only the return value changes. The integer returned value is 1 is the item is contained in the document or 0 otherwise.

=== JsonContains_Path
&lt;&lt;code&gt;&gt;
JsonContains_Path(json_doc, path)
&lt;&lt;/code&gt;&gt;
This function can be used to check whether a Json path is contained in the document. The integer returned value is 1 is the path is contained in the document or 0 otherwise.

=== Json_File

&lt;&lt;code&gt;&gt;
Json_File(arg1, [arg2, [arg3]], …)
&lt;&lt;/code&gt;&gt;
The first argument must be a file name. This function returns the text of the file that is supposed to be a json file. If only one argument is specified, the file text is returned without being parsed. Up to two additional arguments can be specified:

A string argument is the path to the sub-item to be returned. An integer argument specifies the pretty format value of the file.

This function is chiefly used to get the json item argument of other json functions from a json file. For instance, supposing the file tb.json is:

&lt;&lt;code&gt;&gt;
{ &#34;_id&#34; : 5, &#34;type&#34; : &#34;food&#34;, &#34;ratings&#34; : [ 5, 8, 9 ] }
{ &#34;_id&#34; : 6, &#34;type&#34; : &#34;car&#34;, &#34;ratings&#34; : [ 5, 9 ] }
&lt;&lt;/code&gt;&gt;

Extracting a value from it can be done with a query such as:

&lt;&lt;sql&gt;&gt;
select JsonGet_String(Json_File(&#39;tb.json&#39;, 0), &#39;[1]:type&#39;) &#34;Type&#34;;
&lt;&lt;/sql&gt;&gt;
or, from MariaDB 10.2.8:
&lt;&lt;sql&gt;&gt;
select JsonGet_String(Json_File(&#39;tb.json&#39;, 0), &#39;$[1].type&#39;) &#34;Type&#34;;
&lt;&lt;/sql&gt;&gt;

This query returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Type
| car
&lt;&lt;/style&gt;&gt;

However, we’ll see that, most of the time, it is better to use Jbin_File or to directly specify the file name in queries. In particular this function should not be used for queries that must modify the json item because, even if the modified json is returned, the file itself would be unchanged.

=== Json_Get_Item
&lt;&lt;product mariadb from=10.1.9&gt;&gt;
Json_Get_Item was added in CONNECT 1.4 (from MariaDB 10.1.9).
&lt;&lt;/product&gt;&gt;

&lt;&lt;code&gt;&gt;
Json_Get_Item(arg1, arg2, …)
&lt;&lt;/code&gt;&gt;

This function returns a subset of the json document passed as first argument. The second argument is the json path of the item to be returned and should be one returning a json item (terminated by a ‘*’). If not, the function will try to make it right but this is not foolproof. For instance:

&lt;&lt;sql&gt;&gt;
select Json_Get_Item(Json_Object(&#39;foo&#39; as &#34;first&#34;, Json_Array(&#39;a&#39;, 33) 
  as &#34;json_second&#34;), &#39;second&#39;) as &#34;item&#34;;
&lt;&lt;/sql&gt;&gt;

The correct path should have been ‘second:*’ (or from MariaDB 10.2.8, ‘second.*’), but in this simple case the function was able to make it right. The returned item:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= item
| [&#34;a&#34;,33] 
&lt;&lt;/style&gt;&gt;

Note: The array is aliased “json_second” to indicate it is a json item and avoid escaping it. However, the “json_” prefix is skipped when making the object and must not be added to the path.

===  JsonGet_Grp_Size
&lt;&lt;code&gt;&gt;
JsonGet_Grp_Size(val)
&lt;&lt;/code&gt;&gt;
This function returns the JsonGrpSize value.


=== JsonGet_String / JsonGet_Int / JsonGet_Real
&lt;&lt;product mariadb from=10.1.9&gt;&gt;
JsonGet_String, JsonGet_Int and JsonGet_Real were added in CONNECT 1.4 (from MariaDB 10.1.9).
&lt;&lt;/product&gt;&gt;

&lt;&lt;code&gt;&gt;
JsonGet_String(arg1, arg2, [arg3] …)
JsonGet_Int(arg1, arg2, [arg3] …)
JsonGet_Real(arg1, arg2, [arg3] …)
&lt;&lt;/code&gt;&gt;
The first argument should be a JSON item. If it is a string with no alias, it will be converted as a json item. The second argument is the path of the item to be located in the first argument and returned, eventually converted according to the used function.  For example:

&lt;&lt;sql&gt;&gt;
select 
JsonGet_String(&#39;{&#34;qty&#34;:7,&#34;price&#34;:29.50,&#34;garanty&#34;:null}&#39;,&#39;price&#39;) &#34;String&#34;,
JsonGet_Int(&#39;{&#34;qty&#34;:7,&#34;price&#34;:29.50,&#34;garanty&#34;:null}&#39;,&#39;price&#39;) &#34;Int&#34;,
JsonGet_Real(&#39;{&#34;qty&#34;:7,&#34;price&#34;:29.50,&#34;garanty&#34;:null}&#39;,&#39;price&#39;) &#34;Real&#34;;
&lt;&lt;/sql&gt;&gt;

This query returns:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= String |= Int |= Real
| 29.50 | 29 | 29.500000000000000
&lt;&lt;/style&gt;&gt;

The function //JsonGet_Real// can be given a third argument to specify the number of decimal digits of the returned value. For instance:

&lt;&lt;sql&gt;&gt;
select 
JsonGet_Real(&#39;{&#34;qty&#34;:7,&#34;price&#34;:29.50,&#34;garanty&#34;:null}&#39;,&#39;price&#39;,4) &#34;Real&#34;;
&lt;&lt;/sql&gt;&gt;

This query returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= String
| 29.50
&lt;&lt;/style&gt;&gt;

The given path can specify all operators for arrays except the “expand” [X] operator (or from MariaDB 10.2.8, the“expand” [*] operator). For instance:

&lt;&lt;sql&gt;&gt;
select 
JsonGet_Int(Json_Array(45,28,36,45,89), &#39;[4]&#39;) &#34;Rank&#34;,
JsonGet_Int(Json_Array(45,28,36,45,89), &#39;[#]&#39;) &#34;Number&#34;,
JsonGet_String(Json_Array(45,28,36,45,89), &#39;[&#34;,&#34;]&#39;) &#34;Concat&#34;,
JsonGet_Int(Json_Array(45,28,36,45,89), &#39;[+]&#39;) &#34;Sum&#34;,
JsonGet_Real(Json_Array(45,28,36,45,89), &#39;[!]&#39;, 2) &#34;Avg&#34;;
&lt;&lt;/sql&gt;&gt;

The result:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Rank |= Number |= Concat |= Sum |= Avg
| 89 | 5 | 45,28,36,45,89 | 243 | 48.60
&lt;&lt;/style&gt;&gt;

=== Json_Item_Merge

&lt;&lt;code&gt;&gt;
Json_Item_Merge(arg1, arg2, …)
&lt;&lt;/code&gt;&gt;

This function merges two arrays or two objects. For arrays, this is done by adding to the first array all the values of the second array. For instance:

&lt;&lt;sql&gt;&gt;
select Json_Item_Merge(Json_Array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), Json_Array(&#39;d&#39;,&#39;e&#39;,&#39;f&#39;)) as &#34;Result&#34;; 
&lt;&lt;/sql&gt;&gt;

The function returns:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Result
| [&#34;a&#34;,&#34;b&#34;,&#34;c&#34;,&#34;d&#34;,&#34;e&#34;,&#34;f&#34;]
&lt;&lt;/style&gt;&gt;

For objects, the pairs of the second object are added to the first object if the key does not yet exist in it; otherwise the pair of the first object is set with the value of the matching pair of the second object. For instance:

&lt;&lt;sql&gt;&gt;
select Json_Item_Merge(Json_Object(1 &#34;a&#34;, 2 &#34;b&#34;, 3 &#34;c&#34;), Json_Object(4 &#34;d&#34;,5 &#34;b&#34;,6 &#34;f&#34;)) 
  as &#34;Result&#34;; 
&lt;&lt;/sql&gt;&gt;

The function returns:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Result
| {&#34;a&#34;:1,&#34;b&#34;:5,&#34;c&#34;:3,&#34;d&#34;:4,&#34;f&#34;:6}
&lt;&lt;/style&gt;&gt;

=== JsonLocate

&lt;&lt;code&gt;&gt;
JsonLocate(arg1, arg2, [arg3], …):
&lt;&lt;/code&gt;&gt;

The first argument must be a JSON tree. The second argument is the item to be located. The item to be located can be a constant or a json item. Constant values must be equal in type and value to be found. This is &#34;shallow equality&#34; – strings, integers and doubles won&#39;t match. 

This function returns the json path to the located item or null if it is not found. For example:

&lt;&lt;sql&gt;&gt;
select JsonLocate(&#39;{&#34;AUTHORS&#34;:[{&#34;FN&#34;:&#34;Jules&#34;, &#34;LN&#34;:&#34;Verne&#34;}, 
  {&#34;FN&#34;:&#34;Jack&#34;, &#34;LN&#34;:&#34;London&#34;}]}&#39; json_, &#39;Jack&#39;) Path;
&lt;&lt;/sql&gt;&gt;

This query returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Path
| AUTHORS:[1]:FN
&lt;&lt;/style&gt;&gt;
or, from MariaDB 10.2.8:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Path
| $.AUTHORS[1].FN |
&lt;&lt;/style&gt;&gt;

The path syntax is the same used in JSON CONNECT tables.

By default, the path of the first occurrence of the item is returned. The third parameter can be used to specify the occurrence whose path is to be returned. For instance:

&lt;&lt;sql&gt;&gt;
select 
JsonLocate(&#39;[45,28,[36,45],89]&#39;,45) first,
JsonLocate(&#39;[45,28,[36,45],89]&#39;,45,2) second,
JsonLocate(&#39;[45,28,[36,45],89]&#39;,45.0) `wrong type`,
JsonLocate(&#39;[45,28,[36,45],89]&#39;,&#39;[36,45]&#39; json_) json;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= first |= second |=wrong type |=json
| [0] | [2]:[1] | &lt;null&gt; | [2]
&lt;&lt;/style&gt;&gt;
or, from MariaDB 10.2.8:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= first |= second |=wrong type |=json
| $[0] | $[2][1] | &lt;null&gt; | $[2]
&lt;&lt;/style&gt;&gt;

For string items, the comparison is case sensitive by default. However, it is possible to specify a string to be compared case insensitively by giving it an alias beginning by “ci”:

&lt;&lt;sql&gt;&gt;
select JsonLocate(&#39;{&#34;AUTHORS&#34;:[{&#34;FN&#34;:&#34;Jules&#34;, &#34;LN&#34;:&#34;Verne&#34;}, 
  {&#34;FN&#34;:&#34;Jack&#34;, &#34;LN&#34;:&#34;London&#34;}]}&#39; json_, &#39;VERNE&#39; ci) Path;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Path
| AUTHORS:[0]:LN
&lt;&lt;/style&gt;&gt;
or, from MariaDB 10.2.8:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Path
| $.AUTHORS[0].LN
&lt;&lt;/style&gt;&gt;

=== Json_Locate_All

&lt;&lt;code&gt;&gt;
Json_Locate_All(arg1, arg2, [arg3], …):
&lt;&lt;/code&gt;&gt;

The first argument must be a JSON item. The second argument is the item to be located. This function returns the paths to all locations of the item as an array of strings. For example:

&lt;&lt;sql&gt;&gt;
select Json_Locate_All(&#39;[[45,28],[[36,45],89]]&#39;,45);
&lt;&lt;/sql&gt;&gt;

This query returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= All paths
| [&#34;[0]:[0]&#34;,&#34;[1]:[0]:[1]&#34;]
&lt;&lt;/style&gt;&gt;
or, from MariaDB 10.2.8:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= All paths
[&#34;$[0][0]&#34;,&#34;$[1][0][1]&#34;]
&lt;&lt;/style&gt;&gt;
The returned array can be applied other functions. For instance, to get the number of occurrences of an item in a json tree, you can do:

&lt;&lt;sql&gt;&gt;
select JsonGet_Int(Json_Locate_All(&#39;[[45,28],[[36,45],89]]&#39;,45), &#39;[#]&#39;) &#34;Nb of occurs&#34;;
&lt;&lt;/sql&gt;&gt;
or, from MariaDB 10.2.8:
&lt;&lt;sql&gt;&gt;
select JsonGet_Int(Json_Locate_All(&#39;[[45,28],[[36,45],89]]&#39;,45), &#39;$[#]&#39;) &#34;Nb of occurs&#34;;
&lt;&lt;/sql&gt;&gt;

The displayed result:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Nb of occurs
| 2
&lt;&lt;/style&gt;&gt;

If specified, the third integer argument set the depth to search in the document. This means the maximum items in the paths (until MariaDB 10.2.7, the number of ‘:’ separator characters in them plus one). This value defaults to 10 but can be increased for complex documents or reduced to set the maximum wanted depth of the returned paths.

=== Json_Make_Array
&lt;&lt;code&gt;&gt;
Json_Make_Array(val1, …, valn)
&lt;&lt;/code&gt;&gt;

This function was named “Json_Array” in previous versions of CONNECT. It was renamed because MariaDB 10.2 features native JSON functions including a [[json_array|Json_Array]] function. The native function does almost the same as the UDF one, but does not accept CONNECT-specific arguments such as the result from JBIN functions.

Json_Make_Array returns a string denoting a JSON array with all its arguments as members. For example:

&lt;&lt;sql&gt;&gt;
select Json_Make_Array(56, 3.1416, &#39;My name is &#34;Foo&#34;&#39;, NULL);
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Make_Array(56, 3.1416, &#39;My name is &#34;Foo&#34;&#39;,N ULL)
| [56,3.141600,&#34;My name is \&#34;Foo\&#34;&#34;,null]
&lt;&lt;/style&gt;&gt;

Note: The argument list can be void. If so, a void array is returned.

This function was named “Json_Array” in previous versions of CONNECT. It was renamed because MariaDB 10.2 features native JSON functions including a “Json_Array” function. The native function does almost the same as the UDF one but does not accept CONNECT specific arguments such as the result from JBIN functions.

=== Json_Make_Object
&lt;&lt;code&gt;&gt;
Json_Make_Object(arg1, …, argn)
&lt;&lt;/code&gt;&gt;

This function was named “Json_Object” in previous versions of CONNECT. It was renamed because MariaDB 10.2 features native JSON functions including a [[json_object|Json_Object]] function. The native function does what the UDF Json_Object_Key does. 

Json_Make_Object returns a string denoting a JSON object. For instance:

&lt;&lt;sql&gt;&gt;
select Json_Make_Object(56, 3.1416, &#39;machin&#39;, NULL);
&lt;&lt;/sql&gt;&gt;

The object is filled with pairs corresponding to the given arguments. The key of each pair is made from the argument (default or specified) alias. 

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Make_Object(56, 3.1416, &#39;machin&#39;, NULL)
| {&#34;56&#34;:56,&#34;3.1416&#34;:3.141600,&#34;machin&#34;:&#34;machin&#34;,&#34;NULL&#34;:null}
&lt;&lt;/style&gt;&gt;

When needed, it is possible to specify the keys by giving an alias to the arguments:

&lt;&lt;sql&gt;&gt;
select Json_Make_Object(56 qty, 3.1416 price, &#39;machin&#39; truc, NULL garanty);
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Make_Object(56 qty,3.1416 price,&#39;machin&#39; truc, NULL garanty)
| {&#34;qty&#34;:56,&#34;price&#34;:3.141600,&#34;truc&#34;:&#34;machin&#34;,&#34;garanty&#34;:null}
&lt;&lt;/style&gt;&gt;

If the alias is prefixed by ‘json_’ (to prevent escaping) the key name is stripped from that prefix.

This function is chiefly useful when entering values retrieved from a table, the key being by default the column name:

&lt;&lt;sql&gt;&gt;
select Json_Make_Object(matricule, nom, titre, salaire) from connect.employe where nom = &#39;PANTIER&#39;;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Make_Object(matricule, nom, titre, salaire)
| {&#34;matricule&#34;:40567,&#34;nom&#34;:&#34;PANTIER&#34;,&#34;titre&#34;:&#34;DIRECTEUR&#34;,&#34;salaire&#34;:14000.000000}
&lt;&lt;/style&gt;&gt;

This function was named “Json_Object” in previous versions of CONNECT. It was renamed because MariaDB 10.2 features native JSON functions including a “Json_Object” function. The native function does what the UDF Json_Object_Key does. 

=== Json_Object_Add

&lt;&lt;code&gt;&gt;
Json_Object_Add(arg1, arg2, [arg3] …)
&lt;&lt;/code&gt;&gt;

The first argument must be a JSON object. The second argument is added as a pair to this object. For example:

&lt;&lt;sql&gt;&gt;
select Json_Object_Add
  (&#39;{&#34;item&#34;:&#34;T-shirt&#34;,&#34;qty&#34;:27,&#34;price&#34;:24.99}&#39; json_old,&#39;blue&#39; color) newobj;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= newobj
| {&#34;item&#34;:&#34;T-shirt&#34;,&#34;qty&#34;:27,&#34;price&#34;:24.990000,&#34;color&#34;:&#34;blue&#34;}
&lt;&lt;/style&gt;&gt;

Note: If the specified key already exists in the object, its value is replaced by the new one.

The third string argument is a Json path to the target object.

=== Json_Object_Delete

&lt;&lt;code&gt;&gt;
Json_Object_Delete(arg1, arg2, [arg3] …):
&lt;&lt;/code&gt;&gt;

The first argument must be a JSON object. The second argument is the key of the pair to delete. For example:

&lt;&lt;sql&gt;&gt;
select Json_Object_Delete(&#39;{&#34;item&#34;:&#34;T-shirt&#34;,&#34;qty&#34;:27,&#34;price&#34;:24.99}&#39; json_old, &#39;qty&#39;) newobj;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= newobj
| {&#34;item&#34;:&#34;T-shirt&#34;,&#34;price&#34;:24.99}
&lt;&lt;/style&gt;&gt;

The third string argument is a Json path to the object to be the target of deletion.

=== Json_Object_Grp
&lt;&lt;code&gt;&gt;
Json_Object_Grp(arg1,arg2)
&lt;&lt;/code&gt;&gt;
This function works like Json_Array_Grp. It makes a JSON object filled with value pairs whose keys are passed from its first argument and values are passed from its second argument.

This can be seen with the query:

&lt;&lt;sql&gt;&gt;
select name, json_object_grp(number,race) from pet group by name;
&lt;&lt;/sql&gt;&gt;

This query returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= name |= json_object_grp(number,race)
| Bill | {&#34;cat&#34;:1}
| Donald | {&#34;dog&#34;:1,&#34;fish&#34;:3}
| John | {&#34;dog&#34;:2} 
| Kevin | {&#34;cat&#34;:2,&#34;bird&#34;:6}
| Lisbeth | {&#34;rabbit&#34;:2}
| Mary | {&#34;dog&#34;:1,&#34;cat&#34;:1}
&lt;&lt;/style&gt;&gt;

===  Json_Object_Key

&lt;&lt;code&gt;&gt;
Json_Object_Key([key1, val1 [, …, keyn, valn]])
&lt;&lt;/code&gt;&gt;
Return a string denoting a JSON object. For instance:

&lt;&lt;sql&gt;&gt;
select Json_Object_Key(&#39;qty&#39;, 56, &#39;price&#39;, 3.1416, &#39;truc&#39;, &#39;machin&#39;, &#39;garanty&#39;, NULL);
&lt;&lt;/sql&gt;&gt;
The object is filled with pairs made from each key/value arguments.

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Object_Key(&#39;qty&#39;, 56, &#39;price&#39;, 3.1416, &#39;truc&#39;, &#39;machin&#39;, &#39;garanty&#39;, NULL) |
| {&#34;qty&#34;:56,&#34;price&#34;:3.141600,&#34;truc&#34;:&#34;machin&#34;,&#34;garanty&#34;:null} |
&lt;&lt;/style&gt;&gt;

=== Json_Object_List

&lt;&lt;code&gt;&gt;
Json_Object_List(arg1, …):
&lt;&lt;/code&gt;&gt;

The first argument must be a JSON object. This function returns an array containing the list of all keys existing in the object. For example:

&lt;&lt;sql&gt;&gt;
select Json_Object_List(Json_Object(56 qty,3.1416 price,&#39;machin&#39; truc, NULL garanty))
  &#34;Key List&#34;;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Key List
| [&#34;qty&#34;,&#34;price&#34;,&#34;truc&#34;,&#34;garanty&#34;]
&lt;&lt;/style&gt;&gt;

=== Json_Object_Nonull

&lt;&lt;code&gt;&gt;
Json_Object_Nonull(arg1, …, argn)
&lt;&lt;/code&gt;&gt;

This function works like [[#json_make_object|Json_Make_Object]] but “null” arguments are ignored and not inserted in the object.
Arguments are regarded as “null” if they are JSON null values, void arrays or objects, or arrays or objects containing only null members.

It is mainly used to avoid constructing useless null items when converting tables (see later).

=== Json_Object_Values

&lt;&lt;code&gt;&gt;
Json_Object_Values(json_object)
&lt;&lt;/code&gt;&gt;

The first argument must be a JSON object. This function returns an array containing the list of all values existing in the object. For example:

&lt;&lt;code&gt;&gt;
select Json_Object_Values(&#39;{&#34;One&#34;:1,&#34;Two&#34;:2,&#34;Three&#34;:3}&#39;) &#34;Value List&#34;;
&lt;&lt;/code&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Value List
| [1,2,3]
&lt;&lt;/style&gt;&gt;

=== JsonSet_Grp_Size
&lt;&lt;code&gt;&gt;
JsonSet_Grp_Size(val)
&lt;&lt;/code&gt;&gt;
This function is used to set the JsonGrpSize value. This value is used by the following aggregate functions as a ceiling value of the number of items in each group. It returns the JsonGrpSize value that can be its default value when passed 0 as argument. 

=== Json_Set_Item / Json_Insert_Item / Json_Update_Item
&lt;&lt;code&gt;&gt;
Json_{Set | Insert | Update}_Item(json_doc, [item, path [, val, path …]])
&lt;&lt;/code&gt;&gt;
These functions insert or update data in a JSON document and return the result. The value/path pairs are evaluated left to right. The document produced by evaluating one pair becomes the new value against which the next pair is evaluated.

*Json_Set_Item	replaces existing values and adds non-existing values. 
*Json_Insert_Item	inserts values without replacing existing values. 
*Json_Update_Item	replaces only existing values.

Example:
&lt;&lt;code&gt;&gt;
set @j = Json_Array(1, 2, 3, Json_Object_Key(&#39;quatre&#39;, 4));
select Json_Set_Item(@j, &#39;foo&#39;, &#39;[1]&#39;, 5, &#39;[3]:cinq&#39;) as &#34;Set&#34;,
Json_Insert_Item(@j, &#39;foo&#39;, &#39;[1]&#39;, 5, &#39;[3]:cinq&#39;) as &#34;Insert&#34;,
Json_Update_Item(@j, &#39;foo&#39;, &#39;[1]&#39;, 5, &#39;[3]:cinq&#39;) as &#34;Update&#34;;
&lt;&lt;/code&gt;&gt;
or, from MariaDB 10.2.8:
&lt;&lt;code&gt;&gt;
set @j = Json_Array(1, 2, 3, Json_Object_Key(&#39;quatre&#39;, 4));
select Json_Set_Item(@j, &#39;foo&#39;, &#39;$[1]&#39;, 5, &#39;$[3].cinq&#39;) as &#34;Set&#34;,
Json_Insert_Item(@j, &#39;foo&#39;, &#39;$[1]&#39;, 5, &#39;$[3].cinq&#39;) as &#34;Insert&#34;,
Json_Update_Item(@j, &#39;foo&#39;, &#39;$[1]&#39;, 5, &#39;$[3].cinq&#39;) as &#34;Update&#34;;
&lt;&lt;/code&gt;&gt;

This query returns:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Set |= Insert |= Update
| [1,&#34;foo&#34;,3,{&#34;quatre&#34;:4,&#34;cinq&#34;:5}] | [1,2,3,{&#34;quatre&#34;:4,&#34;cinq&#34;:5}] | [1,&#34;foo&#34;,3,{&#34;quatre&#34;:4}]
&lt;&lt;/style&gt;&gt;

=== JsonValue
&lt;&lt;code&gt;&gt;
JsonValue (val)
&lt;&lt;/code&gt;&gt;
Returns a JSON value as a string, for instance:

&lt;&lt;sql&gt;&gt;
select JsonValue(3.1416);
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= JsonValue(3.1416)
| 3.141600
&lt;&lt;/style&gt;&gt;

Before MariaDB 10.1.9, this function was called Json_Value, but was renamed to avoid clashing with the [[json_value|JSON_VALUE]] function. 

== The “JBIN” return type
Almost all functions returning a json string - whose name begins with //Json_// - have a counterpart with a name beginning with //Jbin_//. This is both for performance (speed and memory) as well as for better control of what the functions should do.

This is due to the way CONNECT UDFs work internally. The Json functions, when receiving json strings as parameters, parse them and construct a binary tree in memory. They work on this tree and before returning; serialize this tree to return a new json string.

If the json document is large, this can take up a large amount of time and storage space. It is all right when one simple json function is called – it must be done anyway – but is a waste of time and memory when json functions are used as parameters to other json functions.

To avoid multiple serializing and parsing, the Jbin functions should be used as parameters to other functions. Indeed, they do not serialize the memory document tree, but return a structure allowing the receiving function to have direct access to the memory tree. This saves the serialize-parse steps otherwise needed to pass the argument and removes the need to reallocate the memory of the binary tree, which by the way is 6 to 7 times the size of the json string. For instance:

&lt;&lt;sql&gt;&gt;
select Json_Object(Jbin_Array_Add(Jbin_Array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), &#39;d&#39;) as &#34;Jbin_foo&#34;) as &#34;Result&#34;;
&lt;&lt;/sql&gt;&gt;

This query returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Result
| {&#34;foo&#34;:[&#34;a&#34;,&#34;b&#34;,&#34;c&#34;,&#34;d&#34;]} 
&lt;&lt;/style&gt;&gt;

Here the binary json tree allocated by //Jbin_Array// is completed by //Jbin_Array_Add// and //Json_Object// and serialized only once to make the final result string. It would be serialized and parsed two more times if using “Json” functions.

Note that Jbin results are recognized as such because they are aliased beginning with “Jbin_”. This is why in the //Json_Object// function the alias is specified as “Jbin_foo”.

What happens if it is not recognized as such? These functions are declared as returning a string and to take care of this, the returned structure begins with a zero-terminated string. For instance:

&lt;&lt;sql&gt;&gt;
select Jbin_Array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);
&lt;&lt;/sql&gt;&gt;

This query replies:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Jbin_Array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)
| Binary Json array
&lt;&lt;/style&gt;&gt;

Note: When testing, the tree returned by a “Jbin” function can be seen using the //Json_Serialize// function whose unique parameter must be a “Jbin” result. For instance:

&lt;&lt;sql&gt;&gt;
select Json_Serialize(Jbin_Array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;));
&lt;&lt;/sql&gt;&gt;

This query returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Serialize(Jbin_Array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))
| [&#34;a&#34;,&#34;b&#34;,&#34;c&#34;]
&lt;&lt;/style&gt;&gt;

Note: For this simple example, this is equivalent to using the //Json_Array// function.

=== Using a file as json UDF first argument
We have seen that many json UDFs can have an additional argument not yet described. This is in the case where the json item argument was referring to a file. Then the additional integer argument is the pretty value of the json file. It matters only when the first argument is just a file name (to make the UDF understand this argument is a file name, it should be aliased with a name beginning with jfile_) or if the function modifies the file, in which case it will be rewritten with this pretty format.  

The json item is created by extracting the required part from the file. This can be the whole file but more often only some of it. There are two ways to specify the sub-item of the file to be used:

# Specifying it in the //Json_File// or //Jbin_File// arguments.
# Specifying it in the receiving function (not possible for all functions).

It doesn’t make any difference when the //Jbin_File// is used but it does with //Json_File//. For instance:

&lt;&lt;sql&gt;&gt;
select Jfile_Make(&#39;{&#34;a&#34;:1, &#34;b&#34;:[44, 55]}&#39; json_, &#39;test.json&#39;);
select Json_Array_Add(Json_File(&#39;test.json&#39;, &#39;b&#39;), 66);
&lt;&lt;/sql&gt;&gt;

The second query returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Array_Add(Json_File(&#39;test.json&#39;, &#39;b&#39;), 66)
| [44,55,66]
&lt;&lt;/style&gt;&gt;

It just returns the – modified -- subset returned by the Json_File function, while the query:

&lt;&lt;sql&gt;&gt;
select Json_Array_Add(Json_File(&#39;test.json&#39;), 66, &#39;b&#39;);
&lt;&lt;/sql&gt;&gt;

returns what was received from //Json_File// with the modification made on the subset.

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Array_Add(Json_File(&#39;test.json&#39;), 66, &#39;b&#39;)
| {&#34;a&#34;:1,&#34;b&#34;:[44,55,66]}
&lt;&lt;/style&gt;&gt;

Note that in both case the test.json file is not modified. This is because the //Json_File// function returns a string representing all or part of the file text but no information about the file name. This is all right to check what would be the effect of the modification to the file.

However, to have the file modified, use the //Jbin_File// function or directly give the file name. //Jbin_File// returns a structure containing the file name, a pointer to the file parsed tree and eventually a pointer to the subset when a path is given as a second argument: 

&lt;&lt;sql&gt;&gt;
select Json_Array_Add(Jbin_File(&#39;test.json&#39;, &#39;b&#39;), 66);
&lt;&lt;/sql&gt;&gt;

This query returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_Array_Add(Jbin_File(&#39;test.json&#39;, &#39;b&#39;), 66)
| test.json
&lt;&lt;/style&gt;&gt;

This time the file is modified. This can be checked with:

&lt;&lt;sql&gt;&gt;
select Json_File(&#39;test.json&#39;, 3);
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Json_File(&#39;test.json&#39;, 3)
| {&#34;a&#34;:1,&#34;b&#34;:[44,55,66]}
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;

The reason why the first argument is returned by such a query is because of tables such as:

&lt;&lt;sql&gt;&gt;
create table tb (
n int key,
jfile_cols char(10) not null);
insert into tb values(1,&#39;test.json&#39;);
&lt;&lt;/sql&gt;&gt;

In this table, the //jfile_cols// column just contains a file name. If we update it by:

&lt;&lt;sql&gt;&gt;
update tb set jfile_cols = select Json_Array_Add(Jbin_File(&#39;test.json&#39;, &#39;b&#39;), 66)
where n = 1;
&lt;&lt;/sql&gt;&gt;

This is the test.json file that must be modified, not the jfile_cols column. This can be checked by:

&lt;&lt;sql&gt;&gt;
select JsonGet_String(jfile_cols, &#39;[1]:*&#39;) from tb;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= JsonGet_String(jfile_cols, &#39;[1]:*&#39;)
| {&#34;a&#34;:1,&#34;b&#34;:[44,55,66]}
&lt;&lt;/style&gt;&gt;

Note: It was an important facility to name the second column of the table beginning by “jfile_” so the json functions knew it was a file name without obliging to specify an alias in the queries.

=== Using “Jbin” to control what the query execution does
This is applying in particular when acting on json files. We have seen that a file was not modified when using the //Json_File// function as an argument to a modifying function because the modifying function just received a copy of the json file. This is not true when using the //Jbin_File// function that does not serialize the binary document and make it directly accessible. Also, as we have seen earlier, json functions that modify their first file parameter modify the file and return the file name. This is done by directly serializing the internal binary document as a file.

However, the “Jbin” counterpart of these functions does not serialize the binary document and thus does not modify the json file. For example let us compare these two queries:

/* First query */
&lt;&lt;sql&gt;&gt;
select Json_Object(Jbin_Object_Add(Jbin_File(&#39;bt2.json&#39;), 4 as &#34;d&#34;) as &#34;Jbin_bt1&#34;)
  as &#34;Result&#34;;
&lt;&lt;/sql&gt;&gt;

/* Second query */
&lt;&lt;sql&gt;&gt;
select Json_Object(Json_Object_Add(Jbin_File(&#39;bt2.json&#39;), 4 as &#34;d&#34;) as &#34;Jfile_bt1&#34;)
  as &#34;Result&#34;;
&lt;&lt;/sql&gt;&gt;

Both queries return:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Result
| {&#34;bt1&#34;:{&#34;a&#34;:1,&#34;b&#34;:2,&#34;c&#34;:3,&#34;d&#34;:4}}
&lt;&lt;/style&gt;&gt;

In the first query //Jbin_Object_Add// does not serialize the document (no “Jbin” functions do) and //Json_Object// just returns a serialized modified tree. Consequently, the file bt2.json is not modified. This query is all right to copy a modified version of the json file without modifying it.

However, in the second query //Json_Object_Add// does modify the json file and returns the file name. The //Json_Object// function receives this file name, reads and parses the file, makes an object from it and returns the serialized result. This modification can be done willingly but can be an unwanted side effect of the query.

Therefore, using “Jbin” argument functions, in addition to being faster and using less memory, are also safer when dealing with json files that should not be modified.

== Using JSON as Dynamic Columns
The JSON nosql language has all the features to be used as an alternative to dynamic columns. For instance, take the following example of dynamic columns:

&lt;&lt;sql&gt;&gt;
create table assets (
   item_name varchar(32) primary key, /* A common attribute for all items */
   dynamic_cols  blob  /* Dynamic columns will be stored here */
 );

INSERT INTO assets VALUES
   (&#39;MariaDB T-shirt&#39;, COLUMN_CREATE(&#39;color&#39;, &#39;blue&#39;, &#39;size&#39;, &#39;XL&#39;));

INSERT INTO assets VALUES
   (&#39;Thinkpad Laptop&#39;, COLUMN_CREATE(&#39;color&#39;, &#39;black&#39;, &#39;price&#39;, 500));

SELECT item_name, COLUMN_GET(dynamic_cols, &#39;color&#39; as char) AS color FROM assets;
+-----------------+-------+
| item_name       | color |
+-----------------+-------+
| MariaDB T-shirt | blue  |
| Thinkpad Laptop | black |
+-----------------+-------+
&lt;&lt;/sql&gt;&gt;

/* Remove a column: */
&lt;&lt;sql&gt;&gt;
UPDATE assets SET dynamic_cols=COLUMN_DELETE(dynamic_cols, &#34;price&#34;)
  WHERE COLUMN_GET(dynamic_cols, &#39;color&#39; as char)=&#39;black&#39;;
&lt;&lt;/sql&gt;&gt;

/* Add a column: */
&lt;&lt;sql&gt;&gt;
UPDATE assets SET dynamic_cols=COLUMN_ADD(dynamic_cols, &#39;warranty&#39;, &#39;3 years&#39;)
   WHERE item_name=&#39;Thinkpad Laptop&#39;;
&lt;&lt;/sql&gt;&gt;

/* You can also list all columns, or
   get them together with their values in JSON format: */
&lt;&lt;sql&gt;&gt;
SELECT item_name, column_list(dynamic_cols) FROM assets;
+-----------------+---------------------------+
| item_name       | column_list(dynamic_cols) |
+-----------------+---------------------------+
| MariaDB T-shirt | `size`,`color`            |
| Thinkpad Laptop | `color`,`warranty`        |
+-----------------+---------------------------+

SELECT item_name, COLUMN_JSON(dynamic_cols) FROM assets;
+-----------------+----------------------------------------+
| item_name       | COLUMN_JSON(dynamic_cols)              |
+-----------------+----------------------------------------+
| MariaDB T-shirt | {&#34;size&#34;:&#34;XL&#34;,&#34;color&#34;:&#34;blue&#34;}           |
| Thinkpad Laptop | {&#34;color&#34;:&#34;black&#34;,&#34;warranty&#34;:&#34;3 years&#34;} |
+-----------------+----------------------------------------+
&lt;&lt;/sql&gt;&gt;

The same result can be obtained with json columns using the json UDF’s:

/* JSON equivalent */
&lt;&lt;sql&gt;&gt;
create table jassets (
   item_name varchar(32) primary key, /* A common attribute for all items */
   json_cols varchar(512)  /* Jason columns will be stored here */
 );

INSERT INTO jassets VALUES
   (&#39;MariaDB T-shirt&#39;, Json_Object(&#39;blue&#39; color, &#39;XL&#39; size));

INSERT INTO jassets VALUES
   (&#39;Thinkpad Laptop&#39;, Json_Object(&#39;black&#39; color, 500 price));

SELECT item_name, JsonGet_String(json_cols, &#39;color&#39;) AS color FROM jassets;
+-----------------+-------+
| item_name       | color |
+-----------------+-------+
| MariaDB T-shirt | blue  |
| Thinkpad Laptop | black |
+-----------------+-------+
&lt;&lt;/sql&gt;&gt;

/* Remove a column: */
&lt;&lt;sql&gt;&gt;
UPDATE jassets SET json_cols=Json_Object_Delete(json_cols, &#39;price&#39;)
 WHERE JsonGet_String(json_cols, &#39;color&#39;)=&#39;black&#39;;
&lt;&lt;/sql&gt;&gt;

/* Add a column */
&lt;&lt;sql&gt;&gt;
UPDATE jassets SET json_cols=Json_Object_Add(json_cols, &#39;3 years&#39; warranty)
 WHERE item_name=&#39;Thinkpad Laptop&#39;;
&lt;&lt;/sql&gt;&gt;

/* You can also list all columns, or get them together with their values in JSON format: */
&lt;&lt;sql&gt;&gt;
SELECT item_name, Json_Object_List(json_cols) FROM jassets;
+-----------------+-----------------------------+
| item_name       | Json_Object_List(json_cols) |
+-----------------+-----------------------------+
| MariaDB T-shirt | [&#34;color&#34;,&#34;size&#34;]            |
| Thinkpad Laptop | [&#34;color&#34;,&#34;warranty&#34;]        |
+-----------------+-----------------------------+

SELECT item_name, json_cols FROM jassets;
+-----------------+----------------------------------------+
| item_name       | json_cols                              |
+-----------------+----------------------------------------+
| MariaDB T-shirt | {&#34;color&#34;:&#34;blue&#34;,&#34;size&#34;:&#34;XL&#34;}           |
| Thinkpad Laptop | {&#34;color&#34;:&#34;black&#34;,&#34;warranty&#34;:&#34;3 years&#34;} |
+-----------------+----------------------------------------+
&lt;&lt;/sql&gt;&gt;

However, using JSON brings features not existing in dynamic columns:

* Use of a language used by many implementation and developers.
* Full support of arrays, currently missing from dynamic columns.
* Access of subpart of json by JPATH that can include calculations on arrays.
* Possible references to json files.

With more experience, additional UDFs can be easily written to support new needs.

== New Set of BSON Functions
All these functions have been rewritten using the new JSON handling way and are temporarily available changing the J starting name to B. Then Json_Make_Array new style is called using Bson_Make_Array.
Some, such as Bson_Item_Delete, are new and some fix bugs found in their Json counterpart.

== Converting Tables to JSON
The JSON UDF’s and the direct Jpath “*” facility are powerful tools to convert table and files to the JSON format. For instance, the file ##biblio3.json## we used previously can be obtained by converting the ##xsample.xml file##. This can be done like this:

From Connect 1.07.0002
&lt;&lt;code wrap=true lang=sql&gt;&gt;
create table xj1 (row varchar(500) jpath=&#39;*&#39;) engine=connect table_type=JSON file_name=&#39;biblio3.json&#39; option_list=&#39;jmode=2&#39;;
&lt;&lt;/code&gt;&gt;

Before Connect 1.07.0002
&lt;&lt;sql&gt;&gt;
create table xj1 (row varchar(500) field_format=&#39;*&#39;) 
 engine=connect table_type=JSON file_name=&#39;biblio3.json&#39; option_list=&#39;jmode=2&#39;;
&lt;&lt;/sql&gt;&gt;

And then :

&lt;&lt;sql&gt;&gt;
insert into xj1
  select json_object_nonull(ISBN, language LANG, SUBJECT, 
    json_array_grp(json_object(authorfn FIRSTNAME, authorln LASTNAME)) json_AUTHOR, TITLE,
    json_object(translated PREFIX, json_object(tranfn FIRSTNAME, tranln LASTNAME) json_TRANSLATOR) 
    json_TRANSLATED, json_object(publisher NAME, location PLACE) json_PUBLISHER, date DATEPUB) 
from xsampall2 group by isbn;
&lt;&lt;/sql&gt;&gt;

The xj1 table rows will directly receive the Json object made by the select statement used in the insert statement and the table file will be made as shown (xj1 is pretty=2 by default) Its mode is Jmode=2 because the values inserted are strings even if they denote json objects.

Another way to do this is to create a table describing the file format we want before the ##biblio3.json## file existed:

From Connect 1.07.0002
&lt;&lt;sql&gt;&gt;
create table jsampall3 (
ISBN char(15),
LANGUAGE char(2) jpath=&#39;LANG&#39;,
SUBJECT char(32),
AUTHORFN char(128) jpath=&#39;AUTHOR:[X]:FIRSTNAME&#39;,
AUTHORLN char(128) jpath=&#39;AUTHOR:[X]:LASTNAME&#39;,
TITLE char(32),
TRANSLATED char(32) jpath=&#39;TRANSLATOR:PREFIX&#39;,
TRANSLATORFN char(128) jpath=&#39;TRANSLATOR:FIRSTNAME&#39;,
TRANSLATORLN char(128) jpath=&#39;TRANSLATOR:LASTNAME&#39;,
PUBLISHER char(20) jpath=&#39;PUBLISHER:NAME&#39;,
LOCATION char(20) jpath=&#39;PUBLISHER:PLACE&#39;,
DATE int(4) jpath=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON file_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

Before Connect 1.07.0002
&lt;&lt;sql&gt;&gt;
create table jsampall3 (
ISBN char(15),
LANGUAGE char(2) field_format=&#39;LANG&#39;,
SUBJECT char(32),
AUTHORFN char(128) field_format=&#39;AUTHOR:[X]:FIRSTNAME&#39;,
AUTHORLN char(128) field_format=&#39;AUTHOR:[X]:LASTNAME&#39;,
TITLE char(32),
TRANSLATED char(32) field_format=&#39;TRANSLATOR:PREFIX&#39;,
TRANSLATORFN char(128) field_format=&#39;TRANSLATOR:FIRSTNAME&#39;,
TRANSLATORLN char(128) field_format=&#39;TRANSLATOR:LASTNAME&#39;,
PUBLISHER char(20) field_format=&#39;PUBLISHER:NAME&#39;,
LOCATION char(20) field_format=&#39;PUBLISHER:PLACE&#39;,
DATE int(4) field_format=&#39;DATEPUB&#39;)
engine=CONNECT table_type=JSON file_name=&#39;biblio3.json&#39;;
&lt;&lt;/sql&gt;&gt;

and to populate it by:

&lt;&lt;sql&gt;&gt;
insert into jsampall3 select * from xsampall;
&lt;&lt;/sql&gt;&gt;

This is a simpler method. However, the issue is that this method cannot handle the multiple column values. This is why we inserted from ##xsampall## not from ##xsampall2##. How can we add the missing multiple authors in this table? Here again we must create a utility table able to handle JSON strings.
From Connect 1.07.0002
&lt;&lt;code wrap=true lang=sql&gt;&gt;
create table xj2 (ISBN char(15), author varchar(150) jpath=&#39;AUTHOR:*&#39;) engine=connect table_type=JSON file_name=&#39;biblio3.json&#39; option_list=&#39;jmode=1&#39;;
&lt;&lt;/code&gt;&gt;

Before Connect 1.07.0002
&lt;&lt;sql&gt;&gt;
create table xj2 (ISBN char(15), author varchar(150) field_format=&#39;AUTHOR:*&#39;) 
  engine=connect table_type=JSON file_name=&#39;biblio3.json&#39; option_list=&#39;jmode=1&#39;;
&lt;&lt;/sql&gt;&gt;

&lt;&lt;sql&gt;&gt;
update xj2 set author =
(select json_array_grp(json_object(authorfn FIRSTNAME, authorln LASTNAME)) 
  from xsampall2 where isbn = xj2.isbn);
&lt;&lt;/sql&gt;&gt;

Voilà !

== Converting json files 
We have seen that json files can be formatted differently depending on the pretty option. In particular, big data files should be formatted with pretty equal to 0 when used by a CONNECT json table. The best and simplest way to convert a file from one format to another is to use the //Jfile_Make// function. Indeed this function makes a file of specified format using the syntax:

&lt;&lt;code&gt;&gt;
Jfile_Make(json_document, [file_name], [pretty]);
&lt;&lt;/code&gt;&gt;

The file name is optional when the json document comes from a Jbin_File function because the returned structure makes it available. For instance, to convert back the json file tb.json to pretty= 0, this can be simply done by:

&lt;&lt;sql&gt;&gt;
select Jfile_Make(Jbin_File(&#39;tb.json&#39;), 0);
&lt;&lt;/sql&gt;&gt;

== Performance Consideration
MySQL and PostgreSQL have a JSON data type that is not just text but an internal encoding of JSON data. This is to save parsing time when executing JSON functions. Of course, the parse must be done anyway when creating the data and serializing must be done to output the result.

CONNECT directly works on character strings impersonating JSON values with the need of parsing them all the time but with the advantage of working easily on external data. Generally, this is not too penalizing because JSON data are often of some or reasonable size. The only case where it can be a serious problem is when working on a big JSON file.

Then, the file should be formatted or converted to //pretty=0//.

From Connect 1.7.002, this easily done using the Jfile_Convert function, for instance:

&lt;&lt;code&gt;&gt;
select jfile_convert(&#39;bibdoc.json&#39;,&#39;bibdoc0.json&#39;,350);
&lt;&lt;/code&gt;&gt;

Such a json file should not be used directly by JSON UDFs because they parse the whole file, even when only a subset is used. Instead, it should be used by a JSON table created on it. Indeed, JSON tables do not parse the whole document but just the item corresponding to the row they are working on. In addition, indexing can be used by the table as explained previously on this page.

Generally speaking, the maximum flexibility offered by CONNECT is by using JSON tables and JSON UDFs together. Some things are better handled by tables, other by UDFs. The tools are there but it is up to you to discover the best way to resolve your problems. 

=== Bjson files
Starting with Connect 1.7.002, //pretty=0// json files can be converted to a binary format that is a pre-parsed representation of json. This can be done with the Jfile_Bjson UDF function, for instance:

&lt;&lt;sql&gt;&gt;
select jfile_bjson(&#39;bigfile.json&#39;,&#39;binfile.json&#39;,3500);
&lt;&lt;/sql&gt;&gt;

Here the third argument, the record length, must 6 to 10 times larger than the lrecl of the initial json file because the parsed representation is bigger than the original json text representation.

Tables using such Bjson files must specify ‘Pretty=-1’ in the option list.
 
It is probably similar to the BSON used by MongoDB and PostgreSQL and permits to process queries up to 10 times faster than working on text json files. Indexing is also available for tables using this format making even more performance improvement. For instance, some queries on a json table of half a million rows, that were previously done in more than 10 seconds, took only 0.1 second when converted and indexed.

Here again, this has been remade to use the new way Json is handled. The files made using the bfile_bjson function are only from two to four times the size of the source files. This new representation is not compatible with the old one. Therefore, these files must be used with BSON tables only.  

== Specifying a JSON table Encoding
An important feature of JSON is that strings should in UNICODE. As a matter of fact, all examples we have found on the Internet seemed to be just ASCII. This is because UNICODE is generally encoded in JSON files using UTF8 or UTF16 or UTF32.

To specify the required encoding, just use the data_charset CONNECT option or the native DEFAULT CHARSET option.

== Retrieving JSON data from MongoDB
Classified as a NoSQL database program, MongoDB uses JSON-like documents (BSON) grouped in collections. The simplest way, and only method available before Connect 1.6, to access MongoDB data was to export a collection to a JSON file. This produces a file having the pretty=0 format. Viewed as SQL, a collection is a table and documents are table rows.

Since CONNECT version 1.6, it is now possible to directly access MongoDB collections via their MongoDB C Driver. This is the purpose of the MONGO table type described later. However, JSON tables can also do it in a somewhat different way (providing MONGO support is installed as described for MONGO tables).

It is achieved by specifying the MongoDB connection URI while creating the table. For instance:

From Connect 1.7.002
&lt;&lt;sql&gt;&gt;
create or replace table jinvent (
_id char(24) not null, 
item char(12) not null,
instock varchar(300) not null jpath=&#39;instock.*&#39;)
engine=connect table_type=JSON tabname=&#39;inventory&#39; lrecl=512
connection=&#39;mongodb://localhost:27017&#39;;
&lt;&lt;/sql&gt;&gt;

Before Connect 1.7.002
&lt;&lt;sql&gt;&gt;
create or replace table jinvent (
_id char(24) not null, 
item char(12) not null,
instock varchar(300) not null field_format=&#39;instock.*&#39;)
engine=connect table_type=JSON tabname=&#39;inventory&#39; lrecl=512
connection=&#39;mongodb://localhost:27017&#39;;
&lt;&lt;/sql&gt;&gt;

In this statement, the //file_name// option was replaced by the //connection// option. It is the URI enabling to retrieve data from a local or remote MongoDB server. The //tabname// option is the name of the MongoDB collection that will be used and the //dbname// option could have been used to indicate the database containing the collection (it defaults to the current database).

The way it works is that the documents retrieved from MongoDB are serialized and CONNECT uses them as if they were read from a file. This implies serializing by MongoDB and parsing by CONNECT and is not the best performance wise. CONNECT tries its best to reduce the data transfer when a query contains a reduced column list and/or a where clause. This way makes all the possibilities of the JSON table type available, such as calculated arrays.

However, to work on large JSON collations, using the MONGO table type is generally the normal way.

Note: JSON tables using the MongoDB access accept the specific MONGO options [[connect-mongo-table-type/#colist-option|colist]], [[connect-mongo-table-type/#filter-option|filter]] and [[connect-mongo-table-type/#pipeline-option|pipeline]]. They are described in the MONGO table chapter.

== Summary of Options and Variables Used with Json Tables

Options and variables that can be used when creating Json tables are listed here:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Table Option |= Type |= Description
| ENGINE | String | Must be specified as CONNECT.
| TABLE_TYPE | String | Must be JSON or BSON.
| FILE_NAME | String | The optional file (path) name of the Json file. Can be absolute or relative to the current data directory. If not specified, it defaults to the table name and json file type. 
| DATA_CHARSET | String | Set it to ‘utf8’ for most Unicode Json documents.
| LRECL | Number | The file record size for pretty &lt; 2 json files.
| HTTP | String | The HTTP of the server of REST queries.
| URI | String | THE URI of REST queries
| CONNECTION* | String | Specifies a connection to ##MONGODB##.
| ZIPPED | Boolean | True if the json file(s) is/are zipped in one or several zip files.
| MULTIPLE | Number | Used to specify a multiple file table.
| SEP_CHAR | String | Set it to ‘:’ for old tables using the old json path syntax.
| CATFUNC | String | The catalog function (column) used when creating a catalog table.
| OPTION_LIST | String | Used to specify all other options listed below.
&lt;&lt;/style&gt;&gt;

(*) For Json tables connected to MongoDB, Mongo specific options can also be used.

Other options must be specified in the option list:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Table Option |= Type |= Description
| DEPTH\\LEVEL | Number | Specifies the depth in the document CONNECT looks when defining columns by discovery or in catalog tables
| PRETTY | Number | Specifies the format of the Json file (-1 for Bjson files)
| EXPAND | String | The name of the column to expand.
| OBJECT | String | The json path of the sub-document used for the table.
| BASE | Number | The numbering base for arrays: 0 (the default) or 1.
| LIMIT | Number | The maximum number of array values to use when concatenating, calculating or expanding arrays. Defaults to 50 (&gt;= Connect 1.7.0003), 10 (&lt;= Connect 1.7.0002).
| FULLARRAY | Boolean | Used when creating with Discovery. Make a column for each value of arrays (up to LIMIT).
| JMODE | Number | The Json mode (array of objects, array of arrays, or array of values) Only used when inserting new rows.
| ACCEPT | Boolean | Keep null columns (for discovery).
| AVGLEN | Number | An estimate average length of rows. This is used only when indexing and can be set if indexing fails by miscalculating the table max size.
| STRINGIFY | String | Ask discovery to make a column to return the Json representation of this object.
&lt;&lt;/style&gt;&gt;

Column options:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Column Option |= Type |= Description
| JPATH\\FIELD_FORMAT | String | Defaults to the column name.
| DATE_FORMAT | String | Specifies the date format into the Json file when defining a DATE, DATETIME or TIME column.
&lt;&lt;/style&gt;&gt;

Variables used with Json tables are:
* [[connect-system-variables/#connect_default_depth|connect_default_depth]]
* [[connect-system-variables/#connect_json_null|connect_json_null]]
* [[connect-system-variables/#connect_json_all_path|connect_json_all_path]]
* [[connect-system-variables/#connect_force_bson|connect_force_bson]]

== Notes
&lt;&lt;references&gt;&gt;</textarea>
    


                    <div id="content_disclaimer" class="graybox">
                        Content reproduced on this site is the property of its respective owners,
                        and this content is not reviewed in advance by MariaDB. The views, information and opinions
                        expressed by this content do not necessarily represent those of MariaDB or any other party.
                    </div>
                </div>
            </section>

            
        </div>
    </div>
</div>

<!-- Footer -->
<footer id="footer">
    <div class="footer">
        <div class="container">
            <div class="row">
                <div class="col-xs-12">
                    <ul class="list-inline text-center footer-nav">
                        <li>
                            <h5>
                                <a href="https://mariadb.com/products" title="Products">Products</a>
                            </h5>
                        </li>
                        <li>
                            <h5>
                                <a href="https://mariadb.com/services" title="Services">Services</a>
                            </h5>
                        </li>
                        <li>
                            <h5>
                                <a href="https://mariadb.com/pricing" title="Pricing">Pricing</a>
                            </h5>
                        </li>
                        <li>
                            <h5>
                                <a href="https://mariadb.com/resources" title="Resources">Resources</a>
                            </h5>
                        </li>
                        <li>
                            <h5><a href="https://mariadb.com/about-us" title="About MariaDB">About Us</a></h5>
                        </li>
                        <li>
                            <h5><a href="https://mariadb.com/download" title="Download">Download MariaDB</a></h5>
                        </li>
                    </ul>
                </div>
            </div>
            <div class="row row-10">
                
                <div class="col-md-4 col-xs-12 item col-md-offset-4">
                    <div id="block-footerformcontact" class="block block-block-content block-block-contentd754ee1b-3cc9-40e7-9ef4-f504f1197fb1">
                        
                            <h5 style="font-weight: 400;">Subscribe to our newsletter!</h5>
                            <script src="//app-sj15.marketo.com/js/forms2/js/forms2.min.js"></script><form id="mktoForm_1498"></form>
                            <script>
                                <!--//--><![CDATA[// ><!--
                                MktoForms2.loadForm("//app-sj15.marketo.com", "573-PXI-984", 1498);
                                //--><!]]]]><![CDATA[>
                                //--><!]]>
                            </script>
                        
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-md-4 col-xs-12 item col-md-offset-4">
                    <div class="footer-copyright">
                        <div class="text-center">
                            <ul class="list-inline no-margin">
                                <li>
                                    <a href="/legal" title="Legal">Legal</a>
                                </li>
                                <li>
                                    <a href="/privacy-policy" title="Privacy Policy">Privacy Policy</a>
                                </li>
                                <li>
                                    <a href="/cookie-policy/" title="Cookies">Cookie Policy</a>
                                </li>
                            </ul>
                            <p>Copyright &copy; 2024 MariaDB. All rights reserved.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
</footer>
</div>

<div id="ajax_loading">
    <img src="/kb/static/images/ajax-loader.a51c5608d01a.gif" />
</div>

    <!-- Google Tag Manager -->
    <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MK2847"
                      height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-MK2847');</script>
    <!-- End Google Tag Manager -->

</body>

<script type="text/javascript" src="/kb/static/js/main.1587e3a666fc.js" charset="utf-8"></script>

</html>