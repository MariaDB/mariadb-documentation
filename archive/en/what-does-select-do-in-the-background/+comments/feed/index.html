<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>MariaDB Knowledge Base Comments for: What does SELECT do in the background ?</title><link>https://mariadb.com/kb/en/what-does-select-do-in-the-background/+comments/feed/</link><description></description><atom:link href="https://mariadb.com/kb/en/what-does-select-do-in-the-background/+comments/feed/" rel="self"></atom:link><language>en-us</language><lastBuildDate>Tue, 02 Jan 2024 00:25:23 +0000</lastBuildDate><item><title>Re: What does SELECT do in the background ?</title><link>https://mariadb.com/kb/en/what-does-select-do-in-the-background/+comments/318</link><description>&lt;p&gt;That is a very nice overview, exactly the kind of information I was looking for.
Plenty of information there to digest.&lt;/p&gt;
&lt;p&gt;Many thanks&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Dave Mira</dc:creator><guid>https://mariadb.com/kb/en/what-does-select-do-in-the-background/+comments/318</guid></item><item><title>Re: What does SELECT do in the background ?</title><link>https://mariadb.com/kb/en/what-does-select-do-in-the-background/+comments/315</link><description>&lt;p&gt;Your SQL query will be place into a  thread that will live the time of your connection into the database server. &lt;/p&gt;
&lt;p&gt;That thread will parse the query and compute an execution plan (QP) and run it.&lt;/p&gt;
&lt;p&gt;The QP ask statistics to the underlying tables and indexes to decide ( brut force) what plan cost less.&lt;/p&gt;
&lt;p&gt;You can see the plan running :&lt;/p&gt;
&lt;p&gt;EXPLAIN SELECT col1,col2,col3,col4,...,coln FROM table1 WHERE (condition) ..&lt;/p&gt;
&lt;p&gt;You need to take care that your conditions are covered by an index that will promote a plan that using the index have direct access to those 1000 thousand records &lt;/p&gt;
&lt;p&gt;Without the index the plan will push all table records to the SQL thread that will reject records that don't match your conditions. DBA are calling this a full table scan and try to limit this with good indexing. &lt;/p&gt;
&lt;p&gt;The result will be put into a network buffer and send to your client. This is costly CPU as well so thread does not really stop working until the plan is finished.&lt;/p&gt;
&lt;p&gt;In many case resultset need to be sorted: ORDER BY, GROUP BY, DISTINCT, that are not covered by an index. 
In that case the result will be fully BUFFERED into a memory table or a disk base table (MyISAM engine type) when the result can't be put in memory : sizing or data type reasons (BLOB does not like memory tables and vis versa)  &lt;/p&gt;
&lt;p&gt;if you wan't to force the server to buffer the resulset into a temporary table just add SQL_BUFFER_RESULT after the SELECT. This will free up a table lock while the resultset is being sent to the client.&lt;/p&gt;
&lt;p&gt;Some API calls also enable this same server buffering feature. &lt;/p&gt;
&lt;p&gt;In MySQL your thread is living in what is call the SQL layer and your data and indexes are manage by what is call the STORAGE ENGINE layer. Each storage engine use some memory buffers to cache indexes and table data. so the first execution of your query will load data from disk and then retrive it later from memory if the all dataset feat into those buffer. Monitoring the hit ratio of those buffers is a requirement for the overall performance and setting them correctly is a must do : read about innodb_buffer_pool_size , and key_buffer. There are mainly the only variables that need to be change according to memory of your hardware. &lt;/p&gt;
&lt;p&gt;There is an other cache call the query cache (QC) this one stay in the SQL LAYER and will store the resultset of your query until the undelying tables get some changes. If the query come again the result will be served from the QC and not get executed again.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Stephane VAROQUI</dc:creator><guid>https://mariadb.com/kb/en/what-does-select-do-in-the-background/+comments/315</guid></item></channel></rss>