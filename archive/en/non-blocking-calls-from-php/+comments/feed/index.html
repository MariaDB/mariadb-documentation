<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>MariaDB Knowledge Base Comments for: Non-blocking calls from PHP</title><link>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/feed/</link><description></description><atom:link href="https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/feed/" rel="self"></atom:link><language>en-us</language><lastBuildDate>Mon, 04 Nov 2024 18:01:30 +0000</lastBuildDate><item><title>Re: Non-blocking calls from PHP</title><link>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2065</link><description>&lt;p&gt;yes it is useful.  you assign a random filename then you poll it.  but do what you want, the solution I proposed will work just fine&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Justin Swanhart Swanhart</dc:creator><guid>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2065</guid></item><item><title>Re: Non-blocking calls from PHP</title><link>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2064</link><description>&lt;p&gt;It's not useful to do temporary files in multiuser multitask system.&lt;/p&gt;
&lt;p&gt;I know one better way to do the task: you can do unbuffered reading in a separate second PHP scipt and call it from the main script by HTTP (using localhost). Then you can read its TCP-socket asynchronous (it's also not graceful in PHP, but possible).&lt;/p&gt;
&lt;p&gt;Node.JS support async requests to MySQL (through new MariaDB clent API). Does anybody know if it's possible to ineract from PHP to Node.JS in a async non-blocking way?&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael Shestero</dc:creator><guid>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2064</guid></item><item><title>Re: Non-blocking calls from PHP</title><link>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2063</link><description>&lt;p&gt;Oh, one more thing, you will need to write the file to a shared filesystem if you aren't running the PHP client on the same machine as the server, but this is trivial.  You could use CIFS or NFS for example.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Justin Swanhart Swanhart</dc:creator><guid>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2063</guid></item><item><title>Re: Non-blocking calls from PHP</title><link>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2062</link><description>&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;You can support the second requirement by using SELECT .. INTO OUTFILE.  You could see that the query is in RUNNING state, then open the file in PHP, which will not be completely written until the query completes.  This will allow you to get the results in an unbuffered fashion.&lt;/p&gt;
&lt;p&gt;To do this with ASYNC, add a hint to the beginning of the query:
call async.queue('/*+unbuffered*/select * from mysql.user into outfile "/tmp/test2.txt"');&lt;/p&gt;
&lt;p&gt;If you combine that with a UDF to erase the files (there is one in &lt;a href="https://github.com/greenlion/Fastbit_UDF"&gt;https://github.com/greenlion/Fastbit_UDF&lt;/a&gt; called fb_unlink()) this could be a very workable solution to your problem.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Justin Swanhart Swanhart</dc:creator><guid>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2062</guid></item><item><title>Re: Non-blocking calls from PHP</title><link>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2061</link><description>&lt;p&gt;Thank you, very interesting!
But also it lack of functionality. I want a status function that return not only that a query is completed or in progress, but 3 cases:
1) query is in progress, nothing ready.
2) query is in progress and one can already read N records/rows in unbuffered mode (or just one record is ready) while it is in progress.
3) query is completed.
[ 4) error ]&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael Shestero</dc:creator><guid>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2061</guid></item><item><title>Re: Non-blocking calls from PHP</title><link>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2035</link><description>&lt;p&gt;I have been working on a native MySQL/MariaDB system that doesn't require using the C client, but instead executes queries (in parallel!) using events.&lt;/p&gt;
&lt;p&gt;Feel free to try it out:
&lt;a href="http://swanhart.livejournal.com/138754.html"&gt;http://swanhart.livejournal.com/138754.html&lt;/a&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Justin Swanhart Swanhart</dc:creator><guid>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2035</guid></item><item><title>Re: Non-blocking calls from PHP</title><link>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2023</link><description>&lt;p&gt;Current implementations of mysqli and mysql don't support the asynchronous API of Connector/C.&lt;/p&gt;
&lt;p&gt;I would recommend to write an additional extension, which uses the mysqli class  and supports the async api only. &lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Georg Richter</dc:creator><guid>https://mariadb.com/kb/en/non-blocking-calls-from-php/+comments/2023</guid></item></channel></rss>