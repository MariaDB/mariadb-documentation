<!DOCTYPE html>
<html>
<head data-cookie-domain=""
      data-cookie-path="/">
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="apple-touch-icon" sizes="180x180" href="/kb/static/images/favicons/apple-touch-icon.159e713979be.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/kb/static/images/favicons/favicon-32x32.bc0ac1d5d11e.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/kb/static/images/favicons/favicon-16x16.5801f8f0f34e.png">
    <link rel="shortcut icon" href="/kb/static/images/favicons/favicon.d122d305dee4.ico" type="image/x-icon" />

    <title>CONNECT ODBC Table Type: Accessing Tables From Another DBMS - Source - MariaDB Knowledge Base</title>

    <link href="/kb/static/css/main.b9e1e104f007.css" rel="stylesheet" type="text/css" />

    
        <meta name="robots" content="noindex, nofollow">
    

    <!-- FB Open Graph tags -->
    <meta property="og:title" content="CONNECT ODBC Table Type: Accessing Tables From Another DBMS - Source" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://mariadb.com/kb/en/connect-odbc-table-type-accessing-tables-from-another-dbms/+source/" />
    <meta property="og:image" content="http://mariadb.comaskmonty-logo.png" />
    <meta property="og:site_name" content="MariaDB KnowledgeBase" />
    <meta property="fb:admins" content="514852603" />
    <meta property="og:description" content="" />

    <meta name="description" content="" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="//fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet"/>
    
</head>
<body class="mpkb nodes autoresize nodes_source jqui" id="nodes_source">





<div id="menu-mobile" class="visible-sm visible-xs">

    <div>
        <div id="mobile-close-menu" class="text-right">
            <a href="javascript:void(0)" title="Close Menu" id="back-main" class="toggle-menu">X<span></span></a>
        </div>
    </div>
    <div class="mainmenu-mobile">
        <ul class="ls-none ul-menu">
            <li data-sub="submenu5"><a class="open-form-search" href="/kb/search/" title="Search">Search </a></li>
            <li data-sub="submenu0"><a href="/products" title="Products">Products</a><span class="arrow-main"></span></li>
            <li data-sub="submenu1"><a href="/services" title="Services">Services</a><span class="arrow-main"></span></li>
            <li data-sub="submenu2"><a href="/resources" title="Resources">Resources</a><span class="arrow-main"></span></li>
            <li data-sub="submenu3"><a href="/about-us" title="About">About</a><span class="arrow-main"></span></li>
            <li data-sub="submenu4"><a href="/contact" title="Contact">Contact</a></li>
        </ul>
    </div>

    <div class="nav-top-mobile">
        <div class="select-box form">

            <ul class="inline-block-md mb-none top-nav">
                <li>

                </li>
                
                    <li>
                        <a href="/kb/user/login?next=/kb/en/connect-odbc-table-type-accessing-tables-from-another-dbms/+source/"> Login</a>
                    </li>
                
            </ul>



        </div>
        <p class="text-center copyright">Copyright &copy; 2024 MariaDB. All rights reserved.</p>
    </div>
</div>
<div id="wrapper">
<div id="top-nav">
    <div class="container">
        <ul class="hidden-sm hidden-xs" >
            <li><a href="https://mariadb.com/kb/">Knowledge Base</a></li>
            <li><a href="https://mariadb.com/contact/">Contact</a></li>
            
                
                    <li>
                        <a href="/kb/user/login?next=/kb/en/connect-odbc-table-type-accessing-tables-from-another-dbms/+source/" rel="nofollow">Login</a>
                    </li>
                
            
            
            <li id="search-form">
                <form action="/kb/en/+search/" method="get" id="search-block-form" accept-charset="UTF-8">
                    <input id="search" title="Enter the terms you wish to search for."
                           placeholder="Search . . ." type="text"
                           name="q" value="" size="15" maxlength="128" class="form-text"
                           data-autocomplete-url="/kb/en/+search/autocomplete/">
                    <input type="hidden" name="quick" value="1" />
                    <input type="hidden" name="source" value="kb" />
                </form>
            </li>
            <li><a id="search-toggler" href="/kb/search/">Search</a></li>
            
        </ul>
    </div>
</div>
<div id="navbar-bottom" class="navbar">
    <div class="container">
        
        
        
        
        <div class="row">
            <div class="col-md-3 col-sm-9 col-xs-9">
                <a class="brand" href="/" title="MariaDB">
                    <img src="/kb/static/images/logo-2018-black.95f5978ae14d.png">
                </a>
            </div>
            <div class="col-md-9 hidden-sm hidden-xs">
                <div class="main-menu">
                    <ul id="main-menu" class="nav navbar-nav inline-block-sm">
    <li class="has-sub full-menu">
        <a href="/products" title="Products">Products</a>
    </li>
    <li class="has-sub full-menu active">
        <a href="/services" title="Services">Services</a>
    </li>
    <li class="has-sub full-menu active">
        <a href="/pricing" title="Pricing">Pricing</a>
    </li>
    <li class="has-sub full-menu">
        <a href="/resources" title="Resources">Resources</a>
    </li>
    <li class="has-sub full-menu">
        <a href="/about-us" title="About Us">About Us</a>
    </li>
    <li class="">
        <a class="button electric-eel small top-bar-right-download" href="/downloads/">Download</a>
    </li>
</ul>
                </div>
            </div>
            <div class="col-md-3 visible-sm visible-xs col-sm-3 col-xs-3 ps-rv">
                <div class="navbar-header text-right pull-right">
                    <button type="button" class="menu-control toggle-menu" id="open-menu">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="main">
    <div class="container">
        

        <div id="subheader1" class="clearfix">
            <div class="pull-left">
                
                <div id="breadcrumbs" class="breadcrumb">
                    <a href="/kb/en/">Knowledge Base</a>
                    


    
    » <a class="crumb" href="/kb/en/documentation/">MariaDB Server Documentation</a>
    

    
    » <a class="crumb" href="/kb/en/columns-storage-engines-and-plugins/">Columns, Storage Engines, and Plugins</a>
    

    
    » <a class="crumb" href="/kb/en/storage-engines/">Storage Engines</a>
    

    
    » <a class="crumb" href="/kb/en/connect/">CONNECT</a>
    

    
    » <a class="crumb" href="/kb/en/connect-table-types/">CONNECT Table Types</a>
    


    » <a class="node_link crumb" href="/kb/en/connect-odbc-table-type-accessing-tables-from-another-dbms/">CONNECT ODBC Table Type: Accessing Tables From Another DBMS</a>


                </div>
                
            </div>
        </div>
    </div>
    <div class="container" id="container-main">
        <div class="row">
            
            
                
                <aside id="sidebar-first" class="sidebar col-md-2 hidden-xs hidden-sm hidden-print">
                    
                        
                        <ul id="category_menu" class="nav nav-pills nav-stacked">
                            <li><a href="/kb/en/">Home</a></li>
                            
                                
                                    <li><a href="/kb/en/+questions/">Open Questions</a></li>
                                
                                <li><a href="/kb/en/documentation/">MariaDB Server</a></li>
                                <li><a href="/kb/en/maxscale/">MariaDB MaxScale</a></li>
                                <li><a href="/kb/en/mariadb-columnstore/">MariaDB ColumnStore</a></li>
                                <li><a href="/kb/en/connectors/">Connectors</a></li>
                            

                        </ul>
                    

                    
                        <div>
    

<div class="well well-small box actions"><div>

        <a class="btn btn-block btn-small" href="/kb/en/connect-odbc-table-type-accessing-tables-from-another-dbms/">Return to article</a>
    
</div>
</div>

</div>
                    

                    

































                </aside>
            
            
            
                
            
            
            <section id="content" class="limited_width col-md-10 clearfix">
                
                    <h1>CONNECT ODBC Table Type: Accessing Tables From Another DBMS - Source</h1>
                

                



                <div>
                    

    

    
    <div class="revision_info">
        <dl class="table">
            <dt>Revision</dt>
            <dd><a href="/kb/en/connect-odbc-table-type-accessing-tables-from-another-dbms/+r/119495/">119495</a></dd>
            <dt>User</dt>
            <dd>
<span class="user" id="user-2">
<a href="/kb/user/id/2" title="Daniel Bartholomew">Daniel Bartholomew</a>
</span></dd>
            <dt>Date</dt>
            <dd>

<span class="datetime" title="2022-10-03 08:15">2022-10-03 08:15</span></dd>
        </dl>
    </div>
    


    

    
        
        <textarea id="answer_source" class="creole_source autogrow">&lt;&lt;toc&gt;&gt;

ODBC (Open Database Connectivity) is a standard API for accessing database management systems (DBMS). CONNECT uses this API to access data contained in other DBMS without having to implement a specific application for each one. An exception is the access to MySQL that should be done using the [[connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables|MYSQL table type]].

&lt;&lt;style class=&#34;bluebox&#34;&gt;&gt;
Note: On Linux, unixODBC must be installed.
&lt;&lt;/style&gt;&gt;

These tables are given the type ODBC. For example, if a &#34;Customers&#34; table is
contained in an Access&lt;&lt;entity&gt;&gt;trade&lt;&lt;/entity&gt;&gt; database you can define it
with a command such as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table Customer (
  CustomerID varchar(5),
  CompanyName varchar(40),
  ContactName varchar(30),
  ContactTitle varchar(30),
  Address varchar(60),
  City varchar(15),
  Region varchar(15),
  PostalCode varchar(10),
  Country varchar(15),
  Phone varchar(24),
  Fax varchar(24))
engine=connect table_type=ODBC block_size=10
tabname=&#39;Customers&#39;
Connection=&#39;DSN=MS Access Database;DBQ=C:/Program
Files/Microsoft Office/Office/1033/FPNWIND.MDB;&#39;;
&lt;&lt;/code&gt;&gt;

Tabname option defaults to the table name. It is required if the source table
name is different from the name of the CONNECT table. Note also that for some data sources this name is case sensitive.

Often, because CONNECT can retrieve the table description using ODBC catalog
functions, the column definitions can be unspecified. For instance this table
can be simply created as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table Customer engine=connect table_type=ODBC
  block_size=10 tabname=&#39;Customers&#39;
  Connection=&#39;DSN=MS Access Database;DBQ=C:/Program Files/Microsoft Office/Office/1033/FPNWIND.MDB;&#39;;
&lt;&lt;/code&gt;&gt;

The ##BLOCK_SIZE## specification will be used later to set the RowsetSize when
retrieving rows from the ODBC table. A reasonably large RowsetSize can greatly
accelerate the fetching process.

If you specify the column description, the column names of your table must
exist in the data source table. However, you are not obliged to define all the
data source columns and you can change the order of the columns. Some type
conversion can also be done if appropriate. For instance, to access the
FireBird sample table EMPLOYEE, you could define your table as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table empodbc (
  EMP_NO smallint(5) not null,
  FULL_NAME varchar(37) not null),
  PHONE_EXT varchar(4) not null,
  HIRE_DATE date,
  DEPT_NO smallint(3) not null,
  JOB_COUNTRY varchar(15),
  SALARY double(12,2) not null)
engine=CONNECT table_type=ODBC tabname=&#39;EMPLOYEE&#39;
connection=&#39;DSN=firebird&#39;;
&lt;&lt;/code&gt;&gt;

This definition ignores the FIRST_NAME, LAST_NAME, JOB_CODE, and JOB_GRADE
columns. It places the FULL_NAME last column of the original table in second
position. The type of the HIRE_DATE column was changed from //timestamp// to
 //date// and the type of the DEPT_NO column was changed from //char// to
 //integer//.

Currently, some restrictions apply to ODBC tables:

# Cursor type is forward only (sequential reading).
# No indexing of ODBC tables (do not specify any columns as key). However,
  because CONNECT can often add a where clause to the query sent to the data
  source, indexing will be used by the data source if it supports it. (Remote indexing is available with version 1.04, released with MariaDB 10.1.6)
# CONNECT ODBC supports [[select|SELECT]] and [[insert|INSERT]]. [[update|UPDATE]] and [[delete|DELETE]] are also supported
  in a somewhat restricted way (see below). For other operations, use an ODBC
  table with the EXECSRC option (see below) to directly send proper commands
  to the data source.

== Random Access of ODBC Tables

In CONNECT version 1.03 (until MariaDB 10.1.5) ODBC tables are not indexable. Version 1.04 (from MariaDB 10.1.6) adds remote indexing facility to the ODBC table type.

However, some queries require random access to an ODBC table; for instance when it is joined to another table or used in an order by queries applied to a long column or large tables.

There are several ways to enable random (position) access to a CONNECT ODBC table. They are dependant on the following table options:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Option |= Type |= Used For
| Block_Size | Integer | Specifying the rowset size.
| Memory* | Integer | Storing the result set in memory.
| Scrollable* | Boolean | Using a scrollable cursor.
&lt;&lt;/style&gt;&gt;

{{{*}}} - To be specified in the option_list.

When dealing with small tables, the simpler way to enable random access is to specify a rowset size equal or larger than the table size (or the result set size if a push down where clause is used). This means that the whole result is in memory on the first fetch and CONNECT will use it for further positional accesses.

Another way to have the result set in memory is to use the memory option. This option can be set to the following values:

**0.** No memory used (the default). Best when the table is read sequentially as in SELECT statements with only eventual WHERE clauses.\\
**1.** Memory size required is calculated during the first sequential table read. The allocated memory is filled during the second sequential read. Then the table rows are retrieved from the memory. This should be used when the table will be accessed several times randomly, such as in sub-selects or being the target table of a join.\\
**2.** A first query is executed to get the result set size and the needed memory is allocated. It is filled on the first sequential reading. Then random access of the table is possible. This can be used in the case of ORDER BY clauses, when MariaDB uses position reading.\\

Note that the best way to handle ORDER BY is to set the max_length_for_sort_data variable to a larger value (its default value is 1024 that is pretty small). Indeed, it requires less memory to be used, particularly when a WHERE clause limits the retrieved data set. This is because in the case of an order by query, MariaDB firstly retrieves the sequentially the result set and the position of each records. Often the sort can be done from the result set if it is not too big. But if too big, or if it implies some “long” columns, only the positions are sorted and MariaDB retrieves the final result from the table read in random order. If setting the max_length_for_sort_data variable is not feasible or does not work, to be able to retrieve table data from memory after the first sequential read, the memory option must be set to 2.

For tables too large to be stored in memory another possibility is to make your table to use a scrollable cursor. In this case each randomly accessed row can be retrieved from the data source specifying its cursor position, which is reasonably fast. However, scrollable cursors are not supported by all data sources.

With CONNECT version 1.04 (from MariaDB 10.1.6), another way to provide random access is to specify some columns to be indexed. This should be done only when the corresponding column of the source table is also indexed. This should be used for tables too large to be stored in memory and is similar to the remote indexing used by the [[connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables|MYSQL table type]] and by the [[federatedx-storage-engine|FEDERATED engine]]. 

There remains the possibility to extract data from the external table and to construct
another table of any file format from the data source. For instance to construct
a fixed formatted DOS table containing the CUSTOMER table data, create the
table as

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table Custfix engine=connect File_name=&#39;customer.txt&#39;
  table_type=fix block_size=20 as select * from customer;
&lt;&lt;/code&gt;&gt;

Now you can use //custfix// for fast database operations on the copied
 //customer// table data.

== Retrieving data from a spreadsheet
ODBC can also be used to create tables based on tabular data belonging to an
Excel spreadsheet:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table XLCONT
engine=CONNECT table_type=ODBC tabname=&#39;CONTACT&#39;
Connection=&#39;DSN=Excel Files;DBQ=D:/Ber/Doc/Contact_BP.xls;&#39;;
&lt;&lt;/code&gt;&gt;

This supposes that a tabular zone of the sheet including column headers is
defined as a table named CONTACT or using a “named reference”. Refer to the Excel documentation for how to
specify tables inside sheets. Once done, you can ask:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from xlcont;
&lt;&lt;/code&gt;&gt;

This will extract the data from Excel and display:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Nom                |= Fonction                           |= Societe
| Boisseau Frederic   |                                     | 9 Telecom
| Martelliere Nicolas |                                     | Vidal SA (Groupe UBM)
| Remy Agathe         |                                     | Price Minister
| Du Halgouet Tanguy  |                                     | Danone
| Vandamme Anna       |                                     | GDF
| Thomas Willy        |                                     | Europ Assistance France
| Thomas Dominique    |                                     | Acoss (DG des URSSAF)
| Thomas Berengere    | Responsable SI Decisionnel          | DEXIA Credit Local
| Husy Frederic       | Responsable Decisionnel             | Neuf Cegetel
| Lemonnier Nathalie  | Directeur Marketing Client          | Louis Vuitton
| Louis Loic          | Reporting International Decisionnel | Accor
| Menseau Eric        |                                     | Orange France
&lt;&lt;/style&gt;&gt;

Here again, the columns description was left to CONNECT when creating the table.

== Multiple ODBC tables
The concept of multiple tables can be extended to ODBC tables when they are
physically represented by files, for instance to Excel or Access tables. The
condition is that the connect string for the table must contain a field
DBQ=//filename//, in which wildcard characters can be included as for
multiple=1 tables in their filename. For instance, a table contained in several
Excel files CA200401.xls, CA200402.xls, ...CA200412.xls can be created by a
command such as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table ca04mul (Date char(19), Operation varchar(64),
  Debit double(15,2), Credit double(15,2))
engine=CONNECT table_type=ODBC multiple=1
qchar= &#39;&#34;&#39; tabname=&#39;bank account&#39;
connection=&#39;DSN=Excel Files;DBQ=D:/Ber/CA/CA2004*.xls;&#39;;
&lt;&lt;/code&gt;&gt;

Providing that in each file the applying information is internally set for
Excel as a table named &#34;bank account&#34;. This extension to ODBC does not support
 //multiple//=2. The //qchar// option was specified to make the identifiers
quoted in the select statement sent to ODBC, in particular the when the table
or column names contain blanks, to avoid SQL syntax errors.

&lt;&lt;style class=&#34;redbox&#34;&gt;&gt;
**Caution:** Avoid accessing tables belonging to the currently running MariaDB server via the MySQL ODBC connector. This may not work and may cause the server to be restarted.
&lt;&lt;/style&gt;&gt;

== Performance consideration
To avoid extracting entire tables from an ODBC source, which can be a lengthy
process, CONNECT extracts the &#34;compatible&#34; part of query WHERE clauses and adds
it to the ODBC query. Compatible means that it must be understood by the data
source. In particular, clauses involving scalar functions are not kept because
the data source may have different functions than MariaDB or use a different
syntax. Of course, clauses involving sub-select are also skipped. This will
transfer eventual indexing to the data source.

&lt;&lt;style class=&#34;bluebox&#34;&gt;&gt;
Take care with clauses involving string items because you may not know whether
they are treated by the data source as case sensitive or case insensitive. If in
doubt, make your queries as if the data source was processing strings as case
sensitive to avoid incomplete results.
&lt;&lt;/style&gt;&gt;

== Using ODBC Tables inside correlated sub-queries
Unlike not correlated subqueries that are executed only once, correlated subqueries are executed many
times. It is what ODBC calls a &#34;requery&#34;. Several methods can be used by CONNECT to deal with this
depending on the setting of the MEMORY or SCROLLABLE Boolean options:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Option   |= Description 
| Default | Implementing &#34;requery&#34; by discarding the current result set and re submitting the query (as MFC does)
| Memory=1 or 2 | Storing the result set in memory as MYSQL tables do.
| Scrollable=Yes | Using a scrollable cursor.
&lt;&lt;/style&gt;&gt;

Note: the MEMORY and SCROLLABLE options must be specified in the OPTION _ LIST.

Because the table is accessed several times, this can make queries last very long except for small tables
and is almost unacceptable for big tables. However, if it cannot be avoided, using the memory method
is the best choice and can be more than four times faster than the default method. If it is supported by the driver, using a scrollable cursor is slightly slower than using memory but can be an alternative to avoid memory problems when the sub-query returns a huge result set.

If the result set is of reasonable size, it is also possible to specify the block_size option equal or slightly larger than the result set. The whole result set being read on the first fetch, can be accessed many times without having to do anything else.

Another good workaround is to replace within the correlated sub-query the ODBC table by a local copy of it because MariaDB is often able to optimize the query and to provide a very fast execution.

== Accessing specified views

Instead of specifying a source table name via the TABNAME option, it is
possible to retrieve data from a “view” whose definition is given in a new
option SRCDEF. For instance:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
CREATE TABLE custnum (
  country varchar(15) NOT NULL,
  customers int(6) NOT NULL)
ENGINE=CONNECT TABLE_TYPE=ODBC BLOCK_SIZE=10
CONNECTION=&#39;DSN=MS Access Database;DBQ=C:/Program Files/Microsoft Office/Office/1033/FPNWIND.MDB;&#39;
SRCDEF=&#39;select country, count(*) as customers from customers group by country&#39;;
&lt;&lt;/code&gt;&gt;

Or simply, because CONNECT can retrieve the returned column definition:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
CREATE TABLE custnum ENGINE=CONNECT TABLE_TYPE=ODBC BLOCK_SIZE=10
CONNECTION=&#39;DSN=MS Access Database;DBQ=C:/Program Files/Microsoft Office/Office/1033/FPNWIND.MDB;&#39;
SRCDEF=&#39;select country, count(*) as customers from customers group by country&#39;;
&lt;&lt;/code&gt;&gt;

Then, when executing for instance:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from custnum where customers &gt; 3;
&lt;&lt;/code&gt;&gt;

The processing of the group by is done by the data source, which returns only
the generated result set on which only the where clause is performed locally.
The result:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= country   |= customers
|  Brazil    |  9
|  France    |  11
|  Germany   |  11
|  Mexico    |  5
|  Spain     |  5
|  UK        |  7
|  USA       |  13
|  Venezuela |  4
&lt;&lt;/style&gt;&gt;

This makes possible to let the data source do complicated operations, such as
joining several tables or executing procedures returning a result set. This
minimizes the data transfer through ODBC.

== Data Modifying Operations
The only data modifying operations are the [[insert|INSERT]] , [[update|UPDATE]] and [[delete|DELETE]] commands.
They can be executed successfully only if the data source database or tables
are not read/only.

=== INSERT Command
When inserting values to an ODBC table, local values are used and sent to the
ODBC table. This does not make any difference when the values are constant but
in a query such as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
insert into t1 select * from t2;
&lt;&lt;/code&gt;&gt;

Where t1 is an ODBC table, t2 is a locally defined table that must exist on the
local server. Besides, it is a good way to create a distant ODBC table from
local data.

CONNECT does not directly support INSERT commands such as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
insert into t1 values(2,&#39;Deux&#39;) on duplicate key update msg = &#39;Two&#39;;
&lt;&lt;/code&gt;&gt;

Sure enough, the “on duplicate key update” part of it is ignored, and will
result in error if the key value is duplicated.

=== UPDATE and DELETE Commands
Unlike the [[insert|INSERT]] command, [[update|UPDATE]] and [[delete|DELETE]] are supported in a simplified way. Only simple table commands are supported; CONNECT does not support multi-table commands, commands sent from a procedure, or issued via a trigger.
These commands are just rephrased to correspond to the data source syntax and sent to the
data source for execution. Let us suppose we created the table:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table tolite (
  id int(9) not null,
  nom varchar(12) not null,
  nais date default null,
  rem varchar(32) default null)
ENGINE=CONNECT TABLE_TYPE=ODBC tabname=&#39;lite&#39;
CONNECTION=&#39;DSN=SQLite3 Datasource;Database=test.sqlite3&#39;
CHARSET=utf8 DATA_CHARSET=utf8;
&lt;&lt;/code&gt;&gt;

We can populate it by:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
insert into tolite values(1,&#39;Toto&#39;,now(),&#39;First&#39;),
(2,&#39;Foo&#39;,&#39;2012-07-14&#39;,&#39;Second&#39;),(4,&#39;Machin&#39;,&#39;1968-05-30&#39;,&#39;Third&#39;);
&lt;&lt;/code&gt;&gt;

The function ##now()## will be executed by MariaDB and it returned value sent
to the ODBC table.

Let us see what happens when updating the table. If we use the query:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
update tolite set nom = &#39;Gillespie&#39; where id = 10;
&lt;&lt;/code&gt;&gt;

CONNECT will rephrase the command as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
update lite set nom = &#39;Gillespie&#39; where id = 10;
&lt;&lt;/code&gt;&gt;

What it did is just to replace the local table name with the remote table name
and change all the back ticks to blanks or to the data source identifier quoting characters if QUOTED is specified.
Then this command will be sent to the data source to be executed by it.

This is simpler and can be faster than doing a positional update using a cursor
and commands such as “select ... for update of ...” that are not supported by
all data sources. However, there are some restrictions that must be understood
due to the way it is handled by MariaDB.

# MariaDB does not know about all the above. The command will be parsed as if
  it were to be executed locally. Therefore, it must respect the MariaDB syntax.
# Being executed by the data source, the (rephrased) command must also respect
  the data source syntax.
# All data referenced in the SET and WHERE clause belongs to the data source.

This is possible because both MariaDB and the data source are using the SQL
language. But you must use only the basic features that are part of the core
SQL language. For instance, keywords like IGNORE or LOW_PRIORITY will cause
syntax error with many data source.

Scalar function names also can be different, which severely restrict the use of
them. For instance:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
update tolite set nais = now() where id = 2;
&lt;&lt;/code&gt;&gt;

This will not work with SQLite3, the data source returning an “unknown scalar
function” error message. Note that in this particular case, you can rephrase it
to:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
update tolite set nais = date(&#39;now&#39;) where id = 2;
&lt;&lt;/code&gt;&gt;

This understood by both parsers, and even if this function would return NULL
executed by MariaDB, it does return the current date when executed by SQLite3.
But this begins to become too trickery so to overcome all these restrictions,
and permit to have all types of commands executed by the data source, CONNECT
provides a specific ODBC table subtype described now.

== Sending commands to a Data Source
This can be done using a special subtype of ODBC table. Let us see this in an
example:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create table crlite (
  command varchar(128) not null,
  number int(5) not null flag=1,
  message varchar(255) flag=2)
engine=connect table_type=odbc
connection=&#39;Driver=SQLite3 ODBC Driver;Database=test.sqlite3;NoWCHAR=yes&#39;
option_list=&#39;Execsrc=1&#39;;
&lt;&lt;/code&gt;&gt;

The key points in this create statement are the EXECSRC option and the column
definition.

The EXECSRC option tells that this table will be used to send a command to the
data source. Most of the sent commands do not return result set. Therefore, the
table columns are used to specify the command to be executed and to get the
result of the execution. The name of these columns can be chosen arbitrarily,
their function coming from the FLAG value:

| Flag=0: | The command to execute.
| Flag=1: | The affected rows, or -1 in case of error, or the result number of column if the command returns a result set.
| Flag=2: | The returned (eventually error) message.

How to use this table and specify the command to send? By executing a command
such as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from crlite where command = &#39;a command&#39;;
&lt;&lt;/code&gt;&gt;

This will send the command specified in the WHERE clause to the data source and
return the result of its execution. The syntax of the WHERE clause must be
exactly as shown above. For instance:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from crlite where command =
&#39;CREATE TABLE lite (
ID integer primary key autoincrement,
name char(12) not null,
birth date,
rem varchar(32))&#39;;
&lt;&lt;/code&gt;&gt;

This command returns:
&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= command |= number |= message
| ##CREATE TABLE lite (ID integer primary key autoincrement, name...## | 0 | Affected rows
&lt;&lt;/style&gt;&gt;

Now we can create a standard ODBC table on the newly created table:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
CREATE TABLE tlite
ENGINE=CONNECT TABLE_TYPE=ODBC tabname=&#39;lite&#39;
CONNECTION=&#39;Driver=SQLite3 ODBC Driver;Database=test.sqlite3;NoWCHAR=yes&#39;
CHARSET=utf8 DATA_CHARSET=utf8;
&lt;&lt;/code&gt;&gt;

We can populate it directly using the supported [[insert|INSERT]] statement:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
insert into tlite(name,birth) values(&#39;Toto&#39;,&#39;2005-06-12&#39;);
insert into tlite(name,birth,rem) values(&#39;Foo&#39;,NULL,&#39;No ID&#39;);
insert into tlite(name,birth) values(&#39;Truc&#39;,&#39;1998-10-27&#39;);
insert into tlite(name,birth,rem) values(&#39;John&#39;,&#39;1968-05-30&#39;,&#39;Last&#39;);
&lt;&lt;/code&gt;&gt;

And see the result:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from tlite;
&lt;&lt;/code&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ID |= name |= birth      |= rem
|  1  |  Toto |  2005-06-12 |  NULL
|  2  |  Foo  |  NULL       |  No ID
|  3  |  Truc |  1998-10-27 |  NULL
|  4  |  John |  1968-05-30 |  Last
&lt;&lt;/style&gt;&gt;

Any command, for instance [[update|UPDATE]], can be executed from the //crlite// table:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from crlite where command =
&#39;update lite set birth = &#39;&#39;2012-07-14&#39;&#39; where ID = 2&#39;;
&lt;&lt;/code&gt;&gt;

This command returns:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= command |= number |= message
|  ##update lite set birth = &#39;2012-07-15&#39; where ID = 2## | 1 | Affected rows
&lt;&lt;/style&gt;&gt;

Let us verify it:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from tlite where ID = 2;
&lt;&lt;/code&gt;&gt;

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= ID |= name |= birth      |= rem
|  2  |  Foo  |  2012-07-15 |  No ID
&lt;&lt;/style&gt;&gt;

The syntax to send a command is rather strange and may seem unnatural. It is possible to use an easier
syntax by defining a stored procedure such as:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
create procedure send_cmd(cmd varchar(255))
MODIFIES SQL DATA
select * from crlite where command = cmd;
&lt;&lt;/code&gt;&gt;

Now you can send commands like this:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
call send_cmd(&#39;drop tlite&#39;);
&lt;&lt;/code&gt;&gt;

This is possible only when sending one single command.

=== Sending several commands together
Grouping commands uses an easier syntax and is faster because only one
connection is made for the all of them. To send several commands in one call,
use the following syntax:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
select * from crlite where command in (
  &#39;update lite set birth = &#39;&#39;2012-07-14&#39;&#39; where ID = 2&#39;,
  &#39;update lite set birth = &#39;&#39;2009-08-10&#39;&#39; where ID = 3&#39;);
&lt;&lt;/code&gt;&gt;

When several commands are sent, the execution stops at the end of them or after
a command that is in error. To continue after //n// errors, set the option
maxerr=//n// (0 by default) in the option list.

**Note 1:** It is possible to specify the SRCDEF option when creating an
EXECSRC table. It will be the command sent by default when a WHERE clause is
not specified.

**Note 2:** Most data sources do not allow sending several commands separated
by semi-colons.

**Note 3:** Quotes inside commands must be escaped. This can be avoided by
using a different quoting character than the one used in the command

**Note 4:** The sent command must obey the data source syntax.

**Note 5:** Sent commands apply in the specified database. However, they can
address any table within this database, or belonging to another database using
the name syntax //schema.tabname//.

== Connecting to a Data Source
There are two ways to establish a connection to a data source:

# Using SQLDriverConnect and a Connection String
# Using SQLConnect and a Data Source Name (DSN)

The first way uses a Connection String whose components describe what is needed to establish the connection. It is the most complete way to do it and by default CONNECT uses it.

The second way is a simplified way in which ODBC is just given the name of a DSN that must have been defined to ODBC or UnixOdbc and that contains the necessary information to establish the connection. Only the user name and password can be specified out of the DSN specification. 

=== Defining the Connection String

Using the first way, the connection string must be specified. This is sometimes the most difficult task when creating ODBC tables because, depending on the
operating system and the data source, this string can widely differ.

The format of the ODBC Connection String is:

&lt;&lt;code&gt;&gt;
connection-string::= empty-string[;] | attribute[;] | attribute; connection-string
empty-string ::=
attribute ::= attribute-keyword=attribute-value | DRIVER=[{]attribute-value[}]
attribute-keyword ::= DSN | UID | PWD | driver-defined-attribute-keyword
attribute-value ::= character-string
driver-defined-attribute-keyword = identifier
&lt;&lt;/code&gt;&gt;

Where character-string has zero or more characters; identifier has one or more
characters; attribute- keyword is not case-sensitive; attribute-value may be
case-sensitive; and the value of the DSN keyword does not consist solely of
blanks. Due to the connection string grammar, keywords and attribute values
that contain the characters ##[]{}(),;?*=!@## should be avoided. The value of
the DSN keyword cannot consist only of blanks, and should not contain leading
blanks. Because of the grammar of the system information, keywords and data
source names cannot contain the backslash (\) character. Applications do not
have to add braces around the attribute value after the DRIVER keyword unless
the attribute contains a semicolon (;), in which case the braces are required.
If the attribute value that the driver receives includes the braces, the driver
should not remove them, but they should be part of the returned connection
string.

=== ODBC Defined Connection Attributes

The ODBC defined attributes are:
* DSN - the name of the data source to connect to. You must create this before attempting to refer to it. You create new DSNs
  through the ODBC Administrator (Windows), ODBCAdmin (unixODBC&#39;s GUI manager)
  or in the odbc.ini file.
* DRIVER - the name of the driver to connect to. You can use this in DSN-less
  connections.
* FILEDSN - the name of a file containing the connection attributes.
* UID/PWD - any username and password the database requires for authentication.
* SAVEFILE - request the DSN attributes are saved in this file.

Other attributes are DSN dependent attributes. The connection string can give
the name of the driver in the DRIVER field or the data source in the DSN field
(attention! meet the spelling and case) and has other fields that depend on the
data source. When specifying a file, the DBQ field must give the **full** path
and name of the file containing the table. Refer to the specific ODBC connector
documentation for the exact syntax of the connection string.

=== Using a Predefined DSN
This is done by specifying in the option list the Boolean option “UseDSN” as yes or 1. In addition, string options “user” and “password” can be optionally specified in the option list.

When doing so, the connection string just contains the name of the predefined Data Source. For instance:

&lt;&lt;sql&gt;&gt;
CREATE TABLE tlite ENGINE=CONNECT TABLE_TYPE=ODBC tabname=&#39;lite&#39;
CONNECTION=&#39;SQLite3 Datasource&#39; 
OPTION_LIST=&#39;UseDSN=Yes,User=me,Password=mypass&#39;;
&lt;&lt;/sql&gt;&gt;

Note: the connection data source name (limited to 32 characters) should not be preceded by “DSN=”.

== ODBC Tables on Linux/Unix

In order to use ODBC tables, you will need to have unixODBC installed. Additionally, you will need the ODBC driver for your foreign server&#39;s protocol. For example, for MS SQL Server or Sybase, you will need to have FreeTDS installed.

Make sure the user running mysqld (usually the mysql user) has permission to the ODBC data source configuration and the ODBC drivers.
If you get an error on Linux/Unix when using TABLE_TYPE=ODBC:

&lt;&lt;code&gt;&gt;
Error Code: 1105 [unixODBC][Driver Manager]Can&#39;t open lib
&#39;/usr/cachesys/bin/libcacheodbc.so&#39; : file not found
&lt;&lt;/code&gt;&gt;

You must make sure that the user running mysqld (usually &#34;mysql&#34;) has enough
permission to load the ODBC driver library. It can happen that the driver file
does not have enough read privileges (use chmod to fix this), or loading is
prevented by SELinux configuration (see below).

Try this command in a shell to check if the driver had enough permission:

&lt;&lt;code lang=bash inline=false&gt;&gt;
sudo -u mysql ldd /usr/cachesys/bin/libcacheodbc.so
&lt;&lt;/code&gt;&gt;

==== SELinux

SELinux can cause various problems. If you think SELinux is causing problems, check the system log (e.g. /var/log/messages) or the audit log (e.g. /var/log/audit/audit.log).

**mysqld can&#39;t load some executable code, so it can&#39;t use the ODBC driver.**

Example error:
&lt;&lt;code&gt;&gt;
Error Code: 1105 [unixODBC][Driver Manager]Can&#39;t open lib
&#39;/usr/cachesys/bin/libcacheodbc.so&#39; : file not found
&lt;&lt;/code&gt;&gt;

Audit log:
&lt;&lt;code&gt;&gt;
type=AVC msg=audit(1384890085.406:76): avc: denied { execute }
for pid=1433 comm=&#34;mysqld&#34;
path=&#34;/usr/cachesys/bin/libcacheodbc.so&#34; dev=dm-0 ino=3279212
scontext=unconfined_u:system_r:mysqld_t:s0
tcontext=unconfined_u:object_r:usr_t:s0 tclass=file
&lt;&lt;/code&gt;&gt;

**mysqld can&#39;t open TCP sockets on some ports, so it can&#39;t connect to the foreign server.**

Example error:
&lt;&lt;code wrap=true&gt;&gt;
ERROR 1296 (HY000): Got error 174 &#39;[unixODBC][FreeTDS][SQL Server]Unable to connect to data source&#39; from CONNECT
&lt;&lt;/code&gt;&gt;

Audit log:
&lt;&lt;code wrap=true&gt;&gt;
type=AVC msg=audit(1423094175.109:433): avc:  denied  { name_connect } for  pid=3193 comm=&#34;mysqld&#34; dest=1433 scontext=system_u:system_r:mysqld_t:s0 tcontext=system_u:object_r:mssql_port_t:s0 tclass=tcp_socket
&lt;&lt;/code&gt;&gt;

== ODBC Catalog Information
Depending on the version of the used ODBC driver, some additional information
on the tables are existing, such as table QUALIFIER or OWNER for old versions,
now named CATALOG or SCHEMA since version 3.

CATALOG is apparently rarely used by most data sources, but SCHEMA (formerly
OWNER) is and corresponds to the DATABASE information of MySQL.

The issue is that if no schema name is specified, some data sources return
information for all schemas while some others only return the information of
the “default” schema. In addition, the used “schema” or “database” is sometimes
implied by the connection string and sometimes is not. Sometimes, it also can
be included in a data source definition.

CONNECT offers two ways to specify this information:

# When specified, the DBNAME create table option is regarded by ODBC tables as
  the SCHEMA name.
# Table names can be specified as “//cat.sch.tab//” allowing to set the catalog and
  schema info.

When both are used, the qualified table name has precedence over DBNAME . For
instance:

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|= Tabname |= DBname |= Description
| test.t1  |         | The t1 table of the test schema.
| test.t1  | mydb    | The t1 table of the test schema (test has precedence)
| t1       | mydb    | The t1 table of the mydb schema
| %.%.%    |         | All tables in all catalogs and all schemas
| t1       |         | The t1 table in the default or all schema depending on the DSN
| %.t1     |         | The t1 table in all schemas for all DSN
| test.%   |         | All tables in the test schema
&lt;&lt;/style&gt;&gt;

When creating a standard ODBC table, you should make sure only one source table
is specified.  Specifying more than one source table must be done only for
CONNECT catalog tables (with CATFUNC=tables or columns).

In particular, when column definition is left to the Discovery feature, if tables with the same name are present in several schemas and the schema name is not specified, several columns with the same name will be generated. This will make the creation fail with a not very explicit error message. 

Note: With some ODBC drivers, the DBNAME option or qualified table name is useless because the
schema implied by the connection string or the definition of the data source has priority over the
specified DBNAME .

=== Table name case
Another issue when dealing with ODBC tables is the way table and column names
are handled regarding of the case.

For instance, Oracle follows to the SQL standard here. It converts non-quoted
identifiers to upper case. This is correct and expected. PostgreSQL is not
standard. It converts identifiers to lower case.  MySQL/MariaDB is not
standard. They preserve identifiers on Linux, and convert to lower case on
Windows.

Think about that if you fail to see a table or a column on an ODBC data source.

== Non-ASCII Character Sets with Oracle
When connecting through ODBC, the MariaDB Server operates as a client to the foreign database management system. As such, it requires that you configure MariaDB as you would configure native clients for the given database server.

In the case of connecting to Oracle, when using non-ASCI character sets, you need to properly set the NLS_LANG environment variable before starting the MariaDB Server.

For instance, to test this on Oracle, create a table that contains a series of special characters:

&lt;&lt;sql&gt;&gt;
CREATE TABLE t1 (letter VARCHAR(4000));

INSERT INTO t1 VALUES
   (UTL_RAW.CAST_TO_VARCHAR2(HEXTORAW(&#39;C4&#39;))),
   (UTL_RAW.CAST_TO_VARCHAR2(HEXTORAW(&#39;C5&#39;))),
   (UTL_RAW.CAST_TO_VARCHAR2(HEXTORAW(&#39;C6&#39;)));

SELECT letter, RAWTOHEX(letter) FROM t1;

letter | RAWTOHEX(letter)
-------|-----------------
Ä     | C4
Å     | C5
Æ     | C6
&lt;&lt;/sql&gt;&gt;

Then create a connecting table on MariaDB and attempt the same query:

&lt;&lt;sql&gt;&gt;
CREATE TABLE t1 (
   letter VARCHAR(4000))
ENGINE=CONNECT
DEFAULT CHARSET=utf8mb4
CONNECTION=&#39;DSN=YOUR_DSN&#39;
TABLE_TYPE = &#39;ODBC&#39;
DATA_CHARSET = latin1
TABNAME = &#39;YOUR_SCHEMA.T1&#39;;

SELECT letter, HEX(letter) FROM t1;

+--------+-------------+
| letter | HEX(letter) |
+--------+-------------+
| A      | 	    41 |
| ?      | 	    3F |
| ?      | 	    3F |
+--------+-------------+
&lt;&lt;/sql&gt;&gt;

While the character set is defined in a way that satisfies MariaDB, it has not been defined for Oracle, (that is, setting the NLS_LANG environment variable). As a result, Oracle is not providing the characters you want to MariaDB and Connect.
The specific method of setting the NLS_LANG variable can vary depending on your operating system or distribution. If you&#39;re experiencing this issue, check your OS documentation for more details on how to properly set environment variables.

=== Using systemd
With Linux distributions that use [[systemd]], you need to set the environment variable in the service file, (systemd doesn&#39;t read from the /etc/environment file).

This is done by setting the Environment variable in the [Service] unit. For instance,

&lt;&lt;code&gt;&gt;
# systemctl edit mariadb.service

[Service]
Environment=NLS_LANG=GERMAN_GERMANY.WE8ISO8859P1
&lt;&lt;/code&gt;&gt;

Then restart MariaDB,

&lt;&lt;code&gt;&gt;
# systemctl restart mariadb.service
&lt;&lt;/code&gt;&gt;

You can now retrieve the appropriate characters from Oracle tables:

&lt;&lt;sql&gt;&gt;
SELECT letter, HEX(letter) FROM t1;

+--------+-------------+
| letter | HEX(letter) |
+--------+-------------+
| Ä      | C384        |
| Å      | C385        |
| Æ      | C386        |
+--------+-------------+
&lt;&lt;/sql&gt;&gt;    
               
=== Using Windows
Microsoft Windows doesn&#39;t ignore environment variables the way systemd does on Linux, but it does require that you set the NLS_LANG environment variable on your system. In order to do so, you need to open an elevated command-prompt, (that is, Cmd.exe with administrative privileges).

From here, you can use the Setx command to set the variable. For instance,

&lt;&lt;code&gt;&gt;
Setx NLS_LANG GERMAN_GERMANY.WE8ISO8859P1 /m
&lt;&lt;/code&gt;&gt;

Note: For more detail about this, see MDEV-17501.

== {{{OPTION_LIST}}} Values Supported by the ODBC Tables

The following options can be given as comma-separated string to the {{{OPTION_LIST}}} value in the {{{CREATE TABLE}}} statement. 

&lt;&lt;style class=&#34;darkheader-nospace-borders&#34;&gt;&gt;
|=Name|=Default|=Description|
|MaxRes|0|Maximum number of rows returned by catalog functions|
|ConnectTimeout|-1|Connection timeout in seconds, unlimited by default|
|QueryTimeout|-1|Query timeout in seconds, unlimited by default|
|UseDSN|false|Use pre-configured DSN|
&lt;&lt;/style&gt;&gt;</textarea>
    


                    <div id="content_disclaimer" class="graybox">
                        Content reproduced on this site is the property of its respective owners,
                        and this content is not reviewed in advance by MariaDB. The views, information and opinions
                        expressed by this content do not necessarily represent those of MariaDB or any other party.
                    </div>
                </div>
            </section>

            
        </div>
    </div>
</div>

<!-- Footer -->
<footer id="footer">
    <div class="footer">
        <div class="container">
            <div class="row">
                <div class="col-xs-12">
                    <ul class="list-inline text-center footer-nav">
                        <li>
                            <h5>
                                <a href="https://mariadb.com/products" title="Products">Products</a>
                            </h5>
                        </li>
                        <li>
                            <h5>
                                <a href="https://mariadb.com/services" title="Services">Services</a>
                            </h5>
                        </li>
                        <li>
                            <h5>
                                <a href="https://mariadb.com/pricing" title="Pricing">Pricing</a>
                            </h5>
                        </li>
                        <li>
                            <h5>
                                <a href="https://mariadb.com/resources" title="Resources">Resources</a>
                            </h5>
                        </li>
                        <li>
                            <h5><a href="https://mariadb.com/about-us" title="About MariaDB">About Us</a></h5>
                        </li>
                        <li>
                            <h5><a href="https://mariadb.com/download" title="Download">Download MariaDB</a></h5>
                        </li>
                    </ul>
                </div>
            </div>
            <div class="row row-10">
                
                <div class="col-md-4 col-xs-12 item col-md-offset-4">
                    <div id="block-footerformcontact" class="block block-block-content block-block-contentd754ee1b-3cc9-40e7-9ef4-f504f1197fb1">
                        
                            <h5 style="font-weight: 400;">Subscribe to our newsletter!</h5>
                            <script src="//app-sj15.marketo.com/js/forms2/js/forms2.min.js"></script><form id="mktoForm_1498"></form>
                            <script>
                                <!--//--><![CDATA[// ><!--
                                MktoForms2.loadForm("//app-sj15.marketo.com", "573-PXI-984", 1498);
                                //--><!]]]]><![CDATA[>
                                //--><!]]>
                            </script>
                        
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-md-4 col-xs-12 item col-md-offset-4">
                    <div class="footer-copyright">
                        <div class="text-center">
                            <ul class="list-inline no-margin">
                                <li>
                                    <a href="/legal" title="Legal">Legal</a>
                                </li>
                                <li>
                                    <a href="/privacy-policy" title="Privacy Policy">Privacy Policy</a>
                                </li>
                                <li>
                                    <a href="/cookie-policy/" title="Cookies">Cookie Policy</a>
                                </li>
                            </ul>
                            <p>Copyright &copy; 2024 MariaDB. All rights reserved.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
</footer>
</div>

<div id="ajax_loading">
    <img src="/kb/static/images/ajax-loader.a51c5608d01a.gif" />
</div>

    <!-- Google Tag Manager -->
    <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MK2847"
                      height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-MK2847');</script>
    <!-- End Google Tag Manager -->

</body>

<script type="text/javascript" src="/kb/static/js/main.fed4ec768178.js" charset="utf-8"></script>

</html>